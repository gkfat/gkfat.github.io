[{"title":"Angular 學習筆記 - 從頭認識一個框架","url":"/2019/10/21/Angular-basic/","content":"因為公司專案使用 Angular，為了能夠駕馭，就義無反顧地投入下去從頭學起啦！Angular 真的是個學習曲線很高的框架，規範相當嚴謹，但相對來說，前面規範細一點，後續維護就方便些，在這方面確實是比 Vue 有更多優勢的。\n\n\n\nAbout AngularAngular 特色結論寫在前面：\n\nTypeScript 定義資料型別\nComponent 元件化的撰寫風格 \nServices 集中管理資料與方法\nModules 各種模組供使用\nRxJS Observables 實現 async 作業\n\nAngular 有很多特性，身為一個 JS 框架，最基本具備的就是「模組化」的能力，因此拆分成 Component 是肯定要的。不過 Angular 在母／子 Component 之間的導入與導出的關係這方面，定義得相當嚴謹。舉個例來說，你定義一個 class 內含的資料，原生 JS 只要寫個變數名跟賦值就好了，像這樣：\nexport class myComponent &#123;    myName : &#x27;&#x27;; // 先給他個空值&#125;\n但在 Angular 因為要求使用 TypeScript 的關係，你必須清楚定義這個變數是什麼型別，像這樣：\nexport class myComponent &#123;    myName:string : &#x27;&#x27;; // 這必須是一個字串！&#125;\n也許對撰寫的人而言，這樣比較麻煩，但試想專案一大、變數一多，難免會搞混每個變數應該裝什麼東西，而這樣就有助於你在看 code 的時候就先有個認知（myName 會是一個「字串」）這樣。對於其他維護專案的人而言，也比較好懂。難道你希望在維護別人寫的扣的時候，看到的是一堆亂七八糟的東西嗎！\nexport class componentA &#123;    A_1 : &#x27;&#x27;; // 鬼才知道這是要放什麼！我會通靈嗎！&#125;\n\n至於其他的特性，因為我也剛接觸不久，還不算太熟悉，就讓我們來一起發掘吧！\n可以邊寫邊看的東西\n跟著官方提供的風格來撰寫 Agnular 專案是比較好的：官方撰寫風格指南\n加速撰寫的速度：速查表\nAngular 有些獨有的專屬詞彙：詞彙表\n\n\nTypeScript\nTypeScript 入門教程\n\n接觸 Angular 之前需要先對 TypeScript 有一定程度的了解。這類的教學在網路上有相當多資源。\n定義類型\nboolean\nnumber\nstring\nvoid（表示此函式不會返回任何值）\nnull &amp; undefined\nany（表示可以被賦予任何類型的值）\n\n聯合類型顧名思義就是可以一次宣告多個類型：\nlet myNumber: string | number;myNumber = &#x27;seven&#x27;;myNumber = 7;// 不會報錯\n其他的部分，因為我也還在了解，就先不多談XD\n\nAngular CLI\n官方 CLI 指令一覽表\n\n終於進到本體了！當你很開心地想要創建一個 Angular 專案，卻發現你需要先搞好 node 跟 npm，於是決定放棄…沒啦，我們假設大家都會使用這套工具了，那就來安裝一下 CLI：\n$ npm install @angular/cli\n移動到專案資料夾下，並透過指令產生新 Angular 專案：\n$ ng new myApp// 選擇是否要啟用 routing// 選擇 CSS format// 開始創建專案啦！\n\n官方建議透過 ng generate &lt;名稱&gt; 來新增元件，透過這指令，新元件會自動 binding 進根元件 app 中，供整個 app 取用。\n透過 CLI 創建的 Angular 專案，有非常多內容，很容易頭昏眼花。這篇文章 有詳細的表可以參考哪個檔案的作用是什麼。\n\n@angular/core一些基本的資料操作都需要先導入 @angular/core，另外還有一些功能會需要導入其他的模組，例如 @angular/forms，相關的功能與模組可以參照官方提供的表：速查表\n// 在目標 component.ts 裡導入 @angular/coreimport &#123; NgModule &#125; from &#x27;@angular/core&#x27;;\n\n基本資料操作// 定義 myName 資料export class myComponent &#123;    myName:string : &#x27;小明&#x27;;&#125;&lt;div&gt;&#123;&#123; myName &#125;&#125;&lt;/div&gt; // 會印出小明\n\n實現雙向綁定// 在目標 component.ts 裡導入 @angular/formsimport &#123; FormsModule &#125; from &#x27;@angular/forms&#x27;;\n// 定義空的 myName 資料export class myComponent &#123;    myName:string : &#x27;&#x27;;&#125;&lt;input [(value)]=&quot;myName&quot; /&gt;&lt;div&gt;&#123;&#123; myName &#125;&#125;&lt;/div&gt; // 會印出在 input 輸入的值\n\n實現條件渲染// 在目標 component.ts 裡導入 @angular/commonimport &#123; CommonModule &#125; from &#x27;@angular/common&#x27;;\n\n// 如果條件符合 A，就渲染這個 template&lt;ng-template *ngIf=&quot;A&quot;&gt;    &lt;p&gt;A!!&lt;/p&gt;&lt;/ng-template&gt;// 如果條件不符合 A，就渲染這個 template&lt;ng-template *ngIfElse=&quot;!A&quot;&gt;    &lt;p&gt;Not A!!&lt;/p&gt;&lt;/ng-template&gt;\n\n實現條件判斷樣式// 在目標 component.ts 裡導入 @angular/commonimport &#123; CommonModule &#125; from &#x27;@angular/common&#x27;;\n\n// 如果條件符合 A，就 background-color=&#x27;blue&#x27;，否則 &#x27;red&#x27;[style.background-color]=&quot;A ? &#x27;blue&#x27; : &#x27;red&#x27;&quot;// 或一次判斷多個樣式[ngStyle]=&quot;&#123;    &#x27;background-color&#x27;: A ? &#x27;blue&#x27;: &#x27;red&#x27;,    &#x27;border&#x27; : A ? &#x27;1px solid red&#x27; : &#x27;none&#x27;&#125;&quot;// 綁定 class[class.&lt;className&gt;]=&quot;&lt;達成條件&gt;&quot;// 更進一步綁定 class[ngClass]=&quot;myFunction()&quot;myFunction() &#123; // 須在 component 定義 function    let myClasses = &#123;        classA: &lt;條件A&gt;,        classB: &lt;條件B&gt;    &#125;    return myClasses;&#125;\n\n以上都相當基本，所以做個筆記就過去了。\n\nRouting如果一開始創建專案時沒有選擇要 Routing 但後來又想用的話，可以使用 CLI 產生 Routing。\n$ ng generate module app-routing --module=app// --module=app：將它註冊到 AppModule 的 imports 陣列中\n\n\nComponent透過 CLI 產生的 Component，會自動幫你綁定在 app 裡。\n$ ng generate component myApp// 或更偷懶的寫法：$ ng g c myApp\n會在 app 資料夾中產生一個 myApp 資料夾，並在 app/myApp 裡產生四個檔案：\nmyApp.component.htmlmyApp.component.cssmyApp.component.tsmyApp.component.spec.ts\n\n其中 spec 檔是跑測試用的，對於規模較小的專案就比較不需要注意這個。其實也是因為我還沒了解，所以就先不談。\n\nService一樣，用 CLI 來產生一個 service：\n$ ng generate service\n\n接著，在 Component 中導入 Service：\n// 在目標 component.ts 檔案裡導入 serviceimport &#123; HttpService &#125; from &#x27;~/http.service&#x27;;// 在 export 中做以下宣告export class myComponent implements OnInit &#123;    // 宣告一個叫 _myHttp 的私有 service    constructor( private _myHttp: HttpService )&#123;&#125;        ngOnInit() &#123;        // Init 時就啟用 myMethod() 方法        this._myHttp.myMethod();    &#125;&#125;\n\n私有的概念就是不容許外部存取，有點類似 scope 的概念。\n\nObservable 與 RxJS專案有點規模了之後，總是會需要用到 async，在 Angular 中要使用 async 的方式就是 Observable 以及 subscribe（用法類似 Promise 跟 .then），不過其實我也還沒搞得很懂，所以就先筆記到這裡，之後比較清楚了再回來談。\n\n結語Angular 實在不是個好理解的框架，但學習曲線高，值得好好學習。熟練之後，對於模組化的 coding style 也能有所幫助的吧。\n\n參考資料：\n\nAngular 網頁應用程式 Hello World 教學\nLearn Angular 8 from Scratch for Beginners - Crash Course\n希望是最淺顯易懂的 RxJS 教學\nTypeScript 入門教程\n\n","tags":["Angular","JavaScript"]},{"title":"Angular 學習筆記 - 生命週期","url":"/2019/10/23/Angular-lifecycle/","content":"既然 Vue 有一堆生命週期，那想當然 Angular 應該也有吧？除了最常用到的 ngOnInit 之外，來瞭解看看其他生命週期階段，能幫助我們在寫扣時更完整地去控制一個元件在各階段應該對資料有什麼反應。\n\n\n\nComponent 的生命週期順序與互相關聯\n\n\n生命週期鉤子\n使用時機\n\n\n\nngOnChanges()\n在ngOnInit()之前，及所綁定的輸入屬性值變更時都會呼叫\n\n\nngOnInit()\n第一輪 ngOnChanges() 完成後呼叫，只調用一次\n\n\nngDoCheck()\n緊跟在ngOnChanges()和ngOnInit()後面呼叫\n\n\nngAfterContentInit()\n第一次ngDoCheck()之後呼叫，只調用一次\n\n\nngAfterContentChecked()\nngAfterContentInit()和每次ngDoCheck()之後呼叫\n\n\nngAfterViewInit()\n第一次ngAfterContentChecked()後呼叫，只調用一次\n\n\nngAfterViewChecked()\nngAfterViewInit()和每次ngAfterContentChecked()後呼叫\n\n\nngOnDestroy()\n在元件銷毀之前呼叫\n\n\nOnChanges當元件有 @Input() 且從外部傳入資料時，會在初始化之前呼叫 ngOnChanges()，且每次傳入的值改變時，都會呼叫一次。\nOnInit我們熟知的 ngOnInit()。在第一輪 ngOnChanges() 之後呼叫，元件初始化時會觸發的方法大多集中在這邊。\nDoCheckngDoCheck() 會在 Angular 核心程式執行變更偵測後呼叫，可以在這裡面寫點方法來額外處理變更偵測所無法偵測到的部分。\nAfterContentInit在 OnInit 時還無法取得元件內容，在 AfterContentInit 之後就可以取得元件內容的實體。\nAfterContentChecked在 DoCheck 週期後，會立刻觸發 AfterContentInit 週期，之後每當有變更偵測發生時，在 DoCheck 後觸發 AfterContentChecked。\nAfterViewInit 與 AfterViewChecked在 AfterContentInit 觸發後，會觸發 AfterViewInit，之後觸發 AfterViewChecked，而在每次變更偵測後也會觸發 AfterViewChecked。\nOnDestroy在元件消失時觸發，通常拿來清理資料或處理 RxJS 的 subscribe 退訂的動作，以免產生重複訂閱的行為。\n\n參考資料：\n\nAngular 官網\n[Angular 大師之路] Day 04 - 認識 Angular 的生命週期\n\n","tags":["Angular","JavaScript","LifeCycle"]},{"title":"Git 學習筆記 - 如何使用 Git 做版本控制","url":"/2021/08/28/git-flow/","content":"在前端的路途上，因為技術觀念尚不扎實，常常都是先做了再說，因此時常會遇到「咦？這個觀念不是跟我平常在用的 XXX 一樣嗎？」的情況，這次要討論的主題 Git Flow 正是其中之一。\n\n\n\n什麼是 Git Flow？版本控管很重要，你知道，我知道，獨眼龍也知道，但實際上到底該如何執行版本控管？理論觀念不知如何落實到實踐，應該是許多人共同的苦惱吧（至少我是啦）。\n先前已經認識 Git Flow 這個詞，只是一直沒有去正視它，最近因緣際會又與開發者朋友聊起，才認真去看了一下這到底是什麼東西。\n一看之下才發覺，欸，這不就是我平常在做版控的流程嗎？不過，我做的是簡易版。\n\n我的 Git Flow在公司裡與我相關的專案，都會盡量導入這套習慣，大致會有下列幾種 Git 分支：\nmaster\n容許合併：develop\n用途：發佈正式版本\n\ndevelop\n容許合併：feat/、fix/\n用途：用來做整合測試使用\n\nfeat/xxx\n容許合併：無\n用途：開發新功能，須從 master 開出分支，開發完後合併進 develop\n\nfix/xxx\n容許合併：無\n用途：修復 issue，因現行產品幾乎沒有發生需要緊急修復的狀況，通常產生 issue 都會安排時程來修復，因此不會直接合併進 master，而是會併入 develop，跟著下一次的版本更新上線\n\n與 Vincent Driessen 的 Git Flow，差別在於 hotfix 的合併規則不同，且沒有一個 release 分支。了解了這些差異後，我認為並不需要特別去修改符合到 Git Flow 規範，畢竟理論規範是一套「理想」的情況，但若一味追求 100% 符合的話，反而會造成時間或資源的浪費。\n舉個例子來說，我會使用 UML 做系統分析並製作開發規劃文件，以方便跟同事討論系統的活動流程、使用者行為、類別等，但若我連開發一個小功能都需要畫出完整的 UML 圖，那無異是多此一舉，因為就算不畫得很完整，只要足以溝通，讓開發者都明白要怎麼開發，那不就夠了嗎！\n剛剛好就好的人生哲學，套用到專案控管上也是說得通的。\n\n持續精進，追求幸福 coding目前因時常一人開發，為求盡快上線，commit 就亂打（心態糟），雖說暫時不會發生問題，但這樣下去只會留下難以查閱的紀錄，不是很好的習慣。\n在讀完 Kuma 老師的這篇文章 後，非常認同使用 git flow 的目的，就是利用簡單明確的 工作流程，讓專案不管在開發、測試、部署、維護階段都能以最小的代價，在問題發生的前期就解決，也就是一種 風險控制 手段。\n開發者會導入一堆有的沒的套件、工作流程，不就是為了培養好習慣，讓開發更順利，生活更幸福嗎？既然如此，持續不斷地改善工作流程，才是讓生活愈來愈美好的關鍵。\n\n參考資料：\n\n高見龍 - Git Flow 是什麼？為什麼需要這種東西？\n\nKuma 老師 - Git怎麼這麼難用？Git Flow + 好習慣 &#x3D; 不再苦惱\n\n","tags":["git"]},{"title":"Git 學習筆記 - 如何使用 Git 做版本控制","url":"/2019/10/24/git/","content":"身為一位工程師，版本控制的重要性就應該刻在你的靈魂深處。不做版控，表示你必需冒著風險修復更動程式碼之後出現的 bug，也代表你的網站被攻擊之後，沒辦法恢復到原來的狀態。\n\n\n所謂版本控制不只是備份專案，更主要的是將專案切成小塊，透過版本紀錄，可以清楚知道專案的進度、每一個版本改動了哪些東西、程式碼之間的差異。\n總而言之，版控是一定要的。\n\n使用 Git 的流程因為 git 相當博大精深，指令超多，我們在一般專案操作及協作上，有個基本的認知的就可以了。平常用到的都是基本功能，哪天遇到奇怪的狀況，再查資料想辦法解決就好了。\n那麼，開始吧！\n配置 git\n先安裝才能使用啊：Git 安裝教學\n\n# 顯示目前的 git 配置$ git config --list# 設定使用者$ git config user.name &quot;GK&quot;$ git config user.email &quot;gk@fat.com&quot;\n\n產生 git 目錄開始寫扣之前，先產生一個 git 目錄。有人習慣用 sourcetree，也可以，但我比較喜歡用 command line 敲指令，因為這樣比較帥（喂）。\n# 產生專案資料夾$ mkdir myProject# 移動到專案目錄$ cd myProject# 初始化 git$ git init# 看到這條訊息，表示成功 init 了Initialized empty Git repository in 你的專案目錄/myProject/.git/\n\nCommit 流程現在有了 git，可以開始做版本控管了。那麼先來看看目前是什麼情況吧。\n$ git logfatal: your current branch &#x27;master&#x27; does not have any commits yet\n\n因為你還沒做過任何 commit，所以 master 主支目前是空的狀態。讓我們來試著 commit 一下。\n# 將檔案添加到暫存區$ git add .# 將暫存區提交到倉庫$ git commit -m &quot;First Commit&quot;On branch masterInitial commitnothing to commit\n\n結果因為沒有任何檔案，所以不讓你 commit。\n好啦，開始寫扣囉。\n專案進行到一個階段後，到達設定的里程碑了，打算來更新版本。假設實作好了「新增／刪除產品」的功能，此時先用上個步驟的添加文件，把進度加到暫存區，然後將暫存區提交到倉庫，完成一個版本更新。\n# 將檔案添加到暫存區$ git add .# 將暫存區提交到倉庫$ git commit -m &quot;Update Add Product Features&quot;# 假如你發現 commit message 打錯了想要更改，可以這樣改寫最後一次的 commit$ git commit --amend -m &quot;Update Add &amp; Delete Product Features&quot;# 如果後悔了，想要撤銷暫存區的檔案，恢復到工作區$ git checkout .\n\n-m 後面那一串代表的是這次版本更新攜帶的訊息，方便之後 git log 時查看，這邊推薦使用英文，方便查詢。\n或許你會想知道能不能修改更早之前的 commit，答案是可以，只是你需要先移動到該次 commit，再用上面那招更改。\n增加／刪除文件不一定每次都要把全部更動的文件加到暫存，可以一次只加一個文件／資料夾。這樣，還沒做好的檔案就可以繼續保持狀態，而更新過的檔案就讓他進去 commit。\n# 添加目前目錄的所有文件到暫存區$ git add .# 添加指定文件到暫存區$ git add [fileName]# 刪除指定文件，並把刪除的動作加入暫存區$ git rm [fileName]# 停止追蹤文件，但不刪除文件$ git rm --cached [fileName]\n\n分支的操作分支 branch 非常方便，你可以想像把一整份項目的檔案全部拷貝出來，修改完其中一個部分，並確定能正常執行後，再合併回去項目本身，這就是分支的概念。\n特別是當多人協作的時候，每個人都可以從特定的版本去拷貝一份出來，進行自己那部份的修改，再合併回去。\n# 列出所有本地分支$ git branch# 從當前分支新增一個分支，但停留在當前分支$ git branch [newBranch]# 新建一個分支並切換過去$ git checkout -b [newBranch]# 切換到指定分支，同時更新工作區$ git checkout [branchName]# 合併指定分支到目前分支$ git merge [branchName]# 刪除分支$ git branch -d [branchName]\n\n其他操作# 顯示目前分支的版本歷史$ git log# 查詢 commit 歷史$ git log -S [keyword]\n\n\n遠程協同作業上面是在本地端操作 git 的部分，那今天當多人要協作時，又是什麼情況呢？假設今天選用的遠端倉庫是 GitHub。\n與 GitHub 連動\n直接看保哥的教學比較快：第 25 天：使用 GitHub 遠端儲存庫 - 觀念篇\n\n# 新增一個遠端倉庫$ git remote add [shortName] [url]# 下載一個遠端倉庫的完整 git 歷史$ git clone [url]# 下載遠端倉庫的所有變動$ git fetch [remote]# 下載遠端倉庫的所有內容，並將遠端的 origin/master 合併到本地 master$ git pull# 將本地的所有變動與歷史推送到遠端倉庫$ git push\n\n以上就是我常用的 git 指令。如果想對 git 有更深入的理解（其實我還有很多不懂的地方），就繼續找資源來鑽研吧！\n\n參考資料：\n\nGit 安裝教學\n30 天精通 Git 版本控管\n\n","tags":["git"]},{"title":"Golang 學習筆記 - 初步接觸 Go!","url":"/2021/09/05/golang-basic/","content":"為了看懂後端主管寫的專案原始碼，趁著最近專案開發中間空檔，趕快來學習一下 Golang！基於自學習慣，我會先概覽這個語言的基礎，之後再針對遇到的主題進一步研究。\n\n\n本次整理出三個部分：\n\nGo 的資料型別\nGo 的套件\nGo 的撰寫風格\n\n\nGo的資料型別數字（Number）\n無號整數：uint、uint8、uint16、uint32、uint64\n有號整數：int、int8、int16、int32、int64\n浮點數：float32、float64\n複數：complex64、complex128字串（String）\nstring：UTF-8 編碼的字串\nbyte：不以編碼處理的字串\nrune：型別為int32 的值布林（Boolean）\ntrue：真\nfalse：偽陣列（Array）\n以數字為索引的線性容器，長度固定。結構（Struct）\n宣告一個資料結構（非實體），具有哪些參數以及型別。指標（Pointer）\n指向儲存其他值的「位址」，透過指標可間接存取值。切片（Slice）\n以數字為索引的線性容器，長度可以伸縮。映射（Map）\n以 key-value pair 的非線性資料結構，以雜湊方式儲存在記憶體中。函式（Function）\n提供具有行為的函式，作為型別來定義變數。通道（Channel）\n在 Goroutine 之間傳遞資料。介面（Interface）\n抽象型別，不顯露內部的值，而只提供可操作的行為。\n\n\nGo的套件Go 以 package 來組織程式，因此每個原始碼檔案的開頭都會是 package &lt;fileName&gt;，以作為一個 package 來讓其他檔案調用。\n下面整理 Go 內建的一些常用套件。\nfmt：格式化輸出以及掃描輸入轉換格式：fmt.Print()、fmt.Printf()、fmt.Println()轉換格式後輸出值，如下例：\nappleColor := &quot;red&quot;fmt.Printf(&quot;Color of apple: %v\\n&quot;, appleColor)// 印出 Color of apple: redfmt.Printf(&quot;Color of apple: %q\\n&quot;, appleColor)// 印出 Color of apple: &quot;red&quot;fmt.Printf(&quot;Color of apple: %T\\n&quot;, appleColor)// 印出 Color of apple: string\n\n\n\n\n\n常用轉換格式\n\n\n\n%v\n值自然格式\n\n\n%s\n字串\n\n\n%q\n加引號的字串\n\n\n%T\n值型別\n\n\n組合字串：fmt.Sprint()、fmt.Sprintln()、fmt.Sprintf()不會印出東西，而是拿來組合字串用的。\nv1 := &quot;I&quot;v2 := &quot;am&quot;v3 := &quot;Iron Man&quot;combineString := fmt.Sprintln(v1, v2, v3)fmt.Println(combineString)// 印出 I am Iron Man\n\nos、io、bufio：存取作業系統存取作業系統：os.Open()、os.Create()、os.Remove()、os.Mkdir()建立、編輯或移除作業系統中的資料夾、檔案。\n存取命令列參數：os.Args[1:]取得開啟檔案時命令列的參數，[1:] 為刪除掉第一個參數（程式執行的路徑）。\n存取作業系統：io/ioutil.ReadFile()、io/ioutil.ReadDir()建立、編輯或移除作業系統中的資料夾、檔案。\n存取作業系統：bufio.NewWriter()實作了 io 的一些介面，能更方便地建立、編輯或移除作業系統中的資料夾、檔案。。\n\n如果你跟我一樣，覺得這些 Package 都很像，產生了「這麼多種，到底什麼時候要用哪個？差別在哪裡？」的疑惑，可以看看這篇：掘金 - Go指南10-谈谈对Golang IO读写的困惑\n\nflag：從命令列取得參數在程式碼中使用設置外來變數：flag.String()、flag.Bool()、flag.Int()、flag.Var()使用這個套件，可以讓使用者在啟動專案時代入參數，進而達到一份專案中包含多功能的效果。\n\nGo的撰寫風格使用指標（Pointer）來做變數處理在宣告一個變數時，會在記憶體中給予其一個位址來存放它的相關設定（型別、值），而 Go 提供一種方法來取用該變數的位址或者指向它做變更，這樣就不用拷貝該變數，多消耗一個記憶體位址。當需要跨函式對同一變數做存取時，這個方法相當有幫助。\n\n*：Point to，指向某個記憶體位址的值\n&amp;：Address of，某個變數的記憶體位址\n\na := 7   // 宣告一個 int 變數p := &amp;a  // 宣告一個變數 p，指向 a 的位址fmt.Printf(&quot;Value of a:%v\\n&quot;, a)// 印出 Value of a:7fmt.Printf(&quot;Address of a:%v\\n&quot;, &amp;a)// 印出 Address of a:0xc000118000fmt.Printf(&quot;Value of p:%v\\n&quot;, p)// 印出 Value of p:0xc000118000*p = 8   // 修改 *p 的值，影響到 afmt.Printf(&quot;Value of a:%v\\n&quot;, a)// 印出 Value of a:8\n\n從上述例子可以看出，p 這個變數儲存的是 a 的記憶體位址，而修改 *p 的值，等於修改到 a 的值。若將 p（a.k.a:a 的記憶體位址）作為變數在函式之間傳遞使用，再用指標指向 *p，就可以在各函式之間對同一個變數做處理，不用一直耗費記憶體來建立新的變數。\n利用 defer（延遲觸發）來做例外處理對於例外處理的這一塊，因為還沒有實際寫出一個 Go 專案，因此還不是很能領會實作方式。\ndefer（延遲處理）\n使用 defer 將工作延遲到想要的時間點執行。\n當程式結束時，多個 defer 處理將以反向順序執行，也就是 LIFO（Last In First Out）。panic（中斷）\n當發生錯誤（也就是常見的 err != nil）時，透過 panic 來將函式中斷。recover（恢復）\n在發生了 panic 而導致流程中斷後，如果想要讓程式繼續做別的處理，就可以使用 recover。但 recover 必須在 defer 中執行，否則回傳值會是 nil。\n\n\n利用 goroutine 來做併發處理Go 特色之一就是對於 concurrency 的處理，而 Go 提供的作法就是使用 goroutine。\nGoroutine（執行緒）只要在函式前加上 go，就會開啟一個新的 goroutine。\nf()    // 呼叫執行 f()go f() // 建立一個新的 goroutine 來呼叫執行 f()\nGoroutine 能讓各個函式同時進行，而不用相互等待，我以前端的 Ajax，或 Python 的 Thread 來理解，就比較能想像了。\nChannel（通道）+ Select（選擇）Channel 是運行中的 goroutine 之間的連線管道，可以讓其中一個 goroutine 發送訊息給其他 goroutine。要建構 channel，可以這樣做：\nch := make(chan int)     // 建構一個型別為 chan int 的 channelch2 := make(chan string) // 建構一個型別為 chan string 的 channelch3 := make(chan bool)   // 建構一個型別為 chan bool 的 channel\nChannel 具有 發送 與 接收 兩種基本操作，通稱為 通訊。\nch &lt;- x   // 發送 x 給 channely  &lt;- ch  // y 接收來自 ch 的值&lt;- ch     // 拋棄結果close(ch) // 關閉 channel\n可以透過 關閉 操作來讓 channel 不再接收值，若再發送值到此 channel，會引發 panic。在已經關閉的 channel 上取值，會取出直到沒有值為止，之後的接收操作會得到 nil。\n對 channel 的進一步討論，我會另外再整理一篇心得。\nMutex（互斥鎖）當有多個 gouroutine 在運行中時，有時會出現互相影響的狀況，此時需要設定讓其中一個 goroutine 先執行完畢，才能開放給其他 goroutine 使用，而這樣的方式就是 Mutex.Lock()。《精通 Go 程式設計》中舉了以下例子：\nimport &quot;sync&quot;var (    mu sync.Mutex    balance int)func Deposit(amount int) &#123;    mu.Lock()                   // 上鎖    balance = balance + amount  // 確保一次只有一個 goroutine 能改變餘額    mu.Unlock()                 // 釋放鎖&#125;func Balance() int &#123;    mu.Lock()    b := balance    mu.Unlock()    return b&#125;\n\nWaitGroup（等待群組）若今天要等到所有 goroutine 都處理完畢再進行下一個動作，除了 channel 之外，sync 套件也提供了 WaitGroup 的方式來達到這樣的效果（以 UML 來說，就是「等待分支節點結合 Join」）。\n詳細的 WaitGroup 使用方式就不贅述。\nContext（背景）叫做背景可能不太精確，context 是在剛開始用 gin 寫 http server 的時候就很常見的一個東西，但實際上還是不太了解它的意思。經過粗淺的研究後，才知道 context 的主要用途，是在背景管理所有不定數量的 goroutine。\n對於目前的我來說，理解 context 還太早，等之後對 goroutine 的使用更熟悉了，再回頭來重新認識 context，會是比較有效率的學習方式。\n\n小結經過本文的整理，對 Go 有了基本淺層的認識，也大致上知道 Go 的優勢以及風格是什麼，這樣應該會對理解主管的專案程式碼有些許的幫助（吧）。愈學愈覺得，Go 是個很棒的語言，主要是他的規範很嚴格，但又相當好懂，對於整理與維護來說非常友善！雖然目前的自己都在寫義大利麵 code，但心中也是有著寫 clean code 的嚮往啊！\n總而言之，大家一起學 Go 吧！\n\n參考資料：\n\nAlan A.A. Donovan - 精通 Go 程式設計\nPJCHENder - [Golang] Struct\niT邦幫忙 - Golang 入門到進階實戰：Day 18 常用基本庫介紹\n掘金 - Go指南10-谈谈对Golang IO读写的困惑\n小惡魔 - AppleBOY - 在 Go 語言內管理 Concurrency 的三種方式\niT邦幫忙 - Go劍復國-30天導入Golang：Golang Concurrency Pattern\n\n","tags":["後端開發","Go"]},{"title":"HTML 學習筆記 - HTML vs HTML5","url":"/2019/09/06/html-html5/","content":"我剛開始接觸網頁前端的時候，因為有太多東西要學了，就一頭栽下去學，總之先熟悉再說。忘記從什麼時候開始，這個疑問就懸在心頭：\n\nHTML 等於 HTML5 嗎？\n一直到最近，搞懂了網頁前端的架構之後，才終於有點餘力來研究這個問題。這篇文章將專注在 HTML 與 HTML5 之間的比較。\n\nHTML 與 HTML5 的定義以下是 Google 到的 HTML 定義：\n\nHTML（HyperText Markup Language），是一種用於建立網頁的標準標記語言。瀏覽器能夠讀取 HTML 標籤，並渲染出來。\n\n而 HTML5 則是：\n\nHTML5 是 HTML 最新的修訂版本，由 W3C 於 2014 年 10 月完成標準制定。目標是取代 1999 年制定的 HTML 4.01 和 XHTML 1.0 標準，以期能在網際網路應用迅速發展的時候，使網路標準達到符合當代的網路需求。\n\n也就是說，HTML5 是 HTML 的修訂版，但現今提到 HTML5 的時候，大多是指符合當代技術潮流標準的 HTML &#x2F; CSS &#x2F; JavaScript 技術組合。\n\nHTML5 新增功能為了能更符合 HTML5 標準地 coding，最好主動去學習一些 HTML5 新增的技術功能。\n\nvideo / audio\ncanvas\nSVG\nheader / section / article / nav / footer\n提供更多樣化的 API\n\n\n題外話：XHTML 與 HTML這邊很快地提一件之前曾經困擾我的問題，就是 XHTML 跟 HTML 又有哪裡不同？\n根據 W3C 的說法，差異如下：\n\nXHTML 元素必須被正確地嶔套\nXHTML 元素必須有關閉標籤\nXHTML 標籤名必須使用小寫\nXHTML 文件必須擁有根元素\n\n總結來說：XHTML 可說是 HTML 的嚴謹版本。\n\n總結總結來說：HTML5 是 HTML 的修訂版，內容包含更多語意化的標籤，目的是為了擴增 HTML 的泛用性與管理便利性，協助開發者打造更豐富的網路應用程式。\n為了讓自己寫的 code 能跟上當代潮流，學習 HTML5 標準是必要的。\n可以到這裡查看你的瀏覽器對 HTML5 的相容性：http://html5test.com\n\n參考資料\nMDN：HTML 基礎\n小春天工坊：認識HTML5 (一)緣起與差異\nW3C：XHTML 與 HTML 的不同\n\n","tags":["html"]},{"title":"JavaScript 學習筆記 - AJAX","url":"/2019/10/04/JS-Ajax/","content":"為了深入學習 JavaScript，不能單單只是會使用 Ajax ，而應進一步探討 Asyncronous JavaScript And XML（不過大多數的 XML 都已被 JSON 取代）。\n\n\n\n首先看懂 Ajax 是什麼Ajax：Asyncronous JavaScript And XML\nAjax 定義結論放前面，Ajax 就是：\n\n向 server 發送請求之後，可以不需等待結果，就先進行其他的任務。等 server 回傳結果，再行處理。\n\n為什麼需要 Ajax？稍微了解 JavaScript 的人都明白，瀏覽器在讀取 JS 檔案時是一行接著一行讀取的，當一行程式碼還沒處理完畢，就不會去動下一行，也因此一行卡住了，所有人都會等它，這就是同步處理。\n反之，你不確定這串程式碼會花多久時間，或你已經知道這會需要一段時間來處理，不想要網頁因為等待這串程式碼而卡住，就叫瀏覽器跳過去，先解讀其他程式碼，這就叫異步處理。\nAjax 就是為了完成異步處理（Asyncronous）而出現的手段。因為要呼叫 server 再得到回傳資料，你實在無法確定這會花多少時間，所以乾脆讓它在背景處理好之後再渲染到 DOM。\n延伸應用，這也能夠提升使用者體驗。舉例來說，當使用者做了某個動作，網頁上的某部分資料會變動，透過 Ajax 就不需要切換整份 HTML，而只要替換變動的那部分資料就好，這才是符合使用者體驗的行為。\n是不是很方便呢？\n\n那麼，到哪裡才買得到呢？不是啦，我是說，要怎樣才能使用如此方便的 Ajax？\nXMLHttpRequest第一種方式，就是透過原生的 JavaScript 去操作，一步步定義好每個 XMLHttpRequest 的 method 與 function，然後送出。\n關於使用原生 JS 操作 XMLHttpRequest，可以參考我之前寫的 這篇文章。\njQuery根據 從ES6開始的JavaScript學習生活 提供的範例，jQuery 在 Ajax 的操作中，提供了與操作 Promise 類似的作法。\n範例如下：\n$.ajax(&#123;    // 進行要求的網址(URL)    url: &#x27;./sample.json&#x27;,    // 要送出的資料    data: &#123;        id: &#x27;a001&#x27;    &#125;,    // 要使用的 method    type: &#x27;GET&#x27;,    // 資料的類型    dataType : &#x27;json&#x27;,&#125;)  .done(function( json ) &#123;       // 要求成功時要執行的程式碼      &#125;)  .fail(function( xhr, status, errorThrown ) &#123;       // 要求失敗時要執行的程式碼        console.log( &#x27;出現錯誤，無法完成!&#x27; )        console.log( &#x27;Error: &#x27; + errorThrown )        console.log( &#x27;Status: &#x27; + status )        console.dir( xhr )      &#125;)  // 不論成功或失敗都會執行的程式碼  .always(function( xhr, status ) &#123;    console.log( &#x27;要求已完成!&#x27; )    &#125;);\n\n老實說，我一直沒有去碰 jQuey，因為我覺得大部分時候，原生 JS 都能解決，因此一直在加深原生的基礎。\nFetch這是一個 HTML5 的新 API，而非 ES6 的新語法。但同時，它也會需要使用到 ES6 的 Promise 來實作。\nFetch 如果成功的話，會回傳一個帶 response 的 Promise 物件。它的語法類似於 jQuery，但相較之下更單純：\nfetch( url, &#123;method: &#x27;get&#x27;&#125; )    .then(function(response) &#123;        // 在這裡處理 response    &#125;)    .catch(function(err) &#123;        // 丟出 Error :(    &#125;);\n\n不過要注意的是， Fetch 只要收到回應，都會回傳 Promise，因此需要多加注意分辨成功與失敗的狀態。\n\nES6 Promise既然 Fetch 就是會回傳一個 Promise，那麼至少必須了解如何使用 Promsie。\n直接透過範例來看會更好懂：\nlet promise = new Promise(function(resolve, reject)&#123;    // 異步處理    // 處理完後，調用 resolve 或 reject&#125;);// 或者這樣做fetch( url, &#123;method: &#x27;get&#x27;&#125; ) //這裡會傳回 promise    .then(successCallback&#125;)    .catch(errorCallback);\n\n簡單地說，Promise 的操作，就是用 .then 與 .catch 去對成功與失敗的結果分別調用 callback。\n\nAsync Await既然有了實現異步處理的工具，再來就會渴求更多。如果能夠「指定」處理的順序，那當然再好不過了對吧！\n在認識 async 以前，我如果要設定處理順序，就會在「需要優先處理的 function」內包覆一個 callback，這樣在優先處理完 function 之後，才會去調用那個 callback，繼續處理接下來的部分（這樣寫又複雜又有機會出 bug）。\n但只要在 function 前加上 async，就不需要再寫 callback！只要在需要優先處理的 function 前加上 await，所有程式就都會等這個 function 處理完之後，才繼續執行。\n換句話說，async 會將 function 內的某部分程式碼變為「強迫單線程執行」。\n綜合以上的這些技術與知識，是不是覺得更能輕鬆實作 Ajax 了呢？\n\n參考資料：\n\n從ES6開始的JavaScript學習生活\nJavaScript Promise 迷你書\n\n","tags":["JavaScript","Ajax"]},{"title":"JavaScript 學習筆記 - 陣列操作方法","url":"/2019/09/14/JS-array-methods/","content":"在寫 JavaScript 時，很常會需要去操作陣列，為了加深自己對陣列操作方法的印象而整理了這一篇筆記。\n\n\n\n操作陣列的目的為了更好地分類內容，我們會把性質相近的元素放在同一個陣列，然而時常又需要對這個陣列做查找、提取、新增、刪除、或其他操作。JavaScript 內建有非常多操作陣列的方法（Methods），不過常用的也只有幾種而已。\n陣列具有兩個重要的屬性： length 與 index，透過這兩個屬性，我們得以直接接觸到目標內容，就不需要迭代整個陣列。\n操作陣列的方法\n\n\n方法\n描述\n\n\n\nforEach()\n對每一個元素執行傳入的 callback\n\n\nmap()\nreturn 一個新陣列，每一個元素為執行傳入的 callback 後的結果\n\n\nfilter()\nreturn 一個在 callback 中返回 true 的元素的新陣列\n\n\nevery()\n如果陣列每一項元素都在 callback 中返回 true，則返回 true\n\n\nsome()\n如果陣列至少有一項元素在 callback 中返回 true，則返回 true\n\n\nreduce()\n透過 callback 對陣列中每個元素做運算，並 return 一個單一的值\n\n\nconcat()\n合併兩個陣列，並 return 新陣列\n\n\ncopyWithin()\n複製陣列中某些元素，並取代陣列中指定 index 的元素\n\n\nfill()\n將陣列中的元素，替換為傳入的值\n\n\nkeys()\nreturn 一個新陣列，每一個元素是原陣列中每個元素的 index 值\n\n\nfind()\n將陣列中每一個元素帶入 callback 判斷，並回傳第一個符合條件的元素\n\n\nfindIndex()\n將陣列中每一個元素帶入 callback 判斷，並回傳第一個符合條件的元素的 index\n\n\nindexOf()\n在陣列中由前往後查找目標元素的 index\n\n\nlastIndexOf()\n在陣列中由後往前查找目標元素的 index\n\n\njoin()\n將陣列內容合併成一個字串\n\n\ntoString()\nreturn 一個字串，內容是以逗號分隔的陣列元素\n\n\nshift()\n移除並返回陣列的第一個元素\n\n\npop()\n移除並返回陣列的最後一個元素\n\n\nunshift()\n在陣列的開頭新增傳入的元素\n\n\npush()\n在陣列的最後新增傳入的元素\n\n\nreverse()\n反轉陣列元素的排列順序\n\n\nsort()\n排序陣列的元素\n\n\nslice()\nreturn 一個新陣列，內容為指定 index 及長度的元素\n\n\nsplice()\n可新增或移除指定 index 的元素\n\n\nisArray()\n判斷一個物件是否為陣列，return true &#x2F; false\n\n\nfrom()\n將物件依照 callback 轉換為陣列\n\n\nincludes()\n判斷陣列中是否含有某個元素，return true &#x2F; false\n\n\n\n常用的方法僅管操作陣列的方法有這麼多種，其實平常也不會全部都用到。以下整理了幾個我本身較常使用的方法。\nforEach() map()當想要對一個陣列中每個元素做操作，這兩種方法就很好用。 若只是想對每個元素進行操作，就用forEach()（有點類似使用 for 迴圈，不過寫法更簡潔）；若操作完後要直接回傳一個陣列，就用 map()。\nfilter() every() some()在實現篩選功能的時候，這幾個方法就很適合。\n若需要較複雜的篩選條件，就用filter() 遍歷整個陣列，並直接返回一個新陣列；而 every() 與 some() 可以拿來做比較簡單的篩選，只需判斷 true &#x2F; false。\nsort()需要對陣列做排序的時候使用。若要做大小排序，只需代入下列匿名函式：\narray.sort(function(a, b) &#123;  return a - b;&#125;);\n當然還可以做更複雜的排序。\nreduce()有點類似 forEach() 與 map() 的用法，但更適合在要對整個陣列運算出一個單一結果時使用。\nfind() findIndex()能夠用抽象的描述找到符合條件元素的 index。通常接著會搭配使用其他的方法，像是取出該元素或複製、刪除等等。\nindexOf() lastIndexOf()如果已經知道目標元素的長相，這兩個方法能夠直接查詢 index，方便你做接下來的操作。\nsplice()能夠很方便地在陣列中指定位置刪除／新增元素，有三個參數可以代入：\narray.splice(index, howmany, items)\n\n\n\n參數\n描述\n\n\n\nindex\n必需。為正／負整數，指定在陣列中開始操作的位置。\n\n\nhowmany\n必需。指定要刪除的數量，若不刪除元素則設置為 0。\n\n\nitems\n可選。向陣列新增的元素。\n\n\npush()若只是需要將新元素插入到陣列的最後，直接使用 push()。\nslice()從陣列中複製一段內容，並回傳一個新陣列。\narray.slice(start, end)\n\n\n\n參數\n描述\n\n\n\nstart\n為正／負整數，指定在陣列中開始操作的位置。\n\n\nend\n可選。提取片段的結尾位置，若有設定則提取到該位置的前一個元素，若不設定就會提取到最後。\n\n\nreverse() join()這兩個方法有時候會搭配使用，當你想要把一個字串內的每個字元反轉過來的時候，先使用字串的操作方法 split() 將其變成陣列，再做 reverse() 反轉每個元素，最後用 join() 再讓他變成一個字串。\n\n參考資料：\n\nTutorial Republic - JavaScript Array Methods\nMDN - 陣列的運用\nOXXO Studio - JavaScript Array 陣列操作方法大全 ( 含 ES6 )\n\n","tags":["JavaScript"]},{"title":"JavaScript 學習筆記 - Closure","url":"/2019/09/17/JS-closure/","content":"面試以來常常碰到的一題，就是 closure。我知道中文叫閉包，但光看字面根本猜不出意思。為了加深對 closure 的印象，而整理了這篇筆記。\n\n\n\n什麼是 Closure？\n閉包是函式以及該函式被宣告時所在的作用域環境。\n\n在讀到 MDN 為解釋閉包而舉的範例時，我產生了一個疑惑：巢狀函式可以取用上一層的變數，那是不是代表：巢狀函式最內部的函式，也可以取用全域變數呢？\n接著繼續往下讀，看到這段對作用域的說明：\n\n「作用域」一詞，指的正是作用域環境在程式碼指定變數時，使用 location 來決定該變數用在哪裡的事情。巢狀函式的內部函式，能訪問在該函式作用域之外的變數。\n\n為了驗證我的疑惑，我寫了一段簡單的 code：\nvar a = 123;function outside()&#123;    console.log(&quot;from outside&quot;, a)    return (function inside()&#123;        console.log(&quot;from inside&quot;, a)    &#125;)()&#125;outside(); \n得到的結果如下：\nfrom outside 123from inside 123\n我得到的結論就是，閉包是一個封閉的環境，外部宣告的變數可以傳入使用，內部宣告的變數無法被外部使用。\n那麼再來的要問的就是，我什麼時候才會需要用到閉包？\n\n閉包的使用時機？簡單地說，當我需要在當某事發生時觸發某個 function，那閉包就相當實用。在此之前我最常用的方法是為一個 DOM 元素綁定 eventListener，再去觸發一個單獨宣告的 function。\n這樣寫當然沒問題，不過若這個事件要觸發的內容需要多做一些運算，那可能就要宣告好幾個 function，除了要一直命名之外，四散的 code 也會增加除錯的複雜度（還有看 code 的爽度）。\n了解閉包的特性之後，感覺對 JS 的理解又更深一層了。\n\n參考資料：\n\nMDN - 閉包\n胡立 - 所有的函式都是閉包：談 JS 中的作用域與 Closure\n從ES6開始的JavaScript學習生活\n\n","tags":["JavaScript","closure"]},{"title":"JavaScript 學習筆記 - Prototype 與 Class","url":"/2019/09/18/JS-class-prototype/","content":"我認為這兩個概念放一起討論會比較好融會貫通，因此整理成同一篇。關於為什麼 JS 需要有繼承與原型鏈，網路上有很多文章在說明緣由，我就不再贅述了。\n\n\n\n物件？類別？實例？首先，我們對 JS 的理解就是「這是一個物件導向的語言」。\n由於我是非本科，對物件導向的概念其實並不了解，因此看了一些文章之後，總結出下列定義：\n「物件（Object）就是類別（Class）的實例（Instance）」\n那麼問題來了。什麼是類別？什麼又是實例？\n類別（Class）與物件（Object）類別，是定義一件事物的抽象特點。\n例如定義一個「人的類別」，可能會有年齡、姓名、生日、身分證字號、聯絡電話、住址…等等特徵。\n物件，就是產生出一個符合這個類別的實例。\n例如：\n&#123;    姓名： 小明,    年齡： 18,    聯絡電話： 0912345678,&#125;\n\n小明就可說是一個「人」的類別的實例。\n\nJavaScript 其實沒有真正的 Class這是一個有點令人混淆的觀念。我們既說 JS 是物件導向的語言，但他又沒有真正的 Class，那 JS 的物件到底是怎麼建立的？不是基於 Class 嗎？\nJavaScript 的類別（Class）Class 其實是一種宣告函式的語法。但並不像函式一樣會 hoisting，因此順序很重要。若要使用 Class 來建立 Object，你需要先宣告 Class，才能取用他。下面這個例子就會拋出錯誤：\nvar p = new Person(); // ReferenceErrorclass Person &#123;&#125;;\n\n一個 Class 中只能有一個建構子（constructor），否則會報錯。constructor 是用來建立和初始化一個類別的物件。\n在 Class 中除了 constructor 之外，還可以宣告這個類別的 methods。例如我可以說：\nclass Person &#123;    constructor(name, age)&#123;        this.name = name;        this.age - age;    &#125;    talk() &#123;        console.log(&#x27;Hello! I&#x27;m &#x27; + this.name);    &#125;&#125;var ming = new Person(&#x27;小明&#x27;, 25); // 宣告一個叫小明的實例\n\n但是正如前文提到的，Class 並不是真正的在宣告類別。以下引用自Summer。桑莫。夏天，說明 Class 的真相：\n\nClass 依舊是利用 [[Prototype]] 委派機制來實作的，它只是個語法糖而已，也就是說，Class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結，因此若不小心變更了父類別的方法或屬性，子類別與其實體都會受到影響。\n\n既然知道了 Class 就是個方便宣告類別的工具之後，接著就要來理解 prototype 的概念了。\n\nJavaScript 的 prototype我讀到一個比較好理解 prototype 的說法。先回到 Class，假設你一次宣告了 10 個 Person，此時雖然他們的 name 與 age 都不同，但每個 Person 都有一個重複的 talk() method。這樣是不是有點佔用資源了？\n這時可以把 talk() 指定到 Person.prototype 上面，讓所有 Person 的 instance 都可以使用這個方法。\n從另一個角度來看，可以從 Person.prototype 去找到底下的 Person，這就是原型鏈的概念。\n什麼是 __proto__ ？用結論來說，__proto__ 就是 instance 往 parent 尋找的方法。\n例如尋找 ming.__proto__，就會找到 Person。\n\n參考資料：\n\n物件導向(Object Oriented Programming)概念\nMDN - 繼承與原型鏈\nTechBridge 技術共筆部落格 - 該來理解 JavaScript 的原型鍊了\nJS原型鏈與繼承别再被問倒了\n從ES6開始的JavaScript學習生活\n你懂 JavaScript 嗎？#21 ES6 Class\n\n","tags":["JavaScript","class","prototype"]},{"title":"JavaScript 學習筆記 - ES5 vs ES6","url":"/2019/09/12/JS-ES5-ES6/","content":"學習 JavaScript 一段時間了，也逐漸熟悉各種語法的運用，覺得差不多可以更深一層地認識這個語言了。因此趁此機會，就來整理一篇筆記，探討 ES5 與 ES6 之間的差異。\n\n\n定義網路上對於 ES5 ES6 ECMA2015 ECMAScript JavaScript 的定義眾說紛紜，剛接觸 JS 的時候我也看得一頭霧水。直到後來看到這篇文章，讓我在一團亂中理清了一絲思緒。\n\n一文讀懂 JavaScript 與 ECMAScript 的區別\n\n根據上文，我可以清楚地定義，我想了解的是 ES5(ECMA2009) 與 ES6(ECMA2015) 之間的差異，也就是新版本究竟做了哪些改動。\n\nES5 與 ES6首先是 JavaScript 的特性，也就是初學者(*也就是我)開始學習 JavaScript 時，最先學習到的基礎部分。這裡就不特別區分 ES5 才新增的語法了。\n\n變數宣告：var\n流程控制：if...else for while switch\n嚴格模式：&#39;Use Strict&#39; \n陣列操作：every / some / forEach / filter / indexOf / map / reduce …等方法\n資料操作：JSON.parse() JSON.stringify()\nObject 方法\n操作 DOM BOM\n\n再來是 ES6 新增的部分。\n\n變數宣告：let const\n字串模板：以 &#96;&#96; 包覆的 html 內容，動態內容則直接寫在 $&#123;&#125; 內部\n解構賦植\n箭頭函示：() =&gt; &#123;&#125;\nClass\nModules\nPromise\n\n\n總結ES6 新增的語法，目前使用得比較熟練、也明白特性的大概就變數宣告、箭頭函式、字串模板。其他的新語法，還有待練習。之後再來寫筆記整理對這些語法的認識吧。\n\n參考資料\n一文讀懂 JavaScript 與 ECMAScript 的區別\n「譯」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎麼回事？\nJavaScript、ES5和ES6的介绍和區别\n\n","tags":["JavaScript"]},{"title":"JavaScript 學習筆記 - XMLHttpRequest","url":"/2019/09/12/JS-XMLHttpRequest/","content":"學習程式以來碰到一個較難突破的關檻，就是「如何向 server 發送要求」。到目前為止常見的方法有三種：\n\n用 jQuery 實現\n用 fetch 實現\n用 axios 實現\n但我的想法是想先了解背後的運作原理，以及用原生 JS 如何實現，之後再去使用方便快速的方法。\n\n很多免費資源都可以在 YouTube 上搜尋到，例如這一個頻道： Traversy Media，他在這支影片裡就帶著你用原生 JS 操作 XMLHttpRequest：影片\n\nXMLHttpRequest在了解如何操作之前，我想知道的是：「什麼是 XMLHttpRequest？它是為了什麼目的而存在的？」\n找了一些資料來看之後，這是定義：\n\nXMLHttp 是一組能被 web 瀏覽器內嵌的 script 語言呼叫的 API，通過 Http 在瀏覽器和 web 伺服器之間收發 XML 或其它資料。其最大的好處在於可以動態地更新網頁內容。\n\n向伺服器發送一個 request，回傳資料後動態地更新網頁內容，對使用者而言，不用一直重複載入整個頁面，當然比較符合使用者體驗。\n同時，XMLHttpRequest 也是實現 AJAX 重要的一環，在使用 asyncronous（非同步）技術來要求資料後動態更新網頁內容，讓使用者不須等待資料全部載完，就能夠先瀏覽網頁的其他內容，UX 因此更上一層。\n但對現今的前端而言，AJAX 已經是必備技術，這也是我覺得必須盡快熟悉的原因。\n\nXMLHttpRequest 的屬性\nXMLHttpRequest.onreadystatechange在 readyState 屬性之狀態改變時被呼叫，可用於監聽 request 請求狀態的改變。\n\nXMLHttpRequest.readyState回傳一個 0~4 之間的整數值，每個值代表的意義如下：\n\n\n\n值\n狀態\n意義\n\n\n\n0\nUNSENT\n客戶端已建立\n\n\n1\nOPENED\nopen() 方法已被呼叫\n\n\n2\nHEADERS_RECEIVED\nsend() 方法已被呼叫，且可取得 header 與狀態\n\n\n3\nLOADING\n回應資料下載中，此時 responseText 會擁有部分資料\n\n\n4\nDONE\n完成下載\n\n\n\n本表格節自 MDN：XMLHttpRequest.readyState\n\n\nXMLHttpRequest.status依據狀態不同，回傳介於 100~500 間的 HTTP status code，分別代表不同意義，例如代表成功回應的 200 OK 或廣為人知的錯誤 404 Not Found。\n\n更多狀態代碼請參照 MDN：HTTP status code\n\n\nXMLHttpRequest.responseText回傳一個 DOMString，其內容為請求之回應的文字內容。如請求失敗或尚未發送，則為 null。若確定 responseText 為 JSON 格式，通常會接著做 JSON.parse() 並接著處理資料。\n\n\n\n如何發送 XMLHttpRequest假設要發送一個簡單的 XMLHttpRequest 向伺服器要求資料，需要做到以下幾點來確保能夠成功返回資料。\n\n建立一個 XMLHttpRequest\n定義請求的方法（GET POST PUT DELETE…）\n定義監聽流程\n送出請求\n\n用範例表示的話就是：\nlet myFunction = function() &#123;    //創建 XMLHttpRequest    let xhr = new XMLHttpRequest();        //定義送出要求的網址    let url = &#x27;&lt;你想送出要求的網址&gt;&#x27;;        //定義請求的方法    xhr.open(&#x27;GET&#x27;, url, true);        //定義監聽流程（當 status 改變時呼叫）    xhr.onreadyStatusChange = function() &#123;            //顯示當前進度        console.log(&#x27;readyState&#x27;, xhr.readyState, &#x27;status&#x27;, xhr.status)                //確定請求成功時執行以下動作        if ( xhr.status === 4 &amp;&amp; xhr.readyState === 200 ) &#123;            //你想對回傳資料做些什麼？            console.log(responseText);        &#125;    &#125;    //送出請求    xhr.send();&#125;\n\n以上就是我目前了解到的發送 XMLHttpRequest 流程，以及每一步的意義。當然請求方法不只一種，XMLHttpRequest 也不會這麼單純，還有更多的細節需要處理。不過這部分就留待之後遇到再來研究如何解決吧。\n\n參考資料\n維基百科：XMLHttpRequest\nMDN：XMLHttpRequest\nMDN：XMLHttpRequest.readyState\nMDN：HTTP status code\n\n","tags":["JavaScript","XMLHttpRequest"]},{"title":"JavaScript 學習筆記 - hoisting","url":"/2019/09/15/JS-hoisting/","content":"JavaScript 這語言在某些時候並不是很嚴謹，所以特別去了解那些奇怪的部分，能夠大幅減少莫名其妙卡住的除錯時間。\n\n\n\n什麼是 hoisting？我們都知道，JS 是一個單線程語言，這也就是說，瀏覽器在讀 code 時，是一行一行讀下來的。那麼：\n\n宣告變數\n使用變數\n\n按照邏輯，一定要按照這個順序，才能正常 working，對吧？舉個例子：\nvar a = 100;console.log(a); //100\n\n那麼，這樣寫會印出什麼呢？\nconsole.log(a); //print?var a = 100;\n\n很簡單嘛！你說。根據你學過的 JS，這個變數還沒有被宣告，所以無法使用，所以會印出 ReferenceError: a is not defined。\n結果一打開 console，嚇死人了！居然跑出 undefined。這代表的是， a 這個變數已經被宣告了，但還沒有被賦值。沒有值這一點很容易理解，畢竟你在賦值以前就使用它嘛，這很正常。但變數宣告 var a; 的部分居然被提到前面來了！？\n這就是 hoisting，提升的概念。\n那麼，再進一步。不只變數會 hoisting，function 也會，而且 function 會優先於變數。用例子來看的話就是像這樣：\nconsole.log(a);var a;function a()&#123;&#125;; \n\nconsole 會印出什麼？答案是 Function: a。\n\nES6 的 hoisting如果你跟我一樣，對 JavaScript 已經有一定熟悉度但還沒熟透，你可能會知道 ES6 新增的變數宣告方法 let 與 const，可能也會有個模糊的概念：這兩個宣告方法沒有 hoisting。\n我原本也是這樣想的，直到讀到這一篇文章：TechBridge - 我知道你懂 hoisting，可是你了解到多深？\n\n這篇文章完整提到 (1)什麼是hoisting？ (2)為什麼我們需要 hoisting？ 以及 (3)hoisting是怎麼運作的？建議各位好好閱讀一下，真的可以理清很多事情。\n\n結果 let 跟 const 還是有 hoisting 的，只是行為跟 var 不同。\n\n參考資料：\n\nTechBridge - 我知道你懂 hoisting，可是你了解到多深？\nMDN - Hoisting\nJavaScript: 变量提升和函数提升\nHoisting in JavaScript\n\n","tags":["JavaScript","hoisting"]},{"title":"Linux 學習筆記 - Journalctl","url":"/2022/03/12/linux-journalctl/","content":"systemd 裡，除了用來操作服務的 systemctl 指令，另外還有一個 journalctl 指令，能夠用各種方式查看服務執行的日誌。也就是說，這對於除錯也是很有幫助的。\n\n\n\njournalctl 指令Journalctl 指令的結構如下：\n$ journalctl &lt;條件篩選&gt;\n\n所有日誌// 顯示所有日誌（從最早的紀錄開始）$ journalctl// 反轉日誌的輸出順序（從最新的紀錄開始）$ journalctl -r// 或$ journalctl --reverse// 根據時間顯示日誌$ journalctl -S -U// 或$ journalctl --since= --until=\n\n追蹤日誌// 顯示最新的日誌，並不斷顯示新產生的日誌$ journalctl -f// 或$ journalctl --follow\n\n控制日誌格式\nshort：預設值，每條日誌佔一行\nverbose：以結構化的格式顯示日誌\njson：將日誌 json 化，每條日誌佔一行\njson-pretty：將日誌 json 化，以人方便閱讀的方式排列\ncat：顯示日誌內容，不包含任何數據\n\n// 控制日誌顯示的格式$ journalctl -o &lt;格式選項&gt;// 或$ journalctl --output=&lt;格式選項&gt;\n\n以重要性顯示日誌\n0：emerg\n1：alert\n2：crit\n3：err\n4：warning\n5：notice\n6：info\n7：debug\n\n// 根據重要性等級顯示日誌$ journalctl -p// 或$ journalctl --priority=&lt;等級範圍&gt;\n\n分頁功能// 在分頁中跳到日誌的底部$ journalctl -e// 或$ journalctl --pager-end// 不要分頁顯示日誌$ journalctl --no-pager\n\n\n\n參考資料：\n\nUbuntu Manpage: journalctl\n\n","tags":["Journalctl","Systemd","Linux"]},{"title":"Linux 學習筆記 - Systemd","url":"/2022/03/12/linux-systemctl/","content":"有時難免會碰到網站掛掉，找到問題後發現是後端服務出錯的情況。身為純前端，這時通常會手足無措，因為必須等後端修復之後，才能回報 user。此時如果前端工程師能自行進入後端環境，做一些基本的偵錯處理，是否就能提升效率呢？\n\n\n\n初步理解 SystemdSystemd 是一個 Linux 的系統與服務管理器。當你們家的網站是架設在 Linux 環境，最好還是熟悉一下 systemd 比較好。\n關於 Systemd 的一些粗淺整理：\n\n每一個系統服務稱為一個單元（unit）\nUnit 有很多種類型：系統服務（.service）、掛載點（.mount）、sockets（.sockets） 、系統設備（.device）、交換分割區（.swap）、檔案路徑（.path）、啟動目標（.target）、由 systemd 管理的計時器（.timer）\n大部分的伺服器都屬於 .service 類型\n可使用 systemctl 指令管理各項單元\n所有可用單元的路徑如下：// 軟體包安裝的單元/usr/lib/systemd/system/// 系統管理員安裝的單元（優先級更高）/etc/systemd/system/\n\n\nsystemctl 指令Systemctl 指令的結構如下：\n$ systemctl 操作指令 &lt;單元&gt;\n\n0. 分析系統狀態\n顯示系統狀態// 顯示系統狀態$ systemctl status// 顯示所有啟動中的單元$ systemctl// 或$ systemctl list-units// 顯示執行失敗的單元$ systemctl --failed\n\n1. 啟動／停止單元\n啟動／停止單元// 啟動運行單元$ systemctl start &lt;單元&gt;// 停止運行單元$ systemctl stop &lt;單元&gt;// 重新啟動單元$ systemctl restart &lt;單元&gt;\n\n2. 查找單元\n檢測系統單元狀態\n// 檢查單元狀態$ systemctl status &lt;單元&gt;// 檢查單元是否正在運行$ systemctl is-active &lt;單元&gt;// 檢查單元是否有設定開機自動啟動$ systemctl is-enabled &lt;單元&gt;// 檢查單元是否啟動失敗$ systemctl is-failed &lt;單元&gt;\n\n列出單元\n// 列出所有單元（包含已啟動／未啟動）$ systemctl list-units --all// 列出所有已啟動的單元$ systemctl list-units// 列出所有未啟動的單元$ systemctl list-units --all --state=inactive// 只列出系統上所有 service type 的單元$ systemctl list-units --type=service\n\n查看單元內部設定檔\n$ systemctl cat &lt;單元&gt;\n\n3. 進一步設定單元\n啟用、停用開機自動啟動單元\n// 啟用開機自動啟動單元$ systemctl enable &lt;單元&gt;// 停用開機自動啟動單元$ systemctl disable &lt;單元&gt;\n\n禁用特定單元\n// 禁用特定單元（禁用後就無法直接或間接啟動）$ systemctl mask &lt;單元&gt;// 取消禁用單元$ systemctl unmask &lt;單元&gt;\n\n\n參考資料：\n\nArchLinux - systemd\nLinux命令大全 - systemctl命令\n\n","tags":["Systemd","Linux","Systemctl"]},{"title":"使用 Hexo + Github 來架設個人部落格","url":"/2019/06/25/myblog-with-hexo/","content":"最近強烈感受到寫技術筆記的需要，因此花費幾天的時間研究 Hexo，並且把這個站給架起來。雖然我本身也有其他的部落格，但程式還是歸程式，感覺比較能專心寫。\n\n安裝 Hexo先確定有安裝 node.js &amp; git，再依官網步驟安裝 Hexo。\n$ npm install -g hexo-cli\n在做上面這步驟時，我遇到權限不足的問題卡了很久，後來照以下步驟就解決了。雖然很多人推用 sudo 解決，但更多人建議不要使用 sudo，好像很容易造成不可挽回的錯誤，於是我就沒用了。\n解法如下，來源請點此\n$ npm config set user 0$ npm config set unsafe-perm true$ npm install -g hexo-cli\n就成功安裝 Hexo 了，真是可喜可賀！\n\n選擇主題 themes部落格最重要的門面，當然不能隨便決定啊！雖然要換很快啦，但我還是選了一陣子。最後決定使用滿多人使用的 NexT。\nNexT 的官方 Github\n輸入下面這行來把 NexT 資料搬下來：\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n就會自動下載主題並在 themes 資料夾底下創建 next 資料夾了，主題所需的東西都在裡面，接下來只要在 _config.yml 中將 theme 改為該主題名稱，像這樣：\ntheme: next\n就可以成功套用主題了！嗚拉拉\n\n發佈一篇文章 Post一、確認 Hexo 已正確啟動$ hexo -v\n如果有正確啟動 Hexo，會跑出版本說明，這時可以放心繼續下去。\n二、新增一個 post（一）新增發文\n$ hexo new &quot;new post name&quot;\nnew post name 也可以是中文喔。\n會在 source&#x2F;_posts 目錄底下新增一個 日期_new_post_name.md 文件，此時就可以進去編輯你的新文章了。\n（二）新增草稿\n$ hexo new draft &quot;new draft name&quot;\n會在 source&#x2F;_drafts 目錄底下新增一個 日期_new_draft_name.md 文件，寫完可以用這個命令來發佈：\n$ hexo publish [layout] &lt;filemame&gt;\n（三）更新 Hexo\n上述兩步都只是在 source 資料夾中更新文章而已，你還需要這個步驟才能更新 Hexo：\n$ hexo generate  //或 hexo g\n三、推上 github（一）更改 _config.yml 內容\n為了將 Hexo 與 Github 連結起來，你需要在 _config.yml 中填入相關資料。\nurl: https://&lt;你的 github name&gt;.github.io/&lt;你的 repository name&gt;/root: /&lt;你的 repository name&gt;/\ndeploy:  type: git  repo: &lt;你的 repository url&gt;\n（二）安裝 Hexo-git-deployer\n$ npm install hexo-deployer-git --save\n\n（三）執行部署\n以下三種命令都會將 Hexo 部署上去，其中的 generate 就是直接幫你把更新 Hexo 也一併做了。\n$ hexo deploy --generate\n$ heso generate --deploy\n$ hexo g -d\n\n\n關於個人部落格的架設就寫到這邊，算是流程的紀錄，也希望之後能幫到遇到一樣的問題的人，感覺 Hexo 還有很多坑等著讓人踩啊。\n","tags":["hexo"]},{"title":"Nginx 學習筆記 - 使用 Nginx","url":"/2019/10/24/nginx/","content":"最近被主管要求使用 Nginx 來放專案的測試版本，方便跟 PM 溝通（就不用一直叫 PM 過來看我表演 ng serve，直接 build 好丟網址給他就可以測試了）。原本以為 Nginx 安裝一下改個 config 很方便，結果還是在意想不到的地方卡了一下，因此整理成筆記分享，以免有人遇到相同的問題。\n\n\n\n安裝 Nginx\n安裝起來先：Nginx 官網\n\n因為我是用 Mac，所以直接開啟 Terminal 輸入：\n$ brew install nginx\n\n\n指令# 啟動$ sudo nginx# 更新$ nginx -s reload# 停止$ sudo nginx -s stop\n\n打開 http://localhost:8080，就會看到 Nginx 在跟你招手了！\n\n配置我們當然不可能滿足於用 localhost:8080，所以現在要來改配置。\n先找到 nginx.conf 檔，Mac 的檔案位置如下：\n/usr/local/etc/nginx/nginx.conf\n\n開啟 nginx.conf 檔之後，找到下面這個區塊：\nserver &#123;    listen 8080 default_server;&#125;\n改為下面這樣子：\nserver &#123;    listen 80 default_server;&#125;\n\n這樣，Nginx 就會在你的 localhost（或你電腦的 ip 位址）執行了。\n\n根目錄localhost 預設會打開的檔案如下：\nserver &#123;    listen 80 default_server;    # listen [::]:80 default_server ipv6only=on;    server_name localhost;    root /usr/local/Cellar/nginx/1.17.3_1/html; # 預設根目錄    index index.html; # 預設開啟的檔案&#125;\n\n那麼，接下來就可以來設定各個路由會通往哪裡了：\nserver &#123;    location / &#123;        # 因為是空的，會去找 server 的預設路徑    &#125;        # 設定 localhost/my-website/    location /my-website/ &#123;        alias /Users/user/desktop/myProject/; # 設定檔案目錄的路徑        index index.html; # 要開啟的檔案    &#125;&#125;\n\n如果訪問 localhost/my-website/，就會去開啟 myProject 專案底下的 index.html 檔了。耶！\n\n權限問題不曉得是什麼原因，我在訪問網址的時候，localhost/ 可以正常顯示，但 localhost/my-website/ 卻一直出現 403 forbidden。找了各種可能的原因後，最後判斷應該是因為訪問者的權限不足，因此不能訪問檔案。\n因此在 nginx.conf 的第一行，調整訪問者的權限：\n# 原本是這樣，也是註解的狀態# user nobody# 把註解打開，並改成這樣user root owner;\n\n就可以訪問各個路徑了。\n只是不曉得對方拿到 root 權限，可以對你的網站做什麼事，一顆心撲通撲通地亂跳。但反正用 Nginx 來架站，我目前僅用於公司內部測試用，就暫時不擔心這個問題啦。\n好了，以上就是感覺充滿坑的 Nginx 架站筆記。\n\n參考資料：\n\nNginx 官網\nInstalling Nginx in Mac OS X Maverick With Homebrew\n\n","tags":["nginx"]},{"title":"Node.js 學習筆記 - 初次接觸 Node.js","url":"/2019/12/22/Node-intro/","content":"由於公司有使用 Node.js 撰寫的專案，之後有維護需求，因此對 Node.js 一竅不通的我，只好趕快惡補。\n\n\n\n1. Overview1.1 為什麼要學 Node.jsNode.js 有許多優勢，但對我而言最直接的原因就是，因為我在前端使用的是 JavaScript，Node.js 是使用 JavaScript 的後端語言，因此對於理解上，就少了一層障礙。\n\n使用 JavaScript 的後端語言\n能夠自己寫 web server\n非同步 IO，事件驅動的特性，降低等待時間與耗能\n許多第三方套件（如 express、socket…等等）\n入門簡單（我不相信）\n\n1.2 基本認識 Node.js\nNode.js - 維基百科Node.js之深入理解特性\n\n如上所述，Node.js 的特性有以下幾個：\n\n事件驅動才調用 I&#x2F;O 資源，減少耗能\n使用 JavaScript 語言編寫\n\n1.3 如何學習 Node.js那麼要學習 Node.js，具體來說應該要理解哪些事呢？我列出幾個學習重點，也方便日後檢視是否真的學會了這些東西：\n\nJavaScript 基礎\nUnix &#x2F; Linux 指令\n理解伺服器端腳本\n模組和套件管理\n異步 I&#x2F;O 與 Async 流程控制庫（Input &#x2F; Output，網路、文件、資料庫、使用者輸入等等的進出）\n事件處理機制\nNode.js 與 AJAX\n跨平台與跨瀏覽器的相容\nTCP&#x2F;UDP 網路程式設計\nHTTP&#x2F;HTTPS 應用程式設計\nNode.js 與資料庫互動\n\n1.4 Node.js 可以做些什麼？\n撰寫 REST APIs\n即時服務（線上聊天室、連線遊戲）\n串接資料庫、blog、社群平台\n\n我認為伺服器最主要功能就是做資源的處理，而前端是接口與呈現。所以在初步學習了 Node.js 之後，應該就會朝撰寫 API、串 WebSocket、串資料庫等方向去進一步探索吧。畢竟學程式就是要做出想做的作品嘛。\n\n2. Node.js 基本概念2.1 線程處理與事件循環2.1.1 線程處理\n收到 request\nthread 應對\nrequest 處理完成，thread 釋放\n\n所謂線程處理，當收到請求時就依照以上步驟處理，因此當同時湧入大量請求時，伺服器負荷就會提高。例如 Apache 6,7,8,9 等版本。\n2.1.2 事件循環Node.js 的事件循環特性就能比較好地 handle 這問題，他的運作方式如下：\n\n開一個事件等待循環（event loop）\n收到 request\n將 request 塞入處理隊列中，然後繼續監聽其他 request\nrequest 處理完成後，調用 I&#x2F;O，結束 request\n\n也就是說，Node.js 以一個監聽器來處理 request 的「請求」與「完成」，並不會從頭到尾監聽，而只在這兩種事件出現時才調用 I&#x2F;O 資源。\n2.2 阻塞處理／非阻塞處理2.2.1 阻塞處理會發生阻塞處理的語言有：Java、Ruby、PHP、Asp.Net 等，因為他們會照以下方式處理程序：\n\n先執行的函式尚未處理完，不會執行下一個函式\n所有的函式都要等待前一個函式處理完\n塞車\n\n2.2.2 非阻塞處理而 Node.js 就能有效解決這個問題，但相對地也會有弱勢。\n\n呼叫函式時，需傳入一個 callback，處理完畢後調用 callback\n一旦函式開始處理，不用等待結果，就繼續運行下一個函式\n整份檔案順暢跑完（但各函式不會同時處理完畢）！\n\n2.3 Node_modulesNode.js 本身的 node_modules 就提供了相當多的套件可以使用，隨便舉幾個例子：\n\nhttp：Web http request 處理\nfs：文件處理\npath：路徑處理\nurl：網址處理\neventEmitter：request 事件監聽處理\nuuid：產生不重複 ID 的小工具\n\n而在部署時，並不需要將這些套件一起打包，只要在 config.json 的 dependencies 註明清楚，就可以透過 npm install 來安裝所有需要的套件包了。\n\n3. 開始 Node.s！3.1 “Hello World”是的，學習一個新語言，當然都是從最基本的跟世界打個招呼來開始。首先知道如何運行它，然後才能一步步深入。\n\n檢查 Node.js 版本\n\n$ node -v // v10.16.0 // 看得到版本代表有成功安裝 Node.js$ npm -v // 6.9.0 // 同時檢查 Node Package Manager 版本$ node // 並跳轉至大於符號代表成功進入 Node 環境&gt;\n\n\n在 Node.js 環境下，呼叫 console 輸出 Hello World\n\n&gt; console.log(&quot;Hello World&quot;); // Node 環境下可以撰寫 JavaScriptHello World // 這是 Node 吐出來的，成功使用 Node 了！undefined // 看到這個不要緊張，這是返回 console.log 這函數的值\n\n\n其他操作\n\n$ .help // 查看 Node 幫助$ .exit // 離開 Node\n\n3.2 進一步的 Hello World當然，我們不希望每次都在 Node.js 裡面打一堆程式碼，最好是能呼叫執行檔案。那麼具體的操作方法是怎麼樣呢？\n\n建立一個 helloworld.js 檔\n檔案內容為： var str = &#x27;Hello Node.js!&#x27;;console.log(str);\n然後，在控制台使用 Node 運行這個檔案 $ node helloworld.js // 或 node helloworldHello Node.js!\n成功使用 Node.js 呼叫檔案了！\n\n\n4. 結語關於 Node.js 的入門學習，就到這邊告一段落了。接下來我會繼續學習如何使用 express 框架來開發 Node.js app，接著就要逐漸嘗試實作出即時聊天室或小遊戲啦！\n\n參考資料：\n\nNode.js - 維基百科\nNode.js Crash Course - Traversy Media\nNode.js之深入理解特性\n\n","tags":["Node.js"]},{"title":"OOP 學習筆記 - 什麼是物件導向程式設計？跟前端開發有什麼關係？","url":"/2021/11/23/oop-basic/","content":"近來在開發網頁時，逐漸能感受到事先訂好類別規格的重要性。比方說，這次要新增的功能是「股票觀察清單」，若能事先定義好觀察清單、觀察對象（EX: 股票）、觀察清單的行為（EX: 建立、編輯、移除），那麼在開發時會清楚許多，往後若要為這功能增加或改動內容（維護階段），都可以從源頭來改。降低 bug 發生機率的同時，也能讓其他同事更迅速理解自己寫的架構，減少溝通鴻溝。為此，該來將先前粗略讀過的「物件導向程式設計」概念，拿出來再理解一遍了。\n\n\n\n什麼是物件導向程式設計（Object-Oriented Programming）？\n根據 《UML 物件導向系統分析與設計》，在物件導向設計中，類別（Class）的實例（Instance）就叫做物件（Object）。物件作為程式的基本單元，每個物件都是獨立的個體，應該要能夠接收資料、處理資料、傳出資料，採用物件導向來設計程式，能夠大大提升程式的靈活性與可維護性。\n\n\n類（Class）：定義一個東西的抽象特徵。包含資料的形式以及對資料的操作。\n物件（Object）：是類的實例，類產生的具體例子。\n\n就像這類文章常見的那個例子一樣：\n// 宣告一個 class，包含屬性以及方法class Person &#123;    name;        constructor(pname) &#123;        this.name = pname;    &#125;        murmur() &#123;        console.log(&quot;我是&quot; + this.name + &quot;嗎?&quot;);    &#125;&#125;// 宣告實例let ming = new Person(&quot;小明&quot;);let hua  = new Person(&quot;小花&quot;);ming.murmur();  // 我是小明嗎?hua.murmur();   // 我是小花嗎?\n\nPerson 是一個 Class，而 new Person() 則會建立一個實例 Object。\n在初步了解物件導向是什麼了之後，就來看看它有哪些特性，以及需要依照怎樣的原則來設計程式吧。\n\n物件導向四大特性物件導向有四個特性：\n\n抽象（Abstraction）\n封裝（Encapsulation）\n繼承（Inheritance）\n多型（Polymorphism）\n\n說真的，當時的我看到這些鬼東西，真是害怕極了。如今卻能大致理解這四項特性分別是在描述什麼，應該是有所成長了吧。\n1. 抽象（Abstraction）我自己覺得這可能是最難理解的概念，但是一但理解了抽象性，對於思考程式如何設計會有相當大的幫助。其實換個角度想，我們在生物課不就學過抽象性了嗎？\n\n不信你看：生物分類法 - 維基百科\n\n就我目前的理解，抽象就是一種分類的方法。透過整理來將一類對象抽象化，而定義出這個類別的特性及行為，以幫助人快速識別對象。這個道理是從大自然中學習來的，而套用在程式設計上也相當合用。\n就像上面的例子一樣，小明與小花都屬於 Person 這個 Class，但各自的 name 及 murmur 的內容卻又不同。\n2. 封裝（Encapsulation）封裝是將 Class 的部份內容包裝、隱藏起來的方法。這是一種防止外界呼叫、存取物件內部實作細節的手段。聽起來很美好，問題是親愛的 JavaScript 中並沒有簡單明瞭的設計來實現物件導向封裝特性。幸好，我們有 TypeScript。透過 public private protected 就能夠快速簡便地讓開發者及系統辨別公開或私有屬性。\n3. 繼承（Inheritance）一個物件有時會在父類別底下延伸出子類別，子類別會比父類別更加具體（但不是實例），且繼承父類別的屬性。\n比方說開頭提到的觀察清單類別，因為需要能夠容納「股票」類別以及「外匯」類別，就可以再分為「股票觀察清單類」及「外匯觀察清單類」。源頭都屬於觀察清單類別，但各自又多了部分不同的屬性。\n4. 多型（Polymorphism）由繼承產生的相關的不同類別，這些類別對同樣的呼叫，會給出不同的反應。這是什麼意思呢？讓我們修改一下開頭的案例：\nclass Person &#123;    murmur()&#123;&#125; // 此處定義了一個方法，但沒有內容&#125;class MalePerson extends Person &#123;    murmur() &#123;        console.log(&quot;我是男漢子!&quot;); // 定義內容    &#125;&#125;class FemalePerson extends Person &#123;    murmur() &#123;        console.log(&quot;我是女漢子!&quot;); // 定義內容    &#125;&#125;let man = new MalePerson();let woman = new FemalePerson();man.murmur();   // 我是男漢子!woman.murmur(); // 我是女漢子!\n\n如上所示，在新類別繼承了 Person 這個類別時，也一併繼承了它的 murmur() 方法，並各自覆蓋了方法的內容。接著建立實例並呼叫此方法的時候，就會印出各自的內容，這就是多型。\n\n物件導向設計 SOLID 原則\nSOLID (物件導向設計) - 維基百科每個專案沒聽到一次就渾身不對勁的 S.O.L.I.D. 原則\n\nSOLID 原則是取以下五個原則的開頭組合而成，剛好也表示依循這樣原則的程式設計會很「穩固」。因為要深入淺出這五個原則，以我目前的功力還辦不到，所以只能簡單做個筆記。有錯誤的部分也歡迎隨時指正。\n\n單一職責原則（Single responsibility principle, SRP）\n開放封閉原則（Open-Close principle, OCP）\n里氏替換原則（Liskov substitution principle, LSP）\n介面隔離原則（Interface segregation principle, ISP）\n依賴反轉原則（Dependency inversion principle, DIP）\n\n1. 單一職責原則(Single responsibility principle, SRP)一個模組應該只對一個角色負責。\n\n依我的理解，這意思就是一個 calcTotal() 的函式，不應該同時做多件事情，例如修改 CompanyWallet.total 以及 CustomerWallet.total，以防哪天因為變更了一點點 calcTotal() 的程式碼，卻影響到其他內容，這是會出大事的。\n那麼依循這個原則，可以這樣做：\n// 建立一個抽象的介面，包含計算函式但不實作class TotalCalculator &#123;    public function calcTotal(): number;&#125;// 各自繼承並實作計算函式的內容class CompanyWallet extends TotalCalculator &#123;    private total: number;    public function calcTotal() &#123;        // 公司的計算方式    &#125;&#125;class CustomerWallet extends TotalCalculator &#123;    private total: number;    public function calcTotal() &#123;        // 客戶的計算方式    &#125;&#125;\n\n目前的我還不能很好地舉例解釋單一職責原則，或許是因為尚未滲透進骨髓，必須再繼續加深印象才行。\n2. 開放封閉原則(Open-Close principle, OCP)開放擴展：當需求變更時，模組可以擴充功能。封閉修改：當進行擴沖時，模組不需修改既有的程式碼。\n\n當一個已經完成的模組要加上新功能時，不應修改原本的程式碼，否則很有可能會在想像不到的地方產生 bug，這是很好理解的。\n3. 里氏替換原則(Liskov substitution principle, LSP)子類別要能取代它的父類別。\n\n大意是說，子類別繼承了父類別，實作時需依循下列原則：\n\n子類別的先決條件不能比父類強，但可以比父類弱\n子類別的後置條件不能比父類弱，但可以比父類強\n父類別的不變條件必須被繼承\n\n乍看很抽象，但用具體例子來看的話，就很好理解。基本上就是子類別實作的範疇不應跳脫父類別，而應該在父類別的範疇內實作。\n4. 介面隔離原則(Interface segregation principle, ISP)使用不到的功能，不應被呼叫。\n\n一樣又是很抽象的說明，具體舉個例子就是：\nclass Website &#123;    public function login();    public function logout();    public function adminMode();&#125;class Client &#123;    site = new Website();    site.login();    site.logout();    site.adminMode(); // 明明是 client 為什麼可以開啟 admin?&#125;\n\n因為 adminMode() 並不是開放給所有人使用的，但偏偏 client 又可以呼叫它，這就表示違反了介面隔離原則。此時需要將 adminMode() 隔離出來，只有管理員可以實作這個介面，並呼叫本功能。\n5. 依賴反轉原則(Dependency inversion principle, DIP)高層模組不應依賴低層模組，而都應該依賴抽象。\n\n當高低模組之間有依賴關係時，此時就會有危險產生。萬一高層模組依賴低層模組，而低層模組的實作內容修改了，高層模組就會發生預期外的結果，要不然就必須去修改高層模組內容，出現高耦合的狀況。\n為了避免，可以在高低模組之間抽出一個抽象的介面，透過抽象去實作方法，這樣就可以降低耦合。\n以上就是 SOLID 原則。以我目前的程度，大概只有一知半解，而且要依照原則來設計程式，又比單純理解物件導向更難了。\n但我相信 OOP 能讓程式變得更好，所以我會持續精進 SOLID！\n\nOOP 如何應用在前端開發？前端工程師在學習的過程中幾乎都會看到「JavaScript 是一個基於物件導向的語言」這句話，接著就會看到原型鏈（Prototype）相關的介紹。當時的我還不是很能把這兩件事串在一起，如今看來之間的關聯再明顯不過了。\n再回到前面的例子，其實 JavaScript 的 Class 並不是真正的類別，而只是個偽裝過的 function，也就是常聽人家說的那一句：「Class 只是 ES6 的語法糖」。但是 ES6 究竟為何要這樣欺騙我們的感情呢？還不是為了讓你開發上更方便（巴頭）！關於這件事，MDN 是這樣說的：\n\n繼承與原型鏈 - MDNJavaScript 是個沒有實做 class 關鍵字的動態語言，所以會對那些基於類別（class-based）語言（如 Java 或 C++）背景出身的開發者來說會有點困惑。（在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JavaScript 仍然是基於原型（prototype-based）的語言）。\n\n我目前對於 Prototype 還沒有系統性地去理解過，只大致上知道是怎麼回事而已，但這不是本篇主旨，所以先跳過。\n我關心的是，究竟 OOP 如何應用在前端開發？\n搭配神兵利器 TypeScript因為目前公司使用的前端框架是 Angular，使用的主要語言是 TypeScript，也因此潛移默化地習慣了事先定義型別、類別的作法，自然養成好習慣。現在要我用原生 JS 開發，如果要像 TypeScript 那樣定義型別，要花一大堆功夫，心裡會很不是滋味。\n如果 OOP 搭配使用 TypeScript，那麼在開發事前就能將類別、資料型別定義得更清楚了，倘若再用上 UML（這才發現我沒寫過 UML 的筆記，看來也該補一篇了）來分析專案，在前期就徹底分析需求，就可以大大減少遺漏需求的問題，也可以減少發生後端都已經部署好 API 了，前端卻在串接過程中發現資料格式不合用想要改結構的情況。這有時候是會影響到 DB schema 的，若能事先定好，就能在前期發現該釐清的事項。\n因此接下來我會用 TypeScript 來呈現 JavaScript 的部分。\n從「物件」作為出發點來思考程式是「本質先於存在」的產物，必須先有「需求」，而後才有對應的「解決方案」。若要在專案開發中導入 OOP，必須從需求分析切入，後續發展才能順暢。讓我們先假設一個需求：\n開發一個檔案上傳管理系統。\n\n好啦，老實說就是這個經驗：後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！，不過當時的我並沒有將物件導向設計應用進去，因此若現在回頭看程式碼，不吐血才怪。\n現在從頭來思考這個需求，我會先做 UML 中的類圖分析，拆解出這個需求中包含下列類（Class）：\n// 檔案class UploadFile &#123;    public id: number;      // 檔案 ID    public name: string;    // 檔名    public content: string; // 檔案內容，以 base64 儲存    public path: string;    // 上傳的路徑&#125;// 使用者class User &#123;    public id: number;      // 使用者 ID    public name: string;    // 使用者名稱    public uploadFile()&#123;&#125;   // fn: 上傳檔案    public removeFile()&#123;&#125;   // fn: 刪除檔案    public readRecord()&#123;&#125;   // fn: 查詢上傳紀錄&#125;// 上傳紀錄class UploadRecord &#123;    public id: number;      // 上傳紀錄 ID    public fileID: number;  // 檔案 ID    public userID: number;  // 使用者 ID    public uploadTime: Date;// 上傳時間&#125;\n\n花個 3 分鐘簡單拆解而已，就能大致看出個輪廓了（當然要能開始開發還遠遠不夠）。類圖分析完後，接著就能用活動圖來分析使用者、前端、後端、資料庫之間的活動，以及活動內容，再來就能推出各自要開發的項目細節了。\n\n結論如此麻煩地套用 OOP，究竟會產生哪些影響？\n\n分析：搭配 UML 能更系統化分析專案，在前期就盡可能釐清 spec\n開發：開發過程中能清楚正在處理的資料型別，不用瞎子摸象亂猜一通\n協作：他人能更迅速理解程式碼的邏輯，工程師間的溝通更順暢\n維護：debug 或修改屬性、擴充功能都更方便\n\n最重要的，是幫助自己在程式設計的領域中提升思維高度，以更全面的角度來看待整個專案，對於成長很有幫助。\n所以，一起來學吧！\n\n參考資料：\n\n物件導向程式設計 - 維基百科\nUML 物件導向系統分析與設計 - Jim Arlow\nTypeScript | 從 TS 開始學習物件導向 - Interface 用法 - 神Q超人\n\n","tags":["OOP","TypeScript","SOLID"]},{"title":"後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！","url":"/2021/09/05/python-file-upload-service/","content":"公司裡有個部門每天都會產出一定份量的繪圖檔案，目前都是人工手動上傳到 NAS，但是對於資料夾與檔案的命名卻沒有任何規範，根本就是個野生叢林！該部門的主管想建立一套規則來更有系統地管理這些檔案（還有管理這些繪圖人員），因此開了這個需求給我。\n\n\n\n需求解析\n開發\n部署\n\n\n需求解析前言（客戶）某部門主管：「可以幫我做一個上傳圖紙到 NAS 的工具嗎？簡單就好，不要花你太多時間。」GK：「（你知道我只是個前端工程師嗎？）好啊，沒問題，你的需求是什麼？」（客戶）某部門主管：「？就是剛剛說的那樣啊…」GK：「？？？哦……好…好吧…」\n由於某些原因，我的部門裡沒有後端工程師，沒有系統分析師，也沒有 DBA，全部都得自己來。幸好經歷過 這個歷練，我對於要建立一個系統服務，還算是有點概念。\n看來，這又是天上掉下來的機會，要讓我拓展視野了。\n系統分析在開始寫程式之前絕對該做的事，就是系統分析（SA）。首先把我的角色從 產品經理（PM） 切換成 系統分析師（SA），經過一番思考後，犧牲了不少腦細胞，但也得出以下架構（因為涉及公司隱私，所以公開的部分有簡化過）。\n系統架構\n\n\n服務\n選擇\n\n\n\nVM\nLinux CenteOS 7（既有）\n\n\nBackend Application\nPython3\n\n\nDatabase\nMariaDB（既有）\n\n\nWeb Application\nAngular 11\n\n\nHTTP Server\nApache\n\n\n\n本來是想學著用 Golang 開發的，但為了讓另外幾位 Python 底的工程師也能夠維護或擴充這個服務，就選擇用 Python 了（反正兩個都是從頭學）（但寫完這個專案後我真的是很討厭 Python）。\n\n活動\n上傳檔案功能\n可將檔案上傳到 NAS 目標資料夾，並儲存紀錄至 DB\n\n\n查詢紀錄功能\n可取得 DB 上傳紀錄，並做分頁、排序、篩選\n\n\n同步 NAS\n可同步 NAS 上資料夾與 DB 客戶、型號\n\n\n\n類別設計\n檔案上傳紀錄類\n客戶類\n型號類\n\n資料庫設計\nNAS 同步紀錄表\n客戶表\n型號表\n檔案上傳紀錄表\n\nAPI 設計\n同步 NAS API\n上傳檔案 API\n查詢紀錄 API\n查詢客戶、型號 API\n\n介面\n上傳檔案頁面\n取得客戶、型號\n選擇檔案，組成目標格式\n上傳檔案\n\n\n查詢紀錄頁面\n同步 NAS\n查詢上傳紀錄（分頁、排序、篩選）\n\n\n\n大致上就完成了一次簡易版 SA 分析，接著就是依據這些規格來開發了（角色切換成 後端工程師(Back End)）。如果開發文件寫得我看不懂，我就定死你 SA！欸，等等，SA 也是我自己？\n\n開發好的，那麼來到了工程師們最喜歡的開發橋段了。有了辛辛苦苦做好的 SA 分析，就可以照著步驟無腦開發了！當然因為一條龍都是我，就沒有把規格訂得太詳細了，開發時再想就好了（這真的不是一個好習慣，後來在整理時發現，要寫 API 文件或後續要再擴充，都要再從程式碼裡找規格）。\n後端開發選擇套件因為 Python 套件非常多，在網路上查詢整理後，選擇了這幾個套件來做核心處理。\n\n\n\n套件\n處理範圍\n\n\n\nflask\nhttp server\n\n\nflask-sqlalchemy\nDB 相關操作\n\n\npysmb\nNAS 相關操作\n\n\n專案架構愉快的開發時間就咻地略過，來看看完成後的模樣吧。以下是憑直覺後端基礎寫出來的架構。\nfile-uploader|-- app.py                // 專案的進入點，啟動 http server|-- deploy.sh             // 讓懶人可以一鍵部署到虛擬機的 Shell Script|-- venv                  // Python 必備虛擬環境，套件都裝在裡面|-- config                // DB、NAS 連線帳號密碼設定檔    |-- config.py|-- connection            // 處理連線，原本裡面有 DB 連線，後來發現不需要    |-- conNas.py|-- model                 // Model 與 Table schema    |-- dbTable.py|-- view                  // API routes 以及分配到哪個 Controller    |-- fileUpload.py|-- controller            // 業務邏輯    |-- uploadControl.py    |-- retrieveControl.py    |-- deleteControl.py    |-- fetchControl.py    |-- customerControl.py    |-- syncControl.py\n\n以上是大致上的專案架構說明，大部分 Controller 都大同小異在對 NAS、DB 做一些基本的 CRUD 操作。比較值得一提的是在 controller/uploadControl.py 裡面對上傳檔案的操作，若一次上傳多個檔案，有開 thread 來並行處理，大概的程式碼如下：\n// 上傳檔案def UploadFile():    uploadList = []  // 要上傳的檔案陣列        // 從 API 取出要上傳的檔案，加入 uploadList    for item in request.get_json()[&#x27;files&#x27;]:        uploadList.append(dict(            state = 0,    // 檔案上傳成功／失敗狀態            file  = item        ))        // 產生多個 Thread，分別執行檔案上傳    for file in uplaodList:       uplaod_thread = threading.Thread(           target=UploadControl.UploadFileThread,           args=(item,)   // 少了那個逗號會有問題，我也不曉得為什麼       )       file = upload_thread.start()              // 等全部的 thread 都完成後才進行下一步       uplaod_thread.join()        // 一些跟 DB 有關的操作    // 回傳 API response// 每個 Thread 上傳檔案的操作def UploadFileThread(file):    // 一些跟 NAS 有關的操作    // 回傳檔案上傳結果\n\n\n前端開發前端就不是筆記的重點了，就是依 SA 分析的功能來開發。\n\nModel：用 typescript 的 namespace 來建立類別 struct\nUI：用 Bootstrap 達到最基本的呈現\nUX：跳過 wireframe，靠經驗\n\n拖曳上傳檔案比較值得一提的地方是，這次嘗試用 Angular 的 directive 來製作出「拖曳式上傳檔案」的監聽檔案拖曳區域，內容相當簡易：\n// dropZone.directive.tsimport &#123; Directive, HostListener, Output, EventEmitter &#125; from &quot;@angular/core&quot;;import * as $ from &#x27;jquery&#x27;;@Directive(&#123;  selector: &#x27;[appDropZone]&#x27;&#125;)export class dropZoneDirective &#123;  @Output() filesDropped = new EventEmitter&lt;any&gt;();  @HostListener(&#x27;dragover&#x27;, [&#x27;$event&#x27;]) onDragOver($event: any) &#123;    $event.preventDefault();    $event.stopPropagation();    $(&#x27;.dropZone&#x27;).addClass(&#x27;grayBGC&#x27;);  &#125;  @HostListener(&#x27;dragleave&#x27;, [&#x27;$event&#x27;]) public onDragLeave($event: any) &#123;    $event.preventDefault();    $event.stopPropagation();    $(&#x27;.dropZone&#x27;).removeClass(&#x27;grayBGC&#x27;);  &#125;  @HostListener(&#x27;drop&#x27;, [&#x27;$event&#x27;]) public onDrop($event: any) &#123;    $event.stopPropagation();    $(&#x27;.dropZone&#x27;).removeClass(&#x27;grayBGC&#x27;);  &#125;&#125;// upload.html&lt;div class=&quot;dropZone&quot; *ngIf=&quot;canUpload&quot; appDropZone (filesDropped)=&quot;chooseFile($event)&quot;&gt;    &lt;input #fileDropRef id=&quot;fileDropRef&quot; type=&quot;file&quot; multiple            (change)=&quot;chooseFile($event)&quot;&gt;    &lt;h5&gt;拖曳檔案至此處&lt;/h5&gt;    &lt;label for=&quot;fileDropRef&quot;&gt;        或點擊此處選擇上傳檔案    &lt;/label&gt;&lt;/div&gt;\n\n基本上就只是在監聽「拖曳進入」「拖曳離開」事件，為區域加上 css 讓使用者得到回饋，然後在「丟下檔案」的時候，emit 給 upload.ts 的 chooseFile() 接收。\n另外還有用 cdkDropList 結合 bootstrap 卡片呈現，製作出拖拉調整順序的介面。除外的就不值一提，很普通XD。\n\n部署後端跟前端都寫好之後，部署的順序如下：\n\n將後端專案複製到虛擬機專案路徑底下\n對目標 DB 做 Migration\nSystemctl 建立 service daemon file\n啟用服務\n\n\n將前端專案複製到虛擬機專案路徑底下\n設定 Apache proxy，將目標網址導向後端 API 或前端網頁\n設定防火牆，讓使用者能存取 port\n\n\n\nDatabase Migration在 Migration 這關其實也摸索了滿久的，後來逐漸認知到步驟其實很單純（我用 flask-sqlalchemy 來做 DB Migration）：\n\nflask db migrate 來產生 migration file（比對 dbTable.py 中 table schema 與目標資料庫中的 schema）\n檢查 upgrade file 裡的操作是否都符合需求\nflask db upgrade 就 Migrate 成功啦！\n\n至於 backup、rollback，就之後再考慮吧。\nLinux Service\n之前有整理過一份 systemctl 的操作，指令都在 這裡。\n\n\n在虛擬機建立 system daemon file\nsystmectl daemon-reload 來載入 service\nsystemctl start &lt;service&gt; 就啟用服務啦！\n\n\n結語現在回頭看看，2021 年初時我還連 DB 怎麼下 query 都搞不懂，連 Linux 都不會操作，過了半年後，居然能夠一條龍做到下列事項：\n\n使用 Python 撰寫 http server、撰寫 API 文件、撰寫方便部署的 Shell Script\n串接 MariaDB 資料庫、執行 DB migration、串接 NAS\n使用 Angular 串接 http server\n部署後端服務、前端專案到虛擬機\n設定 Apache、防火牆讓使用者能夠連線\n\n真的是滿感謝有這個大好機會，讓我對整套專案的執行有了進一步的了解（但不敢說這就叫全端），經過了一兩季後，這個專案也已經逐漸成長到了 1.5 版本，對於後端也愈來愈能理解了。接下來想把重心放在學習 Golang，以及加強後端 Concurrency 處理的觀念。\n\n參考資料：\n\nTechBridge 技術共筆 - 簡明 SQL 資料庫語法入門教學\n\n","tags":["後端開發","Python","API","NAS"]},{"title":"Road to Front-End Developer","url":"/2019/10/15/road-to-front-end/","content":"當我還是個稚嫩的高中生時，我非常討厭電腦課教的程式語言（C++／VB），認為這輩子都跟程式絕緣。殊不知在日新月異的前端領域中，我找到了比設計、文案更巨大的成就感。下定決心轉職的幾個月後，我已經找到一份前端工程師的工作了。\n\n\n\n一切都始於一個小小的契機\n在成為前端工程師的路上，用微小而堅定的步伐，努力邁進。\n\n說到為什麼會想要轉職成前端工程師，原因其實還滿單純的：因為寫程式很有成就感。\n2018 &#x2F; 6 月前後，我當時的工作是文案企劃，做著做著就也想順便弄一下自己的部落格（當時比較各家之後選用 WordPress.org），買了網域、找了厲害的工程師朋友幫忙處理後台，勉勉強強也是讓部落格上線了。無奈的是，想要自訂點畫面，卻連 CSS 都看不懂，只能一直加裝 plugin，網站就一直增肥，幾個月後只好放棄。\n大概就是從那個時候開始，覺得 CSS 很有趣。設定點東西，畫面就會改變，這件事帶來相當巨大的成就感。\n從那之後就會時不時地看一下 W3Schools，想要多了解一點程式語言，從此一腳踏進前端的世界，回不了頭了。\n\n莫名其妙開始的自學之路\n你真的知道自己在做什麼嗎？\n\n不過當時我連前端／後端具體是什麼都還不清楚，一下就看 W3School，對初學者的我而言難度太高。於是，我決定先研究一下大方向，了解一下這產業的環境。\n學習路徑\n摸黑如何前進？\n\n我爬了不少文章跟網站，總算稍微分得清前／後端。但嚇人的是，程式語言的語言、框架、函式庫、專業術語就像床上的塵蟎一樣，想到就頭皮發麻。我一直不斷地搜尋、整理、調整，總算列出自己想要的學習路徑，之後才是去驗證這條路徑到底適不適合我（必須且戰且走才知道！）。\n下面列出一些滿值得參考的文件，沒方向的時候就上去看看自己在哪個階段、應該要去學什麼：\n\n前端資源懶人包\n前端九部 - 入門者手冊2019\n胡立 - 前端循序漸進學習路程\n網路上許多大大的轉職心得文\n\n東看看西看看之後，我得到的結論是，前端的一切其實都是從這三個東西延伸出來的：\n\nHTML\nCSS\nJavaScript\n\n你知道，我知道，獨眼龍也知道，這些都是基本中的基本。基本，很枯燥乏味，但不論學什麼，打好地基都是幫助之後快速成長最快的途徑，這是我的信念。正因如此，在學會使用框架、函式庫之前，必須學會使用原生的方式寫出任何想要呈現的效果，才夠格說自己會前端。很多問題其實在網路上都有解答，真的要用的時候剪貼過來就好了，問題是我看不看得懂人家在寫什麼。如果只是要會用，那難度其實不會太高，但是我絕不要做一個只會 Ctrl+C &#x2F; Ctrl+V 的工程師。\n我要能夠自己變出來啊！\n這是我對自己的要求，所以前面好幾個月，我把時間全部投注在打基礎上。\n\n在這個階段，很適合去看一些基礎的教學影片，或跟著免費課程一步一步學習，例如：\n\n澎澎的 JavaScript 前端工程\nTraversy Media\nFree Code Camp\nCodeCademy\n\n\n自學最重要的事\n如果你都不放過自己，還有誰會放過你？\n\n我認為自學最重要的事情，就是要認知到下面兩點：\n\n沒有人會逼你，所以你得逼自己\n何時該放自己一馬\n\n第一點人人都明白，但假如你沒辦法讓自己適當地休息，掌控自己的節奏，那很容易會把自己逼到盡頭，如果你是喜歡挑戰極限的人，這樣做當然挺好的，但如果你像我一樣是個凡人，那逼到極限就意味著離放棄不遠了。\n要時常回想，當時為什麼要開始學程式？回想起那些富有成就感的時刻，想想初衷，好好放鬆一下身心，然後繼續再戰。\n這樣，才能走得長遠。\n支撐我繼續走下去的成就感來源：進入心流\n支撐你繼續堅持下去的，又是什麼呢？\n\n學習前端好一陣子，終於能夠開始寫點小作品了的時候，我有時會體驗到進入心流的感覺。那是一種專心致志、全神貫注、腦子非常清楚、全然投入的感覺，有好幾天 coding 到晚上 11、12 點，睡覺夢到某個問題的解法，清晨 4、5 點就清醒，然後再也睡不著，只想繼續寫。\n最近在開發一個案子，也有滿高的機率開啟心流。那種感覺，真的只有一個爽字能形容！\n但我逐漸認知到，這種時刻通常都是出現在「產出」，而非「吸收」的時候，也因此要避免自己只想寫不想學，這樣只會把自己榨乾而已。該累積養分的時候還是得乖乖學習的唷。\n\n確定要來真的了嗎？轉職的轉捩點\n你是何時開始認真看待自己要轉職到一個完全陌生的領域這件事呢？\n\n大約是在 2019 &#x2F; 4 月左右，當時覺得對於 HTML &#x2F; CSS 已經有基礎的了解， CodeCademy、FreeCodeCamp 上的免費教程也已經做到有點索然無味了，想要來認真加深 JavaScript 能力，一方面也想著：「是不是該來認真考慮轉職的事了？」\n果斷辭職\n有時候，純粹是一股衝動。\n\n搜尋了一陣子 JS 課程後，我報了台大資訊系統的一門實體課，叫做「網頁前端實務 JavaScript」，教的內容完全符合我的需求，既超出我的程度，又不會到完全不懂，但需要很努力才能跟上腳步的那種。\n我原本一直是用業餘的時間來學程式，但漸漸地發現，這樣下去我的學習成果不會好。既然已經決定要轉職了，那就必須投入 100% 努力才行。因此在 2019 &#x2F; 5 月中，我果斷離開原本的工作，專心在學習程式、準備轉職上。\n久到令人心慌的空窗期\n前途一片迷茫。何時才能結束？\n\n前前後後空窗了 4 個半月，是我人生中目前為止空窗最久的一段時間了。\n這段期間，每天大部分的時間都花在學習程式上。當然，「假如失敗」的念頭，三不五時就會冒出來。每當這種時候，轉移注意力、貨回憶初衷，都是很有效的辦法，能將自己拉回正軌。\n當你專注在一件事情上的時候，全宇宙都會來推你一把！就是在這個時期，我參加了幾個前端 Facebook 社團，而剛好看到了 Luka 大大創立的 程式柴 Codeshiba 專頁，當時正準備開啟一連串的職涯領航計畫，衝著免費我就報名了。\n發現有一群人跟自己在同樣的道路上掙扎前進，那種感覺是無可比擬的，就好像原本是獨自一人在跑馬拉松，突然發現其實身邊全是夥伴的感覺。而且有個 mentor 領跑，更能夠幫助自己看清方向，去除掉不必要的、浪費時間的事，更有效率地專注在達成目標上。\nCodeShiba 社團真的給予我很大的助力，跪拜 Luka 大大。\n\n想加入需要通過審核，請自行私訊程式柴粉絲頁\n\n粉絲頁： 程式柴 Codeshiba \n社團： CodeShiba 學員專區\n\n\n\n跌跌撞撞的面試面試才知道自己哪裡不足\n你以為公司為什麼過這麼久都不通知你？\n\n這幾個月都是在 Udemy &#x2F; Youtube 上找課程、影片學習，偶爾有靈感的時候，就會自己寫個小作品（寫的時候很有成就感，寫完回頭看才覺得怎麼那麼醜，哈哈哈）。\n差不多七月中，開始有公司會發面試邀請過來，但面試完幾乎都沒有下文。我心裡很清楚是因為程度不足被刷掉，所以每一次的面試，我都會盡量去記被問到答不出來、或答得卡卡的部分，那些就是我該補強的地方（結果多到數不清…）。\n以下是每次面試都會被問到的部分：\n\ngit 能力\nCSS 切版（Float、Flexbox、Grid）\nCSS 權重觀念\nJS DOM／陣列 操作\nJS 串接 API、Ajax、ES6\n\n除了自己去面試，也可以多多參考他人的履歷，Luka 相當熟知怎樣的履歷看起來會吸引人而且程度很高，被他調整履歷了之後不久，我就找到目前的工作了（當然，還是有一些運氣成份，幸好面試主管實際問到的問題我答得出來）。實在是可喜可賀！\n\nGK 的履歷，看看笑笑就好\n\n\nRoad to Front End Developer Never Ends\n這是一條沒有盡頭的路。\n\n我畢竟還是個全然的跨領域轉職者，雖然已經有一些基礎了，但比起原本就在這一行裡打滾的前輩們，根本完全不夠。接下來我為自己設定的方向如下：\n\n在公司裡能學到的\n業界協作流程（git）\n與 server 互動（串資料）\nJS 框架（Angular）\n\n\n自行練習\nCSS（Materialize、Bulma、BootStrap 等套件）\njQuery（沒錯！我還不會 jQuery，通通都是寫原生）\n補足瀏覽器、http 協定等相關知識\n加深 JavaScript 觀念\n學習 Node.js\n\n\n\n原本的目標是兩年內要能夠自己寫含前後端的部落格，不過我現在期望自己能夠盡快學會跟 App 有關的能力，因為我有一些有趣的遊戲跟應用的點子，卻寫不出來，很痛苦啊。\n對我來說，轉職只是個中繼點，通過這個 check point，不代表已經到終點了，還是必須繼續朝目標前進。終極目標是什麼？其實我也不曉得，就且戰且走吧。\n總而言之，祝各位在轉職的路上，穩定踏實地邁進！\n","tags":["Career"]},{"title":"自我管理心法（一）：為什麼要自我管理？","url":"/2020/01/26/self-manage/","content":"你有沒有問過自己，活這輩子，你的目標是什麼呢？你想活出怎樣的生活？想得到什麼樣的成就？你是否足夠了解自己，並且妥善管理自己的生活，讓生活的一切都在自己的掌控中？\n\n\n1. 為什麼要做自我管理？\n這輩子，你想怎麼活？\n\n我是覺得，人活在世上一輩子，其實沒什麼特別的目的，死掉之後也不會有任何意義，重要的是在自我的意識能感知到的這段期間內，如何活著。\n然而，正在看這篇文章的你，與我對於「怎麼活」的解讀是不可能完全一樣的，這世界上也不會有兩個人對於怎麼活有一模一樣的答案。但是，這並不代表就不需要去思考這件事。相反地，我認為人生前半段，主要是在尋找自己「想要怎麼活？」這問題的解答。\n如果你還不曉得自己想要怎麼活，那我會建議你先找到答案。當然，隨著歷練增長，這個答案可能會變動，這是很正常的。\n對我來說，要能活得盡興，需要達到以下幾個目標：\n\n找到能樂在其中的工作\n擁有健康的身體\n需要金錢的時候不會覺得拮据\n\n達成了這些目標之後，基本上就算活得很盡興了，至於有沒有衍生出其他的目標，我覺得都可以。畢竟，本來就沒人規定這輩子一定要達成什麼大成就，對吧？\n\n2. 需要管理的項目這是我的目標：\n\n找到能樂在其中的工作\n擁有健康的身體\n需要金錢的時候不會覺得拮据\n\n簡化一下，就變成：\n\n工作\n運動\n金錢\n\n那麼，接下來就來看看，這三個項目要如何管理吧。\n2.1 如何管理工作一講到工作，有人充滿熱情，有人卻意興闌珊。我認為其實每個人都有機會找到最適合自己、能讓自己充滿激情的工作。為了尋找這樣的工作，你對每一份工作，都應該要設定目標，例如：這份工作的目標是「學習資料搜集與分析的能力」、或為了「累積 30 萬資金」，達成目標後，其實就可以朝下個階段邁進，很快地就能累積在工作上的成就。\n每一份工作都有值得吸收、學習的地方，若你對於現在的工作感到痛苦，分析看看是什麼原因？如果會造成你偏離目標，就想辦法調整；如果已經沒東西可以學了，就趕緊離開那份工作！\n管理自己的工作是很重要的。如果可以，用架構化的方式來管理，能更有效率。以下提供幾個我目前在使用的方法給你參考。\n\n\n\n方法\n內容\n\n\n\n事先規劃\n這方法又分為每日、每週、每月、每季。在時段開始時（例如一天的開頭，花個一小時做這件事），列出每個時段預計完成的事項，在時段結束時檢視，以有效掌握自己的工作能力。才不會每天工作都像無頭蒼蠅撞來撞去，覺得還有很多事沒做。\n\n\n待辦清單\n這是最基本的方法，用條列式清單列出需要完成的任務。可以搭配事先規劃來使用。\n\n\n工時追蹤\n基本上就是工作日誌。藉由詳細列出自己一天花了多少時間在做哪些事，來掌握自己的 loading。\n\n\n對於管理工作，因為太多可以學，我不打算在這裡深談。之後再開其他篇文章來分享關於這塊的心得吧。\n2.2 如何管理運動擁有健康的身體、充足（或有效）的睡眠，才不會每天都病厭厭、全身無力或沒精神，也更能好好地面對一天的挑戰。\n因為運動就是興趣，所以我沒有太去想如何管理運動，基本上多運動就對了。還是稍微分享一下「如何開始運動」好了。\n首先想想，你為什麼會覺得很懶，不想運動？我認為這是因為一般人對於運動的標準愈來愈高，搞得好像不做一些很 hardcore 的運動就會被笑怎麼那麼弱，會覺得運動是很累人的事，上班就已經耗掉一整天的精力了，下班哪還有體力去運動，只想耍廢。\n但是，真的要很累、很喘才叫有運動到嗎？回頭想想，運動的本質是什麼？是促進血液循環、新陳代謝、消耗卡路里吧。走路能不能做到這些事？一樣可以啊！\n每天下班多繞一條巷子才回到家，算不算有運動到？以我的觀點來看，是有的哦！千萬別一下子把門檻定得太高，這樣只會害自己想打消念頭。所謂千里之行始於足下，一次一點點、一次一點點，當你發現的時候，可能就已經離不開運動的習慣了。\n講一大堆，還是沒說我如何管理運動，阿就真的沒有啊。\n2.3 如何管理金錢這是每個人的課題，錢真的不好賺，但非常容易花掉。如何有效管理金錢？我認為還是腳踏實地最實在。\n\n\n\n方法\n內容\n\n\n\n預算控制\n列出每個月基本開銷，並在月底檢視是否有超支的狀況，並做調整。\n\n\n儲蓄\n每月一拿到薪資，就先撥一部分存進儲蓄戶頭。這真的很重要！絕大部分的金錢都來自儲蓄，千萬別想著一蹴可幾的錢財，那通常都會讓你血本無歸。\n\n\n投資自己\n每個月撥一些花費用在買課程、學習技能、取得新體驗上。讓自己的內在愈來愈豐富。\n\n\n控制慾望\n想吃好吃的嗎？想買新衣服？給自己設定一個目標，達成了就可以獲得獎勵，讓身體習慣這件事。\n\n\n\n這邊推薦一個很棒的 youtube 頻道：艾爾文，談了許多自我管理相關的話題，也有很多閱讀心得分享，相當實用！\n\n\n3. 總結為了活得盡興，我想對自己的生活做妥善地管理，分配金錢的使用、分配體力的使用、為了達到目標而學習技能，等等。在管理自己生活的過程中，也不斷產生成就感，成就感帶來的是自信與自尊，讓我能夠活得更盡興。\n如果你也對自我管理感興趣，歡迎來跟我聊聊！\n","tags":["自我管理"]},{"title":"前後端＆資料庫系統建置心得","url":"/2021/03/19/system-deploying/","content":"機緣巧合下，我接到了個任務，需要把一套系統在一個新建的 Server 上架起來。盤點手上資源，是幾套程式碼，還有前人遺留在各 Server 的設定檔。我是剛轉職一年的前端工程師，對前端領域可說是才剛有一些心得，現在就來了這個任務…好吧！解就解，誰怕誰（反正有 Stack Overflow）！\n\n\n\n系統架構要從無到有將系統建起來，首先需要了解系統的架構。廢話不多說，先上圖。\n\n這個系統是長成這個鬼樣子的，至於為什麼要用這麼多種語言設計，不要問我，去問前人。總之這系統上的各套服務，原本是架在不同 Server 的，而我這次要做的事情就是將它們全部搬到同個 Server 運行。\n經過一陣子的研究後，要達成目標，需要下列技術：\n\nLinux 基本操作\n資料庫安裝（MariaDB &amp; MongoDB）\nNode.js build &amp; deploy\nGolang build &amp; deploy\nAngular build &amp; deploy\nService config（systemd）\nWeb Server config（httpd）\n\n\n補充一下困難程度，在開始做這件事前，我會的只有 5 而已…\n\n\n資料庫建置好！那麼首先要嘗試的，就是資料庫的安裝。\n由於對這兩套資料庫完全不了解，我先在本機（Mac）試著用 homebrew 安裝了幾次。現在回過頭看覺得挺好笑的，因為後來才知道在 Mac 安裝跟在 Linux 安裝，完全是兩回事…\nMariaDB\nMacOS 安裝：https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/\nLinux 安裝：https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/\n\nMongoDB\nMacOS 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\nLinux 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n\n\n目標伺服器是 Linux CentOS 7，也是因此契機才稍微去瞭解了下 Linux 作業系統，才知道原來有非常多版本。有興趣知道更多可參考這篇：黑暗執行緒 - 我的 Linux 作業系統考察\n\n安裝了資料庫後才是真正的開始，會遇到 root 密碼無法登入問題、安全性設定問題等怪事，這部分就不細說了，總之 Stack Overflow 是你我的好朋友。\n\nNode.js 專案部署完成資料庫的安裝後，接著是 Form Service，因為這套要先運行起來，Main Service 才能運行。由於在前端打滾了一年，多少還是懂一點 NPM，因此只要稍微讀一下 Package.json，就大概知道操作指令有哪些了。\n接著，做下面這些事情：\n\n將專案資料夾複製到伺服器的專案路徑下\n建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;.service）\n在專案路徑執行 npm install 以下載依賴套件\n啟動服務：systemctl start &lt;service_name&gt;.service\n檢查服務：systemctl status &lt;service_name&gt;.service\n開放 tcp 連線 port：firewall-cmd --add-port=&lt;port_number&gt;/tcp\n\n\n在服務設定檔中會指定專案路徑，以及在這個路徑底下要 Linux 執行什麼指令，因此熟悉的 npm run start 就會寫在這裡。\n\n\nGolang 專案部署在測試過 Form Service 正常運行後，就可以來接著架 Main Service 了。由於我完全不會 Golang，因此花了一些時間從頭學習，也整理出幾個 Go 常用的套件，找了一些 tutorial 來做。\nGolang 常用套件：\n\nGin：http server\nGorm：MariaDB 操作\nMongo：MongoDB 操作\nCron：排程設定\nCobra：指令處理\nJwt：認證處理\n\n熟悉了基本的結構後，就可以試著來 Build Project 了。在打包 Golang 成應用程式時，必須要注意要運行的環境規格（GOOS、GOARCH）。\n接著，做下面這些事情：\n\n將專案資料夾複製到伺服器的專案路徑下\n建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;.service）\n啟動服務：systemctl start &lt;service_name&gt;.service\n檢查服務：systemctl status &lt;service_name&gt;.service\n開放 tcp 連線 port：firewall-cmd --add-port=&lt;port_number&gt;/tcp\n\n\n因為 Main Service 需要接收 http request，因此 tcp 一定要確認好。\n\n\nAngular 專案部署資料庫跟前面兩套系統 run 起來之後，終於來到熟悉的 Angular 專案部署。因為很常做，這裡就不廢話，按照 Package.json 裡的說明 Build，然後複製到伺服器的專案路徑資料夾即可。\n有一點可以延伸討論，前人有為這個專案留下 Shell Script 部署檔，讓打包部署流程變得方便許多，這次在仔細研讀後，也對整個流程到底是做了哪些事情有進一步的認識。或許之後也可以寫一些 Shell Script 小工具。\n\nLinux 設定在部署上面前後端程式及資料庫的過程中，一直有碰到陌生的未知領域，在查找了好一陣子之後，整理出下面三塊 Linux 設定。\nService通常後端服務都會作為 Service 運行，而在 Linux 想要運行服務，很常會用到的一些基本指令（也是我在這次架站過程中反覆用到的指令），整理如下：\n\nLsof：\n查詢目前使用中的 port 及 process id：lsof -n -i\n查詢特定 port 的服務：lsof -n -i:&lt;port_number&gt;\n清除 PID：kill &lt;PID&gt;\n\n\nSystemctl：\n查看所有服務狀態：systemctl --type=service\n查看特定服務狀態：systemctl status &lt;service name&gt;\n啟動服務：systemctl start &lt;service name&gt;\n停止服務：systemctl stop &lt;service name&gt;\n重啟服務：systemctl restart &lt;service name&gt;\n查看服務的設定檔：systemctl cat &lt;service name&gt;\n\n\n\nFirewall後端服務 run 起來時我也稍微卡了一下，因為從 local 明明就可以打到 API，不知為何換個 ip 就一直失敗。後來查到原來是防火牆沒設定好，真相往往就這麼簡單。\n常用指令：\n\n列出使用中的 port：firewall-cmd --list-ports\n打開 port：firewall-cmd --add-port=&lt;port_number&gt;/tcp\n永久打開 port：firewall-cmd --permanent --add-port=&lt;port_number&gt;/tcp\n重啟：firewall-cmd --reload\n關閉 port：firewall-cmd --remove-port=&lt;port_number&gt;/tcp\n\n\n其實除了預設的 80 Port 外，應盡量少讓其他人可以透過 tcp 直接連進伺服器會比較好，這部分的知識我尚未具備，還需要深入精進。\n\nWeb Server這裡也是卡很久，但其實若對 httpd 有些了解，應該是很簡單的事，因為就是Directory 跟 Proxy Reverse 兩件事而已。\n\n其實應該還缺 SSL 憑證相關的東西，但因為這次沒有接觸到設定網域名稱，之後有碰到再說吧！目前遇到的都還不是非常難的問題，一樣是那句話，凡事問 Stack Overflow 就有解了XD（例如說 Apache config 檔案在哪…Where is the Apache configuration in CentOS）\n\n\n結論從研究各套 code 到嘗試建置的過程，前後加起來共 2 週，對一個 Senior 來說可能嫌太久（或許 Senior 只需要 3 天？），但我給自己一個正面的肯定。經過這次的磨練，補強知識的同時也在訓練自學能力，覺得能解這次任務實在是太好了！\n","tags":["fullStack"]},{"title":"Vue.js 學習筆記（一）","url":"/2019/06/26/vue-note-1/","content":"從頭開始學習 Vue.js，這真的是個很方便的東西。因為是記錄給自己看的，比較不會太詳細或有系統，也不知道會有幾篇XD。如果你想更進一步學習 Vue，建議你上網找課程，或閱讀 Vue 的官方文件。\n\n\n導入 Vue.js 的方法在 &lt;head&gt;&lt;/head&gt; 內新增下列這一行程式碼，即可透過 CDN 引入 Vue.js。\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;\n\n至於如何透過 npm 來安裝，以及官方所謂的腳手架工具，目前還不是很了解。\n\nVue 的基本環境創建需先在 &lt;html&gt; 內創建一個掛載點，簡單的寫法如下：\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;\n這個 &lt;div&gt; 就是 Vue 透過 id 抓到的的掛載點（也可以透過 class 來綁定，但沒辦法用同個 class 建立兩個 Vue，只會出現一個），接下來在&lt;script&gt;&lt;/script&gt; 內新增一個 Vue 如下：\n&lt;script&gt;    var app = new Vue(&#123;      el: &quot;#app&quot;  //透過id抓取此掛載點      //此處撰寫 Vue    &#125;);&lt;/script&gt;\n\n這樣一個基本的 Vue 環境就建置完成了。\n另外補充一個點，在 Vue(); 的內部，是用物件來撰寫資料的，這也是為什麼會需要用大括號包起來。\n\nVue 基本功能一、條件判定渲染v-if v-else-if v-else 使用條件來判定是否要渲染內容。若只依單一情況判定是否渲染，那可以用 v-show 就好。\n可以單獨使用如下：\n&lt;p v-if=&quot;isAwake&quot;&gt;我醒著&lt;/p&gt;  //isAwake=true 則渲染這塊內容\n也可以搭配使用如下：\n&lt;p v-if=&quot;isAwake&quot;&gt;我醒著&lt;/p&gt;  //isAwake=true 則渲染這塊內容&lt;p v-else&gt;我睡死了&lt;/p&gt; //isAwake=false 則渲染這塊內容\n三者同時混用如下：\n&lt;p v-if=&quot;num===1&quot;&gt;This is 1&lt;/p&gt;&lt;p v-else-if=&quot;num===2&quot;&gt;This is 2&lt;/p&gt;&lt;p v-else-if=&quot;num===3&quot;&gt;This is 3&lt;/p&gt;&lt;p v-else&gt;This is not 1/2/3&lt;/p&gt;\n\n二、列表渲染v-for 可以達到節省重複撰寫 &lt;li&gt; 的效果。\n舉例 &lt;html&gt; 中要重複渲染的區塊如下：\n&lt;ul id=&quot;app1&quot;&gt;  &lt;li v-for=&quot;item in items&quot;&gt;  //或 item of items    &#123;&#123; item.content &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;\n\n在 Vue 的 data.items 中列出所有內容，就可以做到重複渲染，如此一來相當方便管理。\n三、事件監聽v-on 可以方便地監聽 DOM 的各種事件，v-on 亦可以用 @ 取代。簡單舉例如下：\n&lt;button v-on:click=&quot;myFunction&quot;&gt;按鈕&lt;/button&gt;&lt;button @click=&quot;myFunction&quot;&gt;按鈕&lt;/button&gt;  //偷懶的縮寫\n\n四、屬性綁定v-bind 將 DOM 元素綁定一個 class。\n&lt;div v-bind:class=&quot;myClass&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;myClass&quot;&gt;&lt;/div&gt;  //偷懶的縮寫\n或綁定 src，讓你能更動態地改變這個 DOM 元素的來源。\n&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;&lt;img :src=&quot;imageSrc&quot; /&gt;  //偷懶的縮寫\n\n屬性綁定還能夠更方便地操作 DOM，之後再來探討。\n五、修飾符Vue 的修飾符分為兩種：\n\n事件修飾符\n按鍵修飾符\n\n接下來就簡短記錄一下。\n（一） 事件修飾符有時為了預防假按鈕 &lt;a&gt; 點擊事件時，觸發到 &lt;href=&quot;#&quot;&gt; 的跳轉或冒泡，我們會使用 preventDefault() stopPropagation() 來處理。在 Vue 中其實也差不多意思。\n\n.stop\n.prevent\n.capture\n.self\n.once\n.passive\n\n隨便舉個例子，可以這樣寫：\n&lt;a href=&quot;#&quot; v-on:click.stop=&quot;myFunction&quot;&gt;假按鈕&lt;/a&gt;\n\n（二） 按鍵修飾符我們常為了監聽按鍵的行為而寫下許多 addEventListener，按鍵修飾符可以說就是簡化這件事的幫手。而且 Vue 還貼心地將按鍵對應的 keycode 轉變成直覺式的命名：\n\n.enter\n.tab\n.delete\n.esc\n.space\n.up\n.down\n.left\n.right\n\n舉個例子，這樣用：\n&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;\n\nVue 真的是很方便呢！\n\nVue 觀念綁定的觀念在 Vue 中很重要的一個觀念就是綁定。透過綁定，讓 DOM 的操作變得容易。\n而透過 v-model 的雙向綁定，讓使用者輸入的內容，能夠同步修改 Vue 中的數據，如此一來能應用的範圍就很廣了。\n舉個例子，我有下列這段 &lt;html&gt;：\n&lt;div id=&quot;app&quot;&gt;    勇者名稱： &#123;&#123; name &#125;&#125;    &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;    &lt;button v-on:click=&quot;enterName&quot;&gt;點我來輸入勇者名稱&lt;/button&gt;&lt;/div&gt;\n在這個範例中，我希望使用者在 &lt;input&gt; 中輸入名稱，並點擊按鈕後，觸發 enterName() 將名稱傳入 message。如果是用純 js，我需要創建一個新的 html 標籤，並抓取 &lt;input&gt; 的 value 傳入，這期間又會需要做一些宣告變數來抓取各個標籤的動作，相當繁瑣。但在 Vue 中我只需要這樣寫：\nvar app = new Vue(&#123;    el: &quot;#app&quot;,    data: &#123;        message: &quot;請輸入勇者姓名&quot;, //直接當作 input placeholder        name: &quot;&quot;  //宣告空的 name    &#125;,    methods: &#123;        enterName: function()&#123;            //直接將 messgae 傳入 name            this.name = this.message;        &#125;    &#125;&#125;);\n就完成了！非常方便。這就是 Vue 偉大的綁定概念。\n\n需進一步了解的部分\nApp.vue：template + script + style\ncomponent\nVue 腳手架\n\n","tags":["vue.js"]},{"title":"Web 學習筆記 - localStorage / sessionStorage / cookie / session 比較","url":"/2019/09/12/web-cookie-session/","content":"這幾個東西有什麼不同？這是面試很常出現的基礎題，也是前端新手（*例如我）很容易霧煞煞的部分。為了加深印象，我決定來整理一篇筆記。\n\n在找資料的過程中，發現一個叫做 session 的東西，與 cookie 放在一起討論。這解釋了我其中一場面試的疑惑，當我在討論localStorage 與 sessionStorage 時，面試官卻說「session 應該是存在伺服器端的才對」，並且提到了 cookie。\n原因在這裡，我們講的是不同東西啊！面試官嘴裡說的是 sessionStorage，心裡想的卻是 session。\n真抱歉，我又不會通靈。\n\nlocalStorage 與 sessionStorage相同特徵\n儲存大小限制皆為 5MB 左右\n都有同源策略（CORS）限制\n僅在客戶端瀏覽器中存在\n\n相異特徵\n\n\n\nlocalStorage\nsessionStorage\n\n\n\n生命週期\n永久儲存在瀏覽器中，除非人為刪除\n瀏覽器或標籤頁關閉時自動刪除\n\n\n作用域\n在同一個瀏覽器内，同源文件間共享，可互相讀取、覆蓋\n因生命週期關係，僅在同個瀏覽器、同個標籤頁內的同源文件間才可共享\n\n\n操作方法//sessionStorage用法相同localStorage.setItem();     // 儲存一個物件localStorage.getItem();     // 獲取物件內容localStorage.key();         // 獲取第i個物件localStorage.removeItem();  // 刪除一個物件localStorage.clear();       // 全部删除\n透過上述的方法，就能夠將使用者的一些資料（例如搜尋字串等）儲存在該使用者的瀏覽器中，當下次再訪問這個網站時，就能夠使用這些資料來提升使用者體驗。\n\ncookie 與 sessioncookie\n大小限制只有 4KB 左右\n通常會帶有使用者的 sessionID 供伺服器辨識\n由伺服器產生後保存在客戶端，可以設定多久失效\n每次都攜帶在 HTTP header 中\n\nsession\n保存在伺服器端\n存有使用者的敏感資料\n\ncookie 與 session 的溝通當使用者訪問網站、通過身份認證後，伺服器端會送出一個 cookie 到客戶端，並建立一個 sessionID 存在 cookie 中。之後使用者只要通過該網站的身份認證，就能夠透過存在 cookie 中的 sessionID 查找到存在伺服器的 session 資料。\n\n參考資料\n\n细说localStorage, sessionStorage, Cookie, Session\n介紹 Session 及 Cookie 兩者的差別說明\n\n","tags":["web","localStorage","sessionStorage","cookie","session"]},{"title":"Web 學習筆記 - HTTP","url":"/2019/12/22/web-http/","content":"HTTP（HyperText Transfer Protocol）可說是學習 Web 知識的基本，不僅如此，他還是基本中的基本。因為接著要接觸到 WebSocket，必須先加深網路基礎知識，才能一步步攻破。\n\n\n\nHTTP 是什麼？首先要了解的是 HTTP 究竟是什麼碗糕？\n\nHTTP（超文本傳輸協定）是一個用戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用 TCP 協定。\n\n也就是說，這是一種溝通標準，用來實現用戶與伺服器間的連接。只要依循這個標準，就能夠實現與伺服器間的互動。\n實際的流程會像這樣：\n\n用戶端發出一個請求\n與伺服器指定埠建立 TCP 連接\n伺服器收到請求，會返回狀態（例如 200 ok）及資源（請求的檔案..etc）\n用戶端收到狀態與資源\n\nHTTP 請求方法HTTP 協定中定義了數種請求的方法，而程式新手（e.g. Me）最常使用到的就是以下四種：\n\n\n\n方法\n用途\n\n\n\nGET\n向伺服器送出「讀取資料」的請求\n\n\nPOST\n向伺服器送出「提交資料」的請求\n\n\nPUT\n向指定的資源上傳「最新資料內容」\n\n\nDELETE\n請求伺服器刪除指定的資源\n\n\n伺服器返回狀態碼伺服器返回的狀態碼依據開頭的數字不同，代表著不同的狀態。以下是一個共通的類別，至於細項可以參考：Http 狀態碼\n\n\n\n狀態碼\n代表狀態\n\n\n\n1xx 訊息\n請求已被伺服器接收，繼續處理\n\n\n2xx 成功\n請求已成功被伺服器接收、理解、並接受\n\n\n3xx 重新導向\n需要後續操作才能完成這一請求\n\n\n4xx 請求錯誤\n請求含有詞法錯誤或者無法被執行\n\n\n5xx 伺服器錯誤\n伺服器在處理某個正確請求時發生錯誤\n\n\n一般前端要操作 Ajax，會用 if 來判斷回傳的狀態是否為 200，是的話再做其他操作。\nif ( xhr.status === 200 ) &#123;    //確定伺服器收到請求並處理了，繼續在本地做一些操作&#125; else &#123;    console.log(&quot;錯誤發生啦！狀態碼為: &quot;, xhr.status)&#125;\n\nHTTP Request HeaderHTTP Request Header 能夠在送出 HTTP 請求時，向伺服器明確闡述請求的類型。有些時候是必要的，例如向伺服器進行使用者的身份認證（Authorization），或設定跨來源資源共用（CORS）等等。 \n設定 Header 的方法：\nxhr.setRequestHeader(&lt;header&gt;, &lt;value&gt;);\n\n跨來源資源共用（Cross-Origin Resource Sharing）對像我這樣的前端入門者而言，這是一個令人頭痛的問題。簡單來說，如果你今天向不同網域提供的 API 送出請求，此時就會產生一個跨來源 HTTP 請求（cross-origin HTTP request）。\n這代表什麼呢？除非提供資源的那一方，在回傳的回應裡有帶到寫著 Access-Control-Allow-Origin 或 * 的 response header，否則這會被瀏覽器判斷為一個跨來源的請求，而被擋下。\n關於 CORS，是個前端工程師必須面對的經典議題。但由於（不是魷魚）小弟我對 CORS 的認識也僅限於上述那麼淺白的程度，還沒辦法做個很好的解釋，因此就請各位自行參考網上大大們寫的文章了。\n\n參考資料：\n\nMDN - HTTP\nWiki - 超文本傳輸協定\nHTTP狀態碼\n跨來源資源共用（CORS）\n原來 CORS 沒有我想像中的簡單\n輕鬆理解 Ajax 與跨來源請求\n\n","tags":["http"]},{"title":"Angular 學習筆記 - RxJS","url":"/2022/05/03/Angular-RxJS/","content":"因為專案使用 Angular 開發，而 Angular 提供 RxJS Library 來做非同步請求的管理，身為一個前端工程師，為了讓程式碼更精簡好讀（也為了看起來更厲害），認真了解 RxJS 絕對是必要的。\n\n\n\n什麼是 ReactiveX？ReactiveX 在官網（[https://reactivex.io](https://reactivex.io）的首頁開宗明義寫道：\n\nAn API for asynchronous programming with observable streams.\n\n由此可知 ReactiveX 的出發點是「對可觀察的串流做非同步處理」，而RxJS 是可用 JavaScript 操作的 Library。\n另外，ReactiveX 對自己的定義則是：\n\nReactiveX is a combination of the best ideas fromthe Observer pattern, the Iterator pattern, and functional programming.\n\n也就是說，這是一個集結了下列三種設計模式精華的好開發方式：\n\nObserver Pattern\nIterator Pattern\nFunctional Programming\n\n了解 RxJS 後，再回來看這串定義，就比較能夠體會了。\n\n如何使用 Angular RxJS Library？在 Angular 中要使用 RxJS 處理資料流，可以使用一個叫做 pipe 的 API 來將處理方式包起來：\nimport &#123; Observable, of &#125; from &#x27;rxjs&#x27;;import &#123; ajax &#125; from &#x27;rxjs/ajax&#x27;;import &#123; map, catchError, tap, take &#125; from &#x27;rxjs/operators&#x27;;const apiData = ajax(&#x27;/api/data&#x27;).pipe(    take(1),    map((res: any) =&gt; &#123;        // 使用 map 對資料流中每一個資料做一些操作        if ( !res.response ) &#123;            throw new Error(&#x27;Value expected!&#x27;);        &#125;        return res.response;    &#125;),    catchError(err =&gt; &#123;        // 當發現錯誤時，用 of 建立一個新的 Observable 並回傳        console.log(err);        return of([]);    &#125;),    tap((data: any) =&gt; &#123;        // 透過 tap 對資料做一些操作        console.log(data);    &#125;));// 訂閱 Observable 物件來執行觀察apiData.subscribe();\n\nAPI &amp; Operators整理我自己常用的 API 與 operators：\n\npipe：將多個 operators 包裝起來\ntap：將資料取出來做處理，沒有其他衍伸效果\ntakeUntil：訂閱此 Observable，直到觸及設定的條件\nof：建立一個新的 Observable\ncatchError：捕捉錯誤\ndebounceTime：為了不過度頻繁地發出非同步請求，設定一個延遲時間\ntake：只取 N 筆資料\nmap：遍歷串流中的每一筆資料\nfilter：根據條件篩選出要的資料\nswitchMap：在串流中發出另一筆非同步請求，並回傳一個 Observable\n\n\n總結目前我自己在 Angular 專案中所使用的 RxJS，全部都是用來處理 AJAX 請求的，在程式碼撰寫風格上逐漸建立起一定的習慣，也增加了易讀性與可擴充性。\n以上就是目前對 RxJS 粗淺的了解。\n\n參考資料：\n\nTechBridge 技術共筆部落格 - 希望是最淺顯易懂的 RxJS 教學\nWill 保哥 - RxJS6 新手入門\niT邦幫忙 - 30 天精通 RxJS\nAngular RxJS 函式庫\n\n","tags":["Angular","JavaScript","RxJS"]},{"title":"TypeScript 學習筆記 - 初探","url":"/2023/02/09/typescript-basic/","content":"tags: TypeScript因為專案使用 Angular 的關係，我在開發上逐漸習慣都使用 TypeScript，甚至連近期在練習使用 Node.js 寫後端專案，也會盡可能使用 TypeScript。用習慣了之後，再回去看原生的 JavaScript，總是會感到渾身不對勁。\n\n\n線上測試 TypeScript：https://www.typescriptlang.org/play\n\n什麼是 TypeScript？\n一言以蔽之，就是「基於 JavaScript，但能夠定義型別」的程式語言。\n\n當一段程式碼在 JavaScript 長這樣：\nlet whatIsThis;// 經過一串程式碼，塞入了不曉得什麼鬼東西...console.log(whatIsThis);// 可能是任何東西...\n\n在 TyepScript 中就會長這樣：\nlet whatIsThis: string[];// 經過一串程式碼，塞入了不曉得什麼鬼東西...console.log(whatIsThis);// 你知道他一定是個字串陣列\n\nTypeScript 的好處就是能夠「清楚地定義型別」，大幅提升程式碼在閱讀與維護上的容易程度。\n剛開始使用 TypeScript 的時候，可能會覺得很麻煩，需要多寫一堆程式碼來定義明擺著的事實，但當專案變大、程式碼變長了之後，你會逐漸發覺很多錯誤都能提早避免，而不是等到要 run code 的時候才報錯。\n\nEnum &amp; Interface &amp; Class不僅在維護上，使用 TypeScript 也能讓開發更有效率。舉例來說：\n// 定義一個 Book 介面interface Book &#123;    author: string;    pages: number;&#125;// 定義一個 Library 類別class Library &#123;    private books: Book[] = [];    constructor(books: Book[]) &#123;        this.books = books;    &#125;    // 取得所有的 Book    public getBooks(): Book[] &#123;        return this.books;    &#125;    // 增加新的 Book    public addBook(newBook: Book): Book[] &#123;        this.books.push(newBook);        return this.books;    &#125;&#125;// 定義 books 的型別為 Book[]，在建立內容時 TypeScript 就會檢查是否符合 Book 屬性const books: Book[] = [    &#123;author: &#x27;John&#x27;, pages: 20&#125;,    &#123;author: &#x27;Jane&#x27;, pages: 50&#125;,    &#123;author: &#x27;Peter&#x27;, pages: 100&#125;,    &#123;name: &#x27;Hello&#x27;, pages: 10&#125; // 會因為 Book 介面沒有 name 屬性而報錯，在開發期間就知道這裡會有錯誤]let library = new Library(books);library.getBooks();\n\n或者可以更方便地使用繼承／擴充，讓程式碼更結構化：\n// 使用 enum 直接依順序列舉enum LegsEnum &#123;    noLeg,   // 0    twoLegs, // 1    fourLegs // 2&#125;interface Animal &#123;    legsType: number;    canFly: boolean;    sound(): string; // Animal 天生就可以叫&#125;class Snake implements Animal &#123;    legsType = LegsEnum.noLeg; // 可以直接指派 enum 的值，legsType === 0    canFly = false;    sound(): string &#123;        return &#x27;sss&#x27;;    &#125;&#125;class Dog implements Animal &#123;    legsType = LegsEnum.twoLegs;    canFly = false;    sound(): string &#123;        return &#x27;bark bark&#x27;;    &#125;&#125;class Bird implements Animal &#123;    legsType = LegsEnum.twoLegs;    canFly = true;    sound(): string &#123;        return &#x27;jo jo&#x27;;    &#125;&#125;\n\n如此一來，看著程式碼就可以很迅速地理解各種類別帶有的屬性及方法，光是這點就足以預防很多笨笨的錯誤了。\n在開發時，TypeScript 也會幫你列出正在使用的類別所帶有的屬性及方法，例如：\nlet bird1 = new Bird();bird1. // 當程式碼寫到這裡時，會列出以下東西// bird1.legsType// bird1.canFly// bird1.sound\n\n實在是相當便利。\n另外一個好處是，當程式碼需要改動時，TypeScript 會自動檢查出還有哪些地方是需要修正的，不會在程式碼上線時才 crash。\nTypeScript 真的是個好東西，尤其對於想把程式碼定義清楚的人而言，尤其推薦！\n\n參考資料：\n\nWhat are the differences between TypeScript and JavaScript?\nAn Introduction to TypeScript Interfaces\n\n","tags":["TypeScript"]}]