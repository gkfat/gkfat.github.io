{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/keep/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/keep/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/images/bg.svg","path":"images/bg.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/upyun.png","path":"images/upyun.png","modified":0,"renderable":1},{"_id":"themes/keep/source/js/back2top.js","path":"js/back2top.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/code-copy.js","path":"js/code-copy.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/dark-light-toggle.js","path":"js/dark-light-toggle.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/header-shrink.js","path":"js/header-shrink.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/left-side-toggle.js","path":"js/left-side-toggle.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-brands-400.eot","path":"webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-brands-400.svg","path":"webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-brands-400.ttf","path":"webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-brands-400.woff","path":"webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-brands-400.woff2","path":"webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-regular-400.eot","path":"webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-regular-400.svg","path":"webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-regular-400.ttf","path":"webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-regular-400.woff","path":"webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-solid-900.eot","path":"webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-solid-900.svg","path":"webfonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-solid-900.ttf","path":"webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-solid-900.woff","path":"webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-solid-900.woff2","path":"webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/webfonts/fa-regular-400.woff2","path":"webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/animated.styl","path":"css/common/animated.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/basic.styl","path":"css/common/basic.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/keep-theme.styl","path":"css/common/keep-theme.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/variables.styl","path":"css/common/variables.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/article-content.styl","path":"css/layout/article-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/page.styl","path":"css/layout/page.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/codeblock/code-theme.styl","path":"css/common/codeblock/code-theme.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/codeblock/copy-code.styl","path":"css/common/codeblock/copy-code.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/codeblock/highlight.styl","path":"css/common/codeblock/highlight.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/images/gkfat.png","path":"images/gkfat.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/logo.ico","path":"images/logo.ico","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/about/index.md","hash":"b79dedb510544d65497493a2737b0bb2e38dfd9d","modified":1647088073972},{"_id":"source/_posts/_posts/Angular-basic.md","hash":"985f84d19d5c90c3685439477ca8b72a104f757c","modified":1647088073900},{"_id":"source/_posts/_posts/JS-ES5-ES6.md","hash":"de17fc06b7bcf81cc76d00c65e613b8636ef5e83","modified":1647088073906},{"_id":"source/_posts/_posts/JS-Ajax.md","hash":"61316bd945814dee55151f9ea6f5ecfe708ec526","modified":1647088073904},{"_id":"source/_posts/_posts/JS-XMLHttpRequest.md","hash":"aa247bf287956612529974cf039b1ff3a8105d02","modified":1647088073907},{"_id":"source/_posts/_posts/Angular-lifecycle.md","hash":"014bb68f10e364bc515bebfccdd44d6b77c03b88","modified":1647088073902},{"_id":"source/_posts/_posts/JS-array-methods.md","hash":"386b7032e0936a1e5c4bf9c6ff03e4dd8797095a","modified":1647088073909},{"_id":"source/_posts/_posts/JS-closure.md","hash":"5e0c2ce0a6017f9ac3be0fc0cb36c5c7e4182ed5","modified":1647088073912},{"_id":"source/_posts/_posts/JS-hoisting.md","hash":"ffee604495b704c7ab56292bc7cc3b27197a037b","modified":1647088073914},{"_id":"source/_posts/_posts/JS-class-prototype.md","hash":"5f36226b244b5a36a820cb3e60a041f18396f110","modified":1647088073911},{"_id":"source/_posts/_posts/Node-intro.md","hash":"256a80d95bb0440b7ab46f00955039d770539f14","modified":1647088073915},{"_id":"source/_posts/_posts/git-flow.md","hash":"75906f01806fa7a61984a3867e08e2b6234d58d2","modified":1647088073916},{"_id":"source/_posts/_posts/git.md","hash":"0cdbf24389b0cc7c038c95777e0e86ec0fb22690","modified":1647088073917},{"_id":"source/_posts/_posts/golang-basic.md","hash":"f042579514a57364faec3edea99501d424c6059a","modified":1647088073919},{"_id":"source/_posts/_posts/html-html5.md","hash":"20625e8200eb74376e0b43af575a22331f0413b4","modified":1647088073920},{"_id":"source/_posts/_posts/linux-journalctl.md","hash":"8560a93833cc3ab5a2e21dbf16dd797a101a76bb","modified":1647088073922},{"_id":"source/_posts/_posts/linux-systemctl.md","hash":"c61af4a38add253d4e2d1d96e7e4b3d9aa133036","modified":1647088073923},{"_id":"source/_posts/_posts/nginx.md","hash":"31f71bbfb1090e68d1798a69ade0a3f564779199","modified":1647088073925},{"_id":"source/_posts/_posts/myblog-with-hexo.md","hash":"71a9e41f488c11d22f2a11bf7da7d96b95445326","modified":1647088073924},{"_id":"source/_posts/_posts/python-file-upload-service.md","hash":"b1fecf31365091b0484acf0c0ad16fee7ca41ace","modified":1647088073929},{"_id":"source/_posts/_posts/oop-basic.md","hash":"c232233979c946639970264de72046b524537cc1","modified":1647088073927},{"_id":"source/_posts/_posts/self-manage.md","hash":"797b6056229b1cd2ca2202417ac9192ed1bc8c2a","modified":1647088073931},{"_id":"source/_posts/_posts/vue-note-1.md","hash":"744c8c287f211500c014ad07c366be38b475380a","modified":1647088073934},{"_id":"source/_posts/_posts/web-cookie-session.md","hash":"0fb3160b30efed111991bf7855c76c743a37207e","modified":1647088073935},{"_id":"source/_posts/_posts/system-deploying.md","hash":"7892bebdc8ffa9f19993c9f11b50c4360b95a150","modified":1647088073933},{"_id":"source/_posts/_posts/web-http.md","hash":"e64945556db7f90a89c75cfd69ef1ee6ddbd9fa8","modified":1647088073936},{"_id":"source/_posts/_posts/road-to-front-end.md","hash":"72f51789738b679fe7be1424a5051fd0a60f7aef","modified":1647088073930},{"_id":"public/2020/12/19/about/index/index.html","hash":"3fe86b8c5dcea359ed65d82b0df69484d091085d","modified":1647088752548},{"_id":"public/archives/index.html","hash":"ed5debc06924e359313735dea9bfce2afc33a8ba","modified":1675917547564},{"_id":"public/archives/2020/index.html","hash":"8d6ae3ff4e98defbb4f3c78ee11b99530307d29b","modified":1675917547564},{"_id":"public/archives/2020/12/index.html","hash":"648f4338375f1d64c9f7ee20d166ce55111d2bd6","modified":1647089922692},{"_id":"public/index.html","hash":"db8827043f4ab6cf59c39f5a745fdb6d69f5c5a4","modified":1675917636669},{"_id":"themes/keep/.editorconfig","hash":"a1c91f0a086bf92fddb02ccf23578ec2b51c099c","modified":1647088721994},{"_id":"themes/keep/.gitignore","hash":"b49daa26b8121cc0c7074d61b377c8e7e0880d03","modified":1647088721995},{"_id":"themes/keep/.npmignore","hash":"79596a6faba67852ff4d0426602141426f48639f","modified":1647088721996},{"_id":"themes/keep/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1647088721997},{"_id":"themes/keep/README_zh-CN.md","hash":"77e024325df8ab87114408cc31c8624edb0f5022","modified":1647088721998},{"_id":"themes/keep/README_zh-TW.md","hash":"106577079fbd01a52ddb7d65fe25bf4c7f9942cd","modified":1647088721998},{"_id":"themes/keep/_config.yml","hash":"c086670360519071252f2b433f26df224e0e7c43","modified":1647091808555},{"_id":"themes/keep/package-lock.json","hash":"6dc040d50e6fa966c5e53cbeadf59174d5104846","modified":1647088737974},{"_id":"themes/keep/package.json","hash":"cc05ba956ac3c672e111fed4d7d2e284d0fb9eeb","modified":1647088722017},{"_id":"themes/keep/README.md","hash":"d98baf3223795c0c2faea57c471fc2af9336cef1","modified":1647088721997},{"_id":"themes/keep/.github/FUNDING.yml","hash":"5fae5cd239ca99c452110a009613055ec77f3902","modified":1647088721995},{"_id":"themes/keep/languages/zh-CN.yml","hash":"a4bc8e834989b17d77b70080a63a0d840847ba27","modified":1647088722000},{"_id":"themes/keep/languages/zh-TW.yml","hash":"c6be2adec90f8c5d0a93a9f8d7bfb5fac0af4786","modified":1647088722000},{"_id":"themes/keep/layout/archive-content.ejs","hash":"cfa8f29b8863534f407136ea3deb18a4b2ff722c","modified":1647088722012},{"_id":"themes/keep/layout/article-content.ejs","hash":"1a5f94c8a27ef232ccf62e886a9dde56da3065bc","modified":1647088722013},{"_id":"themes/keep/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1647088722012},{"_id":"themes/keep/layout/category-content.ejs","hash":"aef0c90a395f909be7d2c358eb41d5558a10406f","modified":1647088722013},{"_id":"themes/keep/layout/category-list.ejs","hash":"a9390b25238332417fd554d32563a4d9999db90f","modified":1647088722013},{"_id":"themes/keep/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1647088722014},{"_id":"themes/keep/layout/home-content.ejs","hash":"79e16c3baa6569afbc07ac6a5d2e3f37b273016a","modified":1647088722014},{"_id":"themes/keep/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1647088722015},{"_id":"themes/keep/layout/layout.ejs","hash":"da9dbeba541ad19fed35c41fe187f4016e41f0db","modified":1647088722015},{"_id":"themes/keep/layout/page.ejs","hash":"4bf34f19bcf18efb5f6e76fcbe7cd36b25ceee6a","modified":1647088722015},{"_id":"themes/keep/layout/tag-content.ejs","hash":"ce4c8192a4ccd6a626af412a7ba258d1edbc0b95","modified":1647088722016},{"_id":"themes/keep/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1647088722016},{"_id":"themes/keep/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1647088722016},{"_id":"themes/keep/languages/en.yml","hash":"e4f42cfda0ed6ea1715d28fd4b1bba6f89b8cdb0","modified":1647088721999},{"_id":"themes/keep/scripts/use-source-data.js","hash":"21f6a49e47b7e4d792d67503079ea5b509f18311","modified":1647088722021},{"_id":"themes/keep/layout/_partial/archive-list.ejs","hash":"7c33e49286d54824cd8f3483e30de5579951edc6","modified":1647088722001},{"_id":"themes/keep/layout/_partial/article-copyright-info.ejs","hash":"77e13720374efb902ee3d4d04d13b62de033a3ae","modified":1647088722001},{"_id":"themes/keep/layout/_partial/article-meta-info.ejs","hash":"647736023e7611917d893c33937d7260d3d5b38b","modified":1647088722001},{"_id":"themes/keep/layout/_partial/first-screen.ejs","hash":"106683de71f01b368c6f0c5417952b54fcdc9611","modified":1647088722004},{"_id":"themes/keep/layout/_partial/head.ejs","hash":"4c68f6750fc179368ca5556d80fb1781ba984ff8","modified":1647088722005},{"_id":"themes/keep/layout/_partial/friends-link.ejs","hash":"fe35aa6dabeb31bc677270062eed569f37472c2c","modified":1647088722005},{"_id":"themes/keep/layout/_partial/footer.ejs","hash":"9933e83e6e1022f4c27722f94a8b1540414b2570","modified":1647088722004},{"_id":"themes/keep/layout/_partial/header.ejs","hash":"627dfa9519ff614d6a79dac942a7b61fa5bfac8c","modified":1647088722006},{"_id":"themes/keep/layout/_partial/home-article-meta-info.ejs","hash":"0aceb1c7c29b65bd5fc2d79a285a564da8c09b63","modified":1647088722006},{"_id":"themes/keep/layout/_partial/image-viewer.ejs","hash":"beb3dec5e08856a29d585fe0eb94a8a6ddade4dd","modified":1647088722007},{"_id":"themes/keep/layout/_partial/local-search.ejs","hash":"6fbcc0a14467da8362a2eaa490d84acb1336d21b","modified":1647088722007},{"_id":"themes/keep/layout/_partial/paginator.ejs","hash":"cfd4d9a30bd20ee0750b79226cb94562439013bf","modified":1647088722009},{"_id":"themes/keep/layout/_partial/progress-bar.ejs","hash":"44af04816b86546e0260e73c2df61353e7404208","modified":1647088722010},{"_id":"themes/keep/layout/_partial/scripts.ejs","hash":"ad75de7966c4d9d923c9ac8cfbfe26b38fbe7aed","modified":1647088722010},{"_id":"themes/keep/layout/_partial/side-tools.ejs","hash":"e55d2034d7e2b8b0c1bd5ac7fdc56ffb8bbd4e60","modified":1647088722011},{"_id":"themes/keep/layout/_partial/tagcloud.ejs","hash":"5968618b53a029922f2255b0c76bf8a9f11712ff","modified":1647088722011},{"_id":"themes/keep/layout/_partial/toc.ejs","hash":"aefc9db612c0fceb4a02fdbed9fa47a6c4e144b5","modified":1647088722011},{"_id":"themes/keep/layout/_partial/post-tools.ejs","hash":"e8a303fa393a1716c5ff1f731923781eb12322ab","modified":1647088722010},{"_id":"themes/keep/layout/_partial/page-template.ejs","hash":"8fd596f871326b03e707d7defcc96f639cdd628e","modified":1647088722008},{"_id":"themes/keep/source/css/font-awesome.min.css","hash":"c508528feb9fd540454f838653cd4863b290df2e","modified":1647088722028},{"_id":"themes/keep/source/css/style.styl","hash":"e0c2fd781ee3de12716d6a54dd0f9f5ffe443334","modified":1647088722041},{"_id":"themes/keep/source/images/avatar.svg","hash":"aba8367cd7550e75279f707671d7146813c2a776","modified":1647088722041},{"_id":"themes/keep/source/images/bg.svg","hash":"f3106cd334dc2ceef885c19012bf59a48498af42","modified":1647088722042},{"_id":"themes/keep/source/images/loading.svg","hash":"eedfa204e08a60ca5c80c620cfe9a3eaa6201585","modified":1647088722042},{"_id":"themes/keep/source/images/logo.svg","hash":"b618728f9964a5698b1dc2548db35b3d06dd115f","modified":1647088722043},{"_id":"themes/keep/source/images/upyun.png","hash":"f014175dd78c3ed5249e69c91603e20a3efcd330","modified":1647088722043},{"_id":"themes/keep/source/js/back2top.js","hash":"fc8e85f6704e39ae3a613bbec5dd51d449be8010","modified":1647088722044},{"_id":"themes/keep/source/js/code-copy.js","hash":"3fdabac26f6406a4592336f1f444ec966201b5d9","modified":1647088722044},{"_id":"themes/keep/source/js/dark-light-toggle.js","hash":"223e6f1d4e6e70956e4661b58c430e1c68def125","modified":1647088722045},{"_id":"themes/keep/source/js/header-shrink.js","hash":"167b9b6a9ed63c6cf4081cb3c201dd16bbbfb9ad","modified":1647088722045},{"_id":"themes/keep/source/js/lazyload.js","hash":"95aad532f17d7a8119979fc61ade9e626308a2af","modified":1647088722046},{"_id":"themes/keep/source/js/left-side-toggle.js","hash":"618f7cfc45db4d82b2f1d00d8e9ee936bcf9043b","modified":1647088722046},{"_id":"themes/keep/source/js/local-search.js","hash":"9509ec6d2d7d4466fe37ad624cf606f6639fb3fe","modified":1647088722048},{"_id":"themes/keep/source/js/main.js","hash":"ca8ed228cc0bc234be74428d029cfd047eec0ed6","modified":1647088722048},{"_id":"themes/keep/source/js/toc.js","hash":"ae69bf65d2b30d299b6ca9e2361d3b6e0db3a077","modified":1647088722049},{"_id":"themes/keep/source/js/utils.js","hash":"a2413711ebf7ffc96eafec2ef45a5d243d3ccdb6","modified":1647088722049},{"_id":"themes/keep/source/webfonts/fa-regular-400.eot","hash":"2baa9a8aa68f1d2d4712b3c7205f9105aaf21879","modified":1647088722076},{"_id":"themes/keep/source/webfonts/fa-regular-400.ttf","hash":"d64e58981a419de52bac110c979887d34e366135","modified":1647088722079},{"_id":"themes/keep/source/webfonts/fa-regular-400.woff","hash":"26afc29d39ab9fac6d0b607be7e76db093ff7c3a","modified":1647088722080},{"_id":"themes/keep/scripts/filters/lazyload-handle.js","hash":"7a8fd4996b9720c8d4cdb3042bfe5a1008f7c5fd","modified":1647088722017},{"_id":"themes/keep/scripts/filters/link-handle.js","hash":"b39cfa42d156b7ad4d4e8246b6f934cd51d8db55","modified":1647088722018},{"_id":"themes/keep/scripts/helpers/export-config.js","hash":"e7c5417a1cd61f0b7c3f97030d4a77419c41b8a5","modified":1647088722019},{"_id":"themes/keep/scripts/helpers/helper.js","hash":"41517e3f4c1cd567e2ae14acb344818a9552fac4","modified":1647088722020},{"_id":"themes/keep/source/webfonts/fa-regular-400.woff2","hash":"fb9648469530a05fa9aac80e47d4d6960472a242","modified":1647088722080},{"_id":"themes/keep/layout/_partial/pjax/pjax.ejs","hash":"949d3fdd4bd215cd7d0c95152c4be630ce227e16","modified":1647088722009},{"_id":"themes/keep/layout/_partial/comment/comment.ejs","hash":"4a7294bbe9aa4be22878e8a638668ed7ade25e2c","modified":1647088722002},{"_id":"themes/keep/layout/_partial/comment/gitalk.ejs","hash":"28a0c8b1da66a9b6863e5444aa0b50c8f6b862f0","modified":1647088722003},{"_id":"themes/keep/layout/_partial/comment/twikoo.ejs","hash":"92d858874543c4ba149acd04374d84e784ba0aaf","modified":1647088722003},{"_id":"themes/keep/layout/_partial/comment/valine.ejs","hash":"467cafd412837af791b4c353646cf44ac4458a3f","modified":1647088722004},{"_id":"themes/keep/source/css/common/animated.styl","hash":"ceb35da27937a5824dea00c0a75de57e10e1dc90","modified":1647088722022},{"_id":"themes/keep/source/css/common/basic.styl","hash":"6d6132527247635f7406d6917cfc8e1cb02d8573","modified":1647088722023},{"_id":"themes/keep/source/css/common/keep-theme.styl","hash":"9b6bf080299102571a6667ca99a62f53c9684246","modified":1647088722026},{"_id":"themes/keep/source/css/common/markdown.styl","hash":"55c6c0f77b608b8e1d9c52bb4fdcee881f55eff8","modified":1647088722027},{"_id":"themes/keep/source/css/common/variables.styl","hash":"8b66a8ae90dbb8ec2e412fcf57ff6c8cee18e949","modified":1647088722027},{"_id":"themes/keep/source/css/layout/archive-content.styl","hash":"515ebe2a251f3b53f0cf130cdc48b8bb1fb85952","modified":1647088722038},{"_id":"themes/keep/source/css/layout/article-content.styl","hash":"5cc7dbdc16afc638deabf8e8c0d8236f395d8305","modified":1647088722038},{"_id":"themes/keep/source/css/layout/category-content.styl","hash":"638c3b50d8203c76106f3010fbfeed9a29bfde5c","modified":1647088722039},{"_id":"themes/keep/source/css/layout/category-list.styl","hash":"bea0a03fe3de16ed08e7b3b541a46d2074561841","modified":1647088722039},{"_id":"themes/keep/source/css/layout/page.styl","hash":"ea83a6a5503b63d91d71221699776c4fe2c7a941","modified":1647088722040},{"_id":"themes/keep/source/css/layout/home-content.styl","hash":"2f2ee2f70020cf5e2ffb5612607bd58772e785a4","modified":1647088722040},{"_id":"themes/keep/source/css/layout/tag-content.styl","hash":"0d1cc0cc0d263f55b9c7245c1dc023abdcfcd69f","modified":1647088722040},{"_id":"themes/keep/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1647088722047},{"_id":"themes/keep/source/js/libs/pjax.min.js","hash":"57ec40cb4898d7ba74a03603d608af378e5431f8","modified":1647088722047},{"_id":"themes/keep/source/css/common/codeblock/code-theme.styl","hash":"fd81f8a76ae4f55bf5da38116bbc4f0e973daad2","modified":1647088722024},{"_id":"themes/keep/source/css/common/codeblock/copy-code.styl","hash":"1edcb0ece1bf4b9838c1937e98eaa845de7f4b3b","modified":1647088722025},{"_id":"themes/keep/source/css/common/codeblock/highlight.styl","hash":"64ea39fa5503f6c5a21a9ed7c9d3d5103cccad5a","modified":1647088722026},{"_id":"themes/keep/source/css/layout/_partial/archive-list.styl","hash":"95c41684691a849d102c5a30efb365300d3d5c6d","modified":1647088722029},{"_id":"themes/keep/source/css/layout/_partial/article-copyright-info.styl","hash":"6eaa067231bd9e9faa5de2260b8974142faae510","modified":1647088722029},{"_id":"themes/keep/source/css/layout/_partial/article-meta-info.styl","hash":"378cb61cdffc7243dc11950efc6c0a5b50eecec9","modified":1647088722030},{"_id":"themes/keep/source/css/layout/_partial/first-screen.styl","hash":"d73c088e639d2d4e076552ff92e611682ce2380b","modified":1647088722032},{"_id":"themes/keep/source/css/layout/_partial/footer.styl","hash":"19a8fc0a01bf1efed637e90530c412d57137dfc4","modified":1647088722032},{"_id":"themes/keep/source/css/layout/_partial/header.styl","hash":"80cd9c8abd3542c0e521841137e987a658471e05","modified":1647088722033},{"_id":"themes/keep/source/css/layout/_partial/image-viewer.styl","hash":"59525fcc1f88c78abf8c1f0b06e24b16a088698c","modified":1647088722033},{"_id":"themes/keep/source/css/layout/_partial/local-search.styl","hash":"98aa2e22f16b98b2ffdbf36e1ea24363f8e5045b","modified":1647088722034},{"_id":"themes/keep/source/css/layout/_partial/page-template.styl","hash":"27d1e19691867a09283facd2983afb9a3404e999","modified":1647088722035},{"_id":"themes/keep/source/css/layout/_partial/paginator.styl","hash":"da5df38b09138af28cb8b3fe9a05aeda9dae5011","modified":1647088722035},{"_id":"themes/keep/source/css/layout/_partial/post-tools.styl","hash":"f78a13e3b03b19cb72b03db0a5659f8c734e742e","modified":1647088722035},{"_id":"themes/keep/source/css/layout/_partial/progress-bar.styl","hash":"a64df5515c60a3a0993c427dc50facee33215f2b","modified":1647088722036},{"_id":"themes/keep/source/css/layout/_partial/side-tools.styl","hash":"a68a1e3f21da63ee2d387035e91f9f60e956e234","modified":1647088722036},{"_id":"themes/keep/source/css/layout/_partial/tagcloud.styl","hash":"61016e73c8e420c74800b3afdbd6c2f890400e51","modified":1647088722037},{"_id":"themes/keep/source/css/layout/_partial/toc.styl","hash":"029ac31a21203a8b86027e67a3ff3a977579325d","modified":1647088722037},{"_id":"themes/keep/source/css/layout/_partial/comment/comment.styl","hash":"f6d9a37520566e38738fc1184ed76817273c3ee5","modified":1647088722030},{"_id":"themes/keep/source/css/layout/_partial/comment/gitalk.styl","hash":"b8fccd13e2753c9fe891fb88a6413087048ab830","modified":1647088722031},{"_id":"themes/keep/source/css/layout/_partial/comment/twikoo.styl","hash":"5844874c50a93239031e58b23856698ca9af2725","modified":1647088722031},{"_id":"themes/keep/source/css/layout/_partial/comment/valine.styl","hash":"6b0c7d69fc3f819610576b41e987ec655411ca44","modified":1647088722032},{"_id":"themes/keep/source/webfonts/fa-brands-400.woff","hash":"a42ac4a94f4e0e9333cdb1b2fb6c13c0ae690ff2","modified":1647088722073},{"_id":"themes/keep/source/webfonts/fa-brands-400.woff2","hash":"f726c4275bb494a045fde059175f072de06c01df","modified":1647088722075},{"_id":"themes/keep/source/webfonts/fa-solid-900.woff","hash":"3b86a0ce15d8d534b65e98560e321a933d310688","modified":1647088722101},{"_id":"themes/keep/source/webfonts/fa-solid-900.woff2","hash":"9b592048b9062b00f0b2dd782d70a95b7dc69b83","modified":1647088722102},{"_id":"themes/keep/source/webfonts/fa-brands-400.eot","hash":"c719f4375679ee58e156434f9ba9727be669cf07","modified":1647088722054},{"_id":"themes/keep/source/webfonts/fa-brands-400.ttf","hash":"9b49c6c5b0cbdef158ae31b2a4e4814555408389","modified":1647088722072},{"_id":"themes/keep/source/webfonts/fa-regular-400.svg","hash":"c41a688158d577e3a2738137992d49b05b17ab8f","modified":1647088722077},{"_id":"themes/keep/source/webfonts/fa-solid-900.eot","hash":"c39b89f7fa7b66931ab02a54002db5ffcbff206c","modified":1647088722084},{"_id":"themes/keep/source/webfonts/fa-solid-900.ttf","hash":"d537bf4cc7273ddb3fd754d53f2b241aeafaefe7","modified":1647088722099},{"_id":"themes/keep/source/webfonts/fa-brands-400.svg","hash":"69a0ff79a9d93a451e9fa90bd79ae7008d2a9da5","modified":1647088722065},{"_id":"themes/keep/source/webfonts/fa-solid-900.svg","hash":"36de6a298660ed3feaab37900f7b28c3e981d80e","modified":1647088722096},{"_id":"public/images/avatar.svg","hash":"aba8367cd7550e75279f707671d7146813c2a776","modified":1647088752548},{"_id":"public/images/bg.svg","hash":"f3106cd334dc2ceef885c19012bf59a48498af42","modified":1647088752548},{"_id":"public/images/logo.svg","hash":"b618728f9964a5698b1dc2548db35b3d06dd115f","modified":1647088752548},{"_id":"public/images/upyun.png","hash":"f014175dd78c3ed5249e69c91603e20a3efcd330","modified":1647088752548},{"_id":"public/images/loading.svg","hash":"eedfa204e08a60ca5c80c620cfe9a3eaa6201585","modified":1647088752548},{"_id":"public/webfonts/fa-regular-400.eot","hash":"2baa9a8aa68f1d2d4712b3c7205f9105aaf21879","modified":1647088752548},{"_id":"public/webfonts/fa-regular-400.ttf","hash":"d64e58981a419de52bac110c979887d34e366135","modified":1647088752548},{"_id":"public/webfonts/fa-regular-400.woff2","hash":"fb9648469530a05fa9aac80e47d4d6960472a242","modified":1647088752548},{"_id":"public/webfonts/fa-regular-400.woff","hash":"26afc29d39ab9fac6d0b607be7e76db093ff7c3a","modified":1647088752548},{"_id":"public/webfonts/fa-brands-400.woff","hash":"a42ac4a94f4e0e9333cdb1b2fb6c13c0ae690ff2","modified":1647088752548},{"_id":"public/js/dark-light-toggle.js","hash":"223e6f1d4e6e70956e4661b58c430e1c68def125","modified":1647088752548},{"_id":"public/js/left-side-toggle.js","hash":"618f7cfc45db4d82b2f1d00d8e9ee936bcf9043b","modified":1647088752548},{"_id":"public/js/code-copy.js","hash":"3fdabac26f6406a4592336f1f444ec966201b5d9","modified":1647088752548},{"_id":"public/js/lazyload.js","hash":"95aad532f17d7a8119979fc61ade9e626308a2af","modified":1647088752548},{"_id":"public/js/header-shrink.js","hash":"167b9b6a9ed63c6cf4081cb3c201dd16bbbfb9ad","modified":1647088752548},{"_id":"public/js/main.js","hash":"ca8ed228cc0bc234be74428d029cfd047eec0ed6","modified":1647088752548},{"_id":"public/js/local-search.js","hash":"9509ec6d2d7d4466fe37ad624cf606f6639fb3fe","modified":1647088752548},{"_id":"public/js/toc.js","hash":"ae69bf65d2b30d299b6ca9e2361d3b6e0db3a077","modified":1647088752548},{"_id":"public/js/utils.js","hash":"a2413711ebf7ffc96eafec2ef45a5d243d3ccdb6","modified":1647088752548},{"_id":"public/css/style.css","hash":"af476d4f3174f491c5d119f98f5dd7ab4817bb84","modified":1647088752548},{"_id":"public/webfonts/fa-brands-400.woff2","hash":"f726c4275bb494a045fde059175f072de06c01df","modified":1647088752548},{"_id":"public/webfonts/fa-solid-900.woff","hash":"3b86a0ce15d8d534b65e98560e321a933d310688","modified":1647088752548},{"_id":"public/webfonts/fa-solid-900.woff2","hash":"9b592048b9062b00f0b2dd782d70a95b7dc69b83","modified":1647088752548},{"_id":"public/webfonts/fa-brands-400.eot","hash":"c719f4375679ee58e156434f9ba9727be669cf07","modified":1647088752548},{"_id":"public/webfonts/fa-brands-400.ttf","hash":"9b49c6c5b0cbdef158ae31b2a4e4814555408389","modified":1647088752548},{"_id":"public/css/common/animated.css","hash":"654c7588d80dc8b481a203e3071b3cedd41c7fde","modified":1647088752548},{"_id":"public/css/common/basic.css","hash":"55f95a3b9398ffbf11b8b39f264509e821df9e2e","modified":1647088752548},{"_id":"public/css/common/keep-theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647088752548},{"_id":"public/css/layout/archive-content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647088752548},{"_id":"public/css/common/markdown.css","hash":"8c9fb9f7fb403e76a4446a7e533ebe36dd702483","modified":1647088752548},{"_id":"public/css/layout/article-content.css","hash":"032fd87dc40e0252a5ab59a12adc420371bd13bf","modified":1647088752548},{"_id":"public/css/layout/category-content.css","hash":"9687f9cbe029092b633fb804c28ecdcb54860511","modified":1647088752548},{"_id":"public/css/common/variables.css","hash":"157311f7b38a76721f2b6a2a9bd5229fac60df41","modified":1647088752548},{"_id":"public/css/layout/page.css","hash":"c9d5a1244b1a393ebf63412cf9ffef43ca48d64e","modified":1647088752548},{"_id":"public/css/layout/home-content.css","hash":"be1438b849ebf82cea573986fbbd1deed5334a72","modified":1647088752548},{"_id":"public/css/layout/category-list.css","hash":"672859a61a4e93c0514772112fb557395306e940","modified":1647088752548},{"_id":"public/css/layout/tag-content.css","hash":"90b0cff1ef0228035cdca9ade2adef71c6c8fb5e","modified":1647088752548},{"_id":"public/css/common/codeblock/code-theme.css","hash":"0edc6d498dc0abbaadb152b48e9e7bebb6fd15f4","modified":1647088752548},{"_id":"public/css/common/codeblock/copy-code.css","hash":"fa5f022395fe92b6daea063418a32f8c19be6168","modified":1647088752548},{"_id":"public/js/back2top.js","hash":"fc8e85f6704e39ae3a613bbec5dd51d449be8010","modified":1647088752548},{"_id":"public/css/common/codeblock/highlight.css","hash":"a6584196f859d00cdd962f43c809e44ed89319e4","modified":1647088752548},{"_id":"public/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1647088752548},{"_id":"public/js/libs/pjax.min.js","hash":"57ec40cb4898d7ba74a03603d608af378e5431f8","modified":1647088752548},{"_id":"public/css/font-awesome.min.css","hash":"c508528feb9fd540454f838653cd4863b290df2e","modified":1647088752548},{"_id":"public/webfonts/fa-regular-400.svg","hash":"c41a688158d577e3a2738137992d49b05b17ab8f","modified":1647088752548},{"_id":"public/webfonts/fa-solid-900.eot","hash":"c39b89f7fa7b66931ab02a54002db5ffcbff206c","modified":1647088752548},{"_id":"public/webfonts/fa-solid-900.ttf","hash":"d537bf4cc7273ddb3fd754d53f2b241aeafaefe7","modified":1647088752548},{"_id":"public/webfonts/fa-brands-400.svg","hash":"69a0ff79a9d93a451e9fa90bd79ae7008d2a9da5","modified":1647088752548},{"_id":"public/webfonts/fa-solid-900.svg","hash":"36de6a298660ed3feaab37900f7b28c3e981d80e","modified":1647088752548},{"_id":"source/_posts/Angular-basic.md","hash":"985f84d19d5c90c3685439477ca8b72a104f757c","modified":1647089899021},{"_id":"source/_posts/Angular-lifecycle.md","hash":"014bb68f10e364bc515bebfccdd44d6b77c03b88","modified":1647089899136},{"_id":"source/_posts/JS-Ajax.md","hash":"61316bd945814dee55151f9ea6f5ecfe708ec526","modified":1647089899927},{"_id":"source/_posts/JS-XMLHttpRequest.md","hash":"aa247bf287956612529974cf039b1ff3a8105d02","modified":1647089900397},{"_id":"source/_posts/JS-array-methods.md","hash":"386b7032e0936a1e5c4bf9c6ff03e4dd8797095a","modified":1647089900065},{"_id":"source/_posts/JS-class-prototype.md","hash":"5f36226b244b5a36a820cb3e60a041f18396f110","modified":1647089900126},{"_id":"source/_posts/JS-closure.md","hash":"5e0c2ce0a6017f9ac3be0fc0cb36c5c7e4182ed5","modified":1647089900203},{"_id":"source/_posts/JS-hoisting.md","hash":"ffee604495b704c7ab56292bc7cc3b27197a037b","modified":1647089900326},{"_id":"source/_posts/Node-intro.md","hash":"256a80d95bb0440b7ab46f00955039d770539f14","modified":1647089901191},{"_id":"source/_posts/git-flow.md","hash":"75906f01806fa7a61984a3867e08e2b6234d58d2","modified":1647089899530},{"_id":"source/_posts/git.md","hash":"0cdbf24389b0cc7c038c95777e0e86ec0fb22690","modified":1647089899618},{"_id":"source/_posts/JS-ES5-ES6.md","hash":"de17fc06b7bcf81cc76d00c65e613b8636ef5e83","modified":1647089900272},{"_id":"source/_posts/golang-basic.md","hash":"f042579514a57364faec3edea99501d424c6059a","modified":1647089899708},{"_id":"source/_posts/html-html5.md","hash":"20625e8200eb74376e0b43af575a22331f0413b4","modified":1647089899847},{"_id":"source/_posts/index.md","hash":"b79dedb510544d65497493a2737b0bb2e38dfd9d","modified":1647089918314},{"_id":"source/_posts/linux-journalctl.md","hash":"8560a93833cc3ab5a2e21dbf16dd797a101a76bb","modified":1647089900445},{"_id":"source/_posts/linux-systemctl.md","hash":"c61af4a38add253d4e2d1d96e7e4b3d9aa133036","modified":1647089900566},{"_id":"source/_posts/myblog-with-hexo.md","hash":"71a9e41f488c11d22f2a11bf7da7d96b95445326","modified":1647089900724},{"_id":"source/_posts/nginx.md","hash":"31f71bbfb1090e68d1798a69ade0a3f564779199","modified":1647089900896},{"_id":"source/_posts/oop-basic.md","hash":"c232233979c946639970264de72046b524537cc1","modified":1647089901353},{"_id":"source/_posts/road-to-front-end.md","hash":"72f51789738b679fe7be1424a5051fd0a60f7aef","modified":1647089901491},{"_id":"source/_posts/python-file-upload-service.md","hash":"b1fecf31365091b0484acf0c0ad16fee7ca41ace","modified":1647089901423},{"_id":"source/_posts/vue-note-1.md","hash":"744c8c287f211500c014ad07c366be38b475380a","modified":1647089901698},{"_id":"source/_posts/system-deploying.md","hash":"7892bebdc8ffa9f19993c9f11b50c4360b95a150","modified":1647089901630},{"_id":"source/_posts/web-cookie-session.md","hash":"0fb3160b30efed111991bf7855c76c743a37207e","modified":1647089901767},{"_id":"source/_posts/self-manage.md","hash":"797b6056229b1cd2ca2202417ac9192ed1bc8c2a","modified":1647089901578},{"_id":"source/_posts/web-http.md","hash":"e64945556db7f90a89c75cfd69ef1ee6ddbd9fa8","modified":1647089901823},{"_id":"themes/keep/source/images/logo.ico","hash":"b91a9f80b47950dbe5ff517cfcc8576676cb3085","modified":1647089342861},{"_id":"themes/keep/source/images/gkfat.png","hash":"f002c46c54ac86381644015658c47914976fc019","modified":1647089001096},{"_id":"public/2022/03/12/linux-journalctl/index.html","hash":"95814783ea02f2d76a10578316f2948c39c07ea6","modified":1675912475762},{"_id":"public/2020/12/19/index/index.html","hash":"d60ec0c6735d110062544626583b59ca56b693c5","modified":1647089922692},{"_id":"public/2019/10/23/Angular-lifecycle/index.html","hash":"304176a7e115a914d899ba4684b3a70ceef12e3a","modified":1675912475762},{"_id":"public/2019/09/17/JS-closure/index.html","hash":"c011ebf328224b21b4faef30e04c12a47dc07a88","modified":1675912475762},{"_id":"public/2019/09/15/JS-hoisting/index.html","hash":"e7f3ce4661d28dfcfadcc5f07de0a9b865bb287d","modified":1675912475762},{"_id":"public/2019/09/12/web-cookie-session/index.html","hash":"84e521712423181c25a888e1e87fd3dae18eb2d2","modified":1675912475762},{"_id":"public/2019/09/12/JS-ES5-ES6/index.html","hash":"fdac33a969dd368ebea319634970de8aa3f5d248","modified":1675912475762},{"_id":"public/2019/09/06/html-html5/index.html","hash":"2a5c639543ddf46e2f43e407b5333246faf07307","modified":1675912475762},{"_id":"public/page/3/index.html","hash":"dddb62cc33bf079178bfeaea52bd109aaec32839","modified":1675917547564},{"_id":"public/tags/Angular/index.html","hash":"39a97ee34cb95f666164184491f2a1ff3c474576","modified":1675912475762},{"_id":"public/tags/JavaScript/index.html","hash":"4cf7e8f6e54fc30638bc8e8ffb68880b8bfeceee","modified":1675912475762},{"_id":"public/tags/LifeCycle/index.html","hash":"a90173fb89651334951500b574c8ad01fcd9bb1e","modified":1675912475762},{"_id":"public/tags/git/index.html","hash":"79871a25d79fafe9d017d3798a005941cbb5fadc","modified":1675912475762},{"_id":"public/tags/後端開發/index.html","hash":"1cd5f4223d34daa17220319e5b593649db14dd2c","modified":1675912475762},{"_id":"public/tags/Go/index.html","hash":"a040bd65aa4d2587c0bc2ee176b26286aebf9b1e","modified":1675912475762},{"_id":"public/tags/html/index.html","hash":"d408c754ea52534a31d632e140e8d18ce0c79b73","modified":1675912475762},{"_id":"public/tags/Ajax/index.html","hash":"8fc769e6891839414bc1182ae5120d0c5b53caf7","modified":1675912475762},{"_id":"public/tags/closure/index.html","hash":"a70a353ccc73b6bebab270154b00abd01fcde3cd","modified":1675912475762},{"_id":"public/tags/class/index.html","hash":"ae3520edeb83e2d6cfb2c8b5deacd5bf8203c5f7","modified":1675912475762},{"_id":"public/tags/prototype/index.html","hash":"7c12c6848d2fd492ea1654a9e557160775cfffac","modified":1675912475762},{"_id":"public/tags/XMLHttpRequest/index.html","hash":"bf3f39d743764ceb190215c12ff1d8814df0fc5a","modified":1675912475762},{"_id":"public/tags/hoisting/index.html","hash":"cd647c2639502427a92e6a6d16a602bef5ec0d06","modified":1675912475762},{"_id":"public/tags/Journalctl/index.html","hash":"23e7e69df988100b92a95e74899c6aa3961c5e8c","modified":1675912475762},{"_id":"public/tags/Systemd/index.html","hash":"edd68cff73645615d4c59fed111b9116a8cee6a7","modified":1675912475762},{"_id":"public/tags/Linux/index.html","hash":"7b14998d90b6d2b6d74df3ce2ac9ae722a0921bb","modified":1675912475762},{"_id":"public/tags/Systemctl/index.html","hash":"f2dfefdf14e54a147e2f6c13942b068bc5fc6c41","modified":1675912475762},{"_id":"public/tags/hexo/index.html","hash":"b43503ae694c7d45e764bcc564f78b2c7949cd70","modified":1675912475762},{"_id":"public/tags/nginx/index.html","hash":"cc495dc04e92148708a45e468e008810e3e6672b","modified":1675912475762},{"_id":"public/tags/Node-js/index.html","hash":"3624f5c68a318b5a82657a461e0540e3cce27ece","modified":1675912475762},{"_id":"public/tags/OOP/index.html","hash":"c5800377893f1aa7daeca2583732d97323fb66ad","modified":1675912475762},{"_id":"public/tags/TypeScript/index.html","hash":"20c46e28d12b9b74fe70c185b319bd5899f32a6e","modified":1675917547564},{"_id":"public/tags/SOLID/index.html","hash":"df75b855edfb50f3d555883963801d2eeb8dd144","modified":1675912475762},{"_id":"public/tags/Python/index.html","hash":"167408a248e66c313e96e6da84d3762d32cb23e5","modified":1675912475762},{"_id":"public/tags/API/index.html","hash":"787751908ed6c59b90bbafaf092c99ed285f498d","modified":1675912475762},{"_id":"public/tags/NAS/index.html","hash":"12fda9ad2fd5cdb8e6405f4cdf56454da6db461a","modified":1675912475762},{"_id":"public/tags/Career/index.html","hash":"642a818c484d76ded6a63ea73a06075cefe53645","modified":1675912475762},{"_id":"public/tags/自我管理/index.html","hash":"4f325f84cb944818a8a112b0d27f270a39c6a64f","modified":1675912475762},{"_id":"public/tags/fullStack/index.html","hash":"195eb9a02328db75ab705a857c92476b7cbda9c8","modified":1675912475762},{"_id":"public/tags/vue-js/index.html","hash":"aa7957273aa4689999bae7ca02db23cf9234c3a6","modified":1675912475762},{"_id":"public/tags/web/index.html","hash":"2e6874d9c4cadb5e91efda279f9ee1ee8a420d5f","modified":1675912475762},{"_id":"public/tags/localStorage/index.html","hash":"f8cbd0188bc18ceb891c4186d3556117b7b73157","modified":1675912475762},{"_id":"public/tags/sessionStorage/index.html","hash":"654712c325bfbfb8dadd4a6a302710e8891d7cbd","modified":1675912475762},{"_id":"public/tags/cookie/index.html","hash":"47a7aaa31416d532b80ec0d29ceef6cde2eae5c2","modified":1675912475762},{"_id":"public/tags/session/index.html","hash":"46ca81a95e4a5e69ced441abe4bfcfc79fad04db","modified":1675912475762},{"_id":"public/tags/http/index.html","hash":"ed831ddd4b290209f259560f8221cad38007bdaf","modified":1675912475762},{"_id":"public/2022/03/12/linux-systemctl/index.html","hash":"b8885525b8e1b8210904d9862409b435a03e9732","modified":1675912475762},{"_id":"public/2021/11/23/oop-basic/index.html","hash":"dd16528c7cbac1b00079a03b804548148d91712c","modified":1675912475762},{"_id":"public/2021/09/05/golang-basic/index.html","hash":"b6e52497de03632fda4ea5bf771b4865503f25bf","modified":1675912475762},{"_id":"public/2021/09/05/python-file-upload-service/index.html","hash":"e3b7598fd481a05a56e6094ef176d4834844373d","modified":1675912475762},{"_id":"public/2020/01/26/self-manage/index.html","hash":"d85f679dab3774adec87722bbf30c50e741d7aac","modified":1675912475762},{"_id":"public/2019/12/22/web-http/index.html","hash":"7691ab012c29f42369d246651a00eb50b5baaa91","modified":1675912475762},{"_id":"public/2019/12/22/Node-intro/index.html","hash":"2dc26adda033ac50725a9a3b34fe423cc858c996","modified":1675912475762},{"_id":"public/2019/10/24/git/index.html","hash":"fca425e9385e9c18763328283538fc18f1fda3b9","modified":1675912475762},{"_id":"public/2019/10/24/nginx/index.html","hash":"86de92199f02c0eacc6fb864e38b02c491e8f3c4","modified":1675912475762},{"_id":"public/2019/10/21/Angular-basic/index.html","hash":"b9b1fa4c7aca9deac0078ae12a9abe93d948fea2","modified":1675912475762},{"_id":"public/2019/10/15/road-to-front-end/index.html","hash":"140916ce76fa323e9faf3636bbc2e55ca4ee54f3","modified":1675912475762},{"_id":"public/2019/10/04/JS-Ajax/index.html","hash":"6d081d430a3cb77e1f91ba6382d339c709c62ad1","modified":1675912475762},{"_id":"public/2019/09/18/JS-class-prototype/index.html","hash":"b84b5506d6939a67c90a354d2720499faeaf3c3c","modified":1675912475762},{"_id":"public/2019/09/14/JS-array-methods/index.html","hash":"6601b3545386400b23e7eef8094546096a2dad16","modified":1675912475762},{"_id":"public/2019/09/12/JS-XMLHttpRequest/index.html","hash":"e927d7a82ab15743ba2678ecf5c5277b29757a15","modified":1675912475762},{"_id":"public/2019/06/26/vue-note-1/index.html","hash":"8c5cd7d73e715e27606a87f60754c9d24297b95a","modified":1675912475762},{"_id":"public/2019/06/25/myblog-with-hexo/index.html","hash":"419a32502cb1831d73861c588654ef48fcaccb1f","modified":1675912475762},{"_id":"public/page/2/index.html","hash":"c6e1bdd68e8b6bf3090f3b12ed68cb8327adfda9","modified":1675917547564},{"_id":"public/archives/page/2/index.html","hash":"ed5debc06924e359313735dea9bfce2afc33a8ba","modified":1675917547564},{"_id":"public/archives/page/3/index.html","hash":"ed5debc06924e359313735dea9bfce2afc33a8ba","modified":1675917547564},{"_id":"public/archives/2019/index.html","hash":"5217f175a4730896a8dbeb4ae58306a6103c0e8f","modified":1675917547564},{"_id":"public/archives/2019/page/2/index.html","hash":"5217f175a4730896a8dbeb4ae58306a6103c0e8f","modified":1675917547564},{"_id":"public/archives/2019/06/index.html","hash":"2415fe3c66345d71319b0506fd050d3960eb8086","modified":1675917547564},{"_id":"public/archives/2019/09/index.html","hash":"94991866d75a5adcc7dbf7448366d57bc3992fd5","modified":1675917547564},{"_id":"public/archives/2019/10/index.html","hash":"7dd7ab230db353acb3b2776565ab82635bc14991","modified":1675917547564},{"_id":"public/archives/2019/12/index.html","hash":"1b2a52508deb00b31172504d83c82c2773d7846b","modified":1675917547564},{"_id":"public/archives/2020/01/index.html","hash":"9da8c363f8ffbc4404664d77fd5c4f5fc8254b3a","modified":1675917547564},{"_id":"public/archives/2021/index.html","hash":"b9808ffdd4dbdf6154fdd53c18baa729bdcb4f07","modified":1675917547564},{"_id":"public/archives/2021/03/index.html","hash":"4769252d2bf0dc3963e609c9d245a2e313a3553c","modified":1675917547564},{"_id":"public/archives/2021/08/index.html","hash":"72ae1275c05211b47c269627581ea9a94b8845d1","modified":1675917547564},{"_id":"public/archives/2021/09/index.html","hash":"3f151cae26b5e474a656a2d06c6ac82a40ff3f5c","modified":1675917547564},{"_id":"public/archives/2021/11/index.html","hash":"fa39fc293fbdc4b61a10fef7ee2b7b626d05c89c","modified":1675917547564},{"_id":"public/archives/2022/index.html","hash":"1aaf9a4064569b76c0507a4fa6905826f23e1080","modified":1675917547564},{"_id":"public/archives/2022/03/index.html","hash":"16976e494e83df533ac23d27c2ddfa72fb9284b7","modified":1675917547564},{"_id":"public/2021/08/28/git-flow/index.html","hash":"9819042c9ae3fcfff2bb7081cba0680f40c52344","modified":1675912475762},{"_id":"public/2021/03/19/system-deploying/index.html","hash":"8ce2855dee03020299bcb37b3fb0eba5fc2c29f4","modified":1675912475762},{"_id":"public/images/logo.ico","hash":"b91a9f80b47950dbe5ff517cfcc8576676cb3085","modified":1647089922692},{"_id":"public/images/gkfat.png","hash":"f002c46c54ac86381644015658c47914976fc019","modified":1647089922692},{"_id":"source/about/index.md","hash":"e80e55c9e0ad0c993200f11e4c2e7ffd83ef98a4","modified":1647090324236},{"_id":"public/about/index.html","hash":"fa19f8c61d78b69e9b83b0a89717040c06a0f0f1","modified":1675912475762},{"_id":"public/search.json","hash":"f94ed78263618ccc8cde57d9bd2409df9ed91a03","modified":1675917636669},{"_id":"source/_posts/Angular-RxJS.md","hash":"a5e060574c581d0ce8a660b34f485a00c24aa6f5","modified":1651555535497},{"_id":"public/2022/05/03/Angular-RxJS/index.html","hash":"786b7b350aa886d0dc39750d262c4e257c20be5b","modified":1675917547564},{"_id":"public/archives/2022/05/index.html","hash":"62d88f16d0bbcd620d945fb35ea4bb800a143a1f","modified":1675917547564},{"_id":"public/tags/RxJS/index.html","hash":"1641f51771583168384ae189d3cc71da7f645de8","modified":1675912475762},{"_id":"source/_posts/typescript-basic.md","hash":"37cbb71102a850c304f0781c26c045c46933611f","modified":1675917627398},{"_id":"public/2023/02/09/typescript-basic/index.html","hash":"09863c9ac961fd089d7c31f04064f44ddd3da57c","modified":1675917636669},{"_id":"public/archives/2023/index.html","hash":"b4cd03869364060723293c33c0b4c24726bbb830","modified":1675917547564},{"_id":"public/archives/2023/02/index.html","hash":"6b017bffea41165737b735c2c7c5ac7bee51cbbe","modified":1675917547564}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2020-12-19T10:06:21.000Z","_content":"\n你好，我是 Gk Wang，是一名設計出身、具廣告行銷背景的**前端工程師**。職涯路上，精進前端能力同時學習後端技術，期許自己不斷成長。將跨部門協作能力發展成為系統分析能力，提升專案效率。樂於擁抱有益成長的高強度環境，在不虧待自己的前提下，享受工作同時重視生活品質，創造個人與公司雙贏局面。\n\n* 聯絡信箱：gkgkdesign@gmail.com\n* 技術筆記：https://gkfat.github.io\n* 個人履歷：https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-12-19 18:06:21\n---\n\n你好，我是 Gk Wang，是一名設計出身、具廣告行銷背景的**前端工程師**。職涯路上，精進前端能力同時學習後端技術，期許自己不斷成長。將跨部門協作能力發展成為系統分析能力，提升專案效率。樂於擁抱有益成長的高強度環境，在不虧待自己的前提下，享受工作同時重視生活品質，創造個人與公司雙贏局面。\n\n* 聯絡信箱：gkgkdesign@gmail.com\n* 技術筆記：https://gkfat.github.io\n* 個人履歷：https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\n","updated":"2022-03-12T13:05:24.236Z","path":"about/index.html","_id":"cl0nuvoj10000kiusdzov6qec","comments":1,"layout":"page","content":"<p>你好，我是 Gk Wang，是一名設計出身、具廣告行銷背景的<strong>前端工程師</strong>。職涯路上，精進前端能力同時學習後端技術，期許自己不斷成長。將跨部門協作能力發展成為系統分析能力，提升專案效率。樂於擁抱有益成長的高強度環境，在不虧待自己的前提下，享受工作同時重視生活品質，創造個人與公司雙贏局面。</p>\n<ul>\n<li>聯絡信箱：<a class=\"link\"   href=\"mailto:&#103;&#107;&#x67;&#107;&#x64;&#101;&#115;&#x69;&#103;&#x6e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;\" >&#103;&#107;&#x67;&#107;&#x64;&#101;&#115;&#x69;&#103;&#x6e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>技術筆記：<a href=\"https://gkfat.github.io/\">https://gkfat.github.io</a></li>\n<li>個人履歷：<a class=\"link\"   href=\"https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\" >https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>你好，我是 Gk Wang，是一名設計出身、具廣告行銷背景的<strong>前端工程師</strong>。職涯路上，精進前端能力同時學習後端技術，期許自己不斷成長。將跨部門協作能力發展成為系統分析能力，提升專案效率。樂於擁抱有益成長的高強度環境，在不虧待自己的前提下，享受工作同時重視生活品質，創造個人與公司雙贏局面。</p>\n<ul>\n<li>聯絡信箱：<a class=\"link\"   href=\"mailto:&#103;&#107;&#x67;&#107;&#x64;&#101;&#115;&#x69;&#103;&#x6e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;\" >&#103;&#107;&#x67;&#107;&#x64;&#101;&#115;&#x69;&#103;&#x6e;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>技術筆記：<a href=\"https://gkfat.github.io/\">https://gkfat.github.io</a></li>\n<li>個人履歷：<a class=\"link\"   href=\"https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\" >https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n"}],"Post":[{"title":"Angular 學習筆記 - 從頭認識一個框架","date":"2019-10-21T13:48:55.000Z","_content":"\n因為公司專案使用 `Angular`，為了能夠駕馭，就義無反顧地投入下去從頭學起啦！`Angular` 真的是個學習曲線很高的框架，規範相當嚴謹，但相對來說，前面規範細一點，後續維護就方便些，在這方面確實是比 `Vue` 有更多優勢的。\n\n<!--more-->\n\n---\n## About `Angular`\n\n### `Angular` 特色\n\n結論寫在前面：\n\n* `TypeScript` 定義資料型別\n* `Component` 元件化的撰寫風格 \n* `Services` 集中管理資料與方法\n* `Modules` 各種模組供使用\n* `RxJS Observables` 實現 async 作業\n\n`Angular` 有很多特性，身為一個 JS 框架，最基本具備的就是「模組化」的能力，因此拆分成 Component 是肯定要的。不過 `Angular` 在母／子 Component 之間的導入與導出的關係這方面，定義得相當嚴謹。舉個例來說，你定義一個 class 內含的資料，原生 JS 只要寫個變數名跟賦值就好了，像這樣：\n```javascript\nexport class myComponent {\n    myName : ''; // 先給他個空值\n}\n```\n但在 `Angular` 因為要求使用 `TypeScript` 的關係，你必須清楚定義這個變數**是什麼型別**，像這樣：\n```javascript\nexport class myComponent {\n    myName:string : ''; // 這必須是一個字串！\n}\n```\n也許對撰寫的人而言，這樣比較麻煩，但試想專案一大、變數一多，難免會搞混每個變數應該裝什麼東西，而這樣就有助於你在看 code 的時候就先有個認知（`myName` 會是一個「字串」）這樣。對於其他維護專案的人而言，也比較好懂。難道你希望在維護別人寫的扣的時候，看到的是一堆亂七八糟的東西嗎！\n```javascript\nexport class componentA {\n    A_1 : ''; // 鬼才知道這是要放什麼！我會通靈嗎！\n}\n```\n\n至於其他的特性，因為我也剛接觸不久，還不算太熟悉，就讓我們來一起發掘吧！\n\n\n### 可以邊寫邊看的東西\n\n* 跟著官方提供的風格來撰寫 Agnular 專案是比較好的：[官方撰寫風格指南](https://angular.tw/guide/styleguide)\n* 加速撰寫的速度：[速查表](https://angular.tw/guide/cheatsheet)\n* `Angular` 有些獨有的專屬詞彙：[詞彙表](https://angular.tw/guide/glossary)\n\n---\n## `TypeScript`\n\n> [TypeScript 入門教程](https://ts.xcatliu.com/)\n\n接觸 `Angular` 之前需要先對 `TypeScript` 有一定程度的了解。這類的教學在網路上有相當多資源。\n\n### 定義類型\n\n* boolean\n* number\n* string\n* void（表示此函式不會返回任何值）\n* null & undefined\n* any（表示可以被賦予任何類型的值）\n\n### 聯合類型\n\n顧名思義就是可以一次宣告多個類型：\n```javascript\nlet myNumber: string | number;\nmyNumber = 'seven';\nmyNumber = 7;\n// 不會報錯\n```\n其他的部分，因為我也還在了解，就先不多談XD\n\n---\n## `Angular CLI`\n\n> [官方 `CLI` 指令一覽表](https://angular.tw/cli)\n\n終於進到本體了！當你很開心地想要創建一個 `Angular` 專案，卻發現你需要先搞好 `node` 跟 `npm`，於是決定放棄...沒啦，我們假設大家都會使用這套工具了，那就來安裝一下 CLI：\n```javascript\n$ npm install @angular/cli\n```\n移動到專案資料夾下，並透過指令產生新 `Angular` 專案：\n```javascript\n$ ng new myApp\n// 選擇是否要啟用 routing\n// 選擇 CSS format\n// 開始創建專案啦！\n```\n\n官方建議透過 `ng generate <名稱>` 來新增元件，透過這指令，新元件會自動 binding 進根元件 `app` 中，供整個 `app` 取用。\n\n透過 `CLI` 創建的 `Angular` 專案，有非常多內容，很容易頭昏眼花。[這篇文章](https://blog.gtwang.org/web-development/angular-framework-hello-world/) 有詳細的表可以參考哪個檔案的作用是什麼。\n\n---\n## `@angular/core`\n\n一些基本的資料操作都需要先導入 `@angular/core`，另外還有一些功能會需要導入其他的模組，例如 `@angular/forms`，相關的功能與模組可以參照官方提供的表：[速查表](https://angular.tw/guide/cheatsheet)\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/core\nimport { NgModule } from '@angular/core';\n```\n\n### 基本資料操作\n\n```javascript\n// 定義 myName 資料\nexport class myComponent {\n    myName:string : '小明';\n}\n\n<div>{{ myName }}</div> // 會印出小明\n```\n\n### 實現雙向綁定\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/forms\nimport { FormsModule } from '@angular/forms';\n```\n```javascript\n// 定義空的 myName 資料\nexport class myComponent {\n    myName:string : '';\n}\n\n<input [(value)]=\"myName\" />\n<div>{{ myName }}</div> // 會印出在 input 輸入的值\n```\n\n### 實現條件渲染\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/common\nimport { CommonModule } from '@angular/common';\n```\n\n```javascript\n// 如果條件符合 A，就渲染這個 template\n<ng-template *ngIf=\"A\">\n    <p>A!!</p>\n</ng-template>\n\n// 如果條件不符合 A，就渲染這個 template\n<ng-template *ngIfElse=\"!A\">\n    <p>Not A!!</p>\n</ng-template>\n```\n\n### 實現條件判斷樣式\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/common\nimport { CommonModule } from '@angular/common';\n```\n\n```javascript\n// 如果條件符合 A，就 background-color='blue'，否則 'red'\n[style.background-color]=\"A ? 'blue' : 'red'\"\n\n// 或一次判斷多個樣式\n[ngStyle]=\"{\n    'background-color': A ? 'blue': 'red',\n    'border' : A ? '1px solid red' : 'none'\n}\"\n\n// 綁定 class\n[class.<className>]=\"<達成條件>\"\n\n// 更進一步綁定 class\n[ngClass]=\"myFunction()\"\n\nmyFunction() { // 須在 component 定義 function\n    let myClasses = {\n        classA: <條件A>,\n        classB: <條件B>\n    }\n    return myClasses;\n}\n```\n\n以上都相當基本，所以做個筆記就過去了。\n\n---\n## `Routing`\n\n如果一開始創建專案時沒有選擇要 `Routing` 但後來又想用的話，可以使用 `CLI` 產生 `Routing`。\n\n```javascript\n$ ng generate module app-routing --module=app\n// --module=app：將它註冊到 AppModule 的 imports 陣列中\n```\n\n---\n## `Component`\n\n透過 `CLI` 產生的 `Component`，會自動幫你綁定在 `app` 裡。\n\n```javascript\n$ ng generate component myApp\n// 或更偷懶的寫法：\n$ ng g c myApp\n```\n會在 `app` 資料夾中產生一個 `myApp` 資料夾，並在 `app/myApp` 裡產生四個檔案：\n```javascript\nmyApp.component.html\nmyApp.component.css\nmyApp.component.ts\nmyApp.component.spec.ts\n```\n\n其中 `spec` 檔是跑測試用的，對於規模較小的專案就比較不需要注意這個。其實也是因為我還沒了解，所以就先不談。\n\n---\n## `Service`\n\n一樣，用 `CLI` 來產生一個 `service`：\n```javascript\n$ ng generate service\n```\n\n接著，在 `Component` 中導入 `Service`：\n\n```javascript\n// 在目標 component.ts 檔案裡導入 service\nimport { HttpService } from '~/http.service';\n\n// 在 export 中做以下宣告\nexport class myComponent implements OnInit {\n    // 宣告一個叫 _myHttp 的私有 service\n    constructor( private _myHttp: HttpService ){}\n    \n    ngOnInit() {\n        // Init 時就啟用 myMethod() 方法\n        this._myHttp.myMethod();\n    }\n}\n```\n\n私有的概念就是不容許外部存取，有點類似 `scope` 的概念。\n\n---\n## `Observable` 與 `RxJS`\n\n專案有點規模了之後，總是會需要用到 async，在 `Angular` 中要使用 async 的方式就是 `Observable` 以及 `subscribe`（用法類似 `Promise` 跟 `.then`），不過其實我也還沒搞得很懂，所以就先筆記到這裡，之後比較清楚了再回來談。\n\n---\n## 結語\n\n`Angular` 實在不是個好理解的框架，但學習曲線高，值得好好學習。熟練之後，對於模組化的 coding style 也能有所幫助的吧。\n\n---\n參考資料：\n* [Angular 網頁應用程式 Hello World 教學](https://blog.gtwang.org/web-development/angular-framework-hello-world/)\n* [Learn Angular 8 from Scratch for Beginners - Crash Course](https://www.youtube.com/watch?v=_TLhUCjY9iA)\n* [希望是最淺顯易懂的 RxJS 教學](https://blog.techbridge.cc/2017/12/08/rxjs/)\n* [TypeScript 入門教程](https://ts.xcatliu.com/)","source":"_posts/Angular-basic.md","raw":"---\ntitle: Angular 學習筆記 - 從頭認識一個框架\ndate: 2019-10-21 21:48:55\ntags: [Angular, JavaScript]\n---\n\n因為公司專案使用 `Angular`，為了能夠駕馭，就義無反顧地投入下去從頭學起啦！`Angular` 真的是個學習曲線很高的框架，規範相當嚴謹，但相對來說，前面規範細一點，後續維護就方便些，在這方面確實是比 `Vue` 有更多優勢的。\n\n<!--more-->\n\n---\n## About `Angular`\n\n### `Angular` 特色\n\n結論寫在前面：\n\n* `TypeScript` 定義資料型別\n* `Component` 元件化的撰寫風格 \n* `Services` 集中管理資料與方法\n* `Modules` 各種模組供使用\n* `RxJS Observables` 實現 async 作業\n\n`Angular` 有很多特性，身為一個 JS 框架，最基本具備的就是「模組化」的能力，因此拆分成 Component 是肯定要的。不過 `Angular` 在母／子 Component 之間的導入與導出的關係這方面，定義得相當嚴謹。舉個例來說，你定義一個 class 內含的資料，原生 JS 只要寫個變數名跟賦值就好了，像這樣：\n```javascript\nexport class myComponent {\n    myName : ''; // 先給他個空值\n}\n```\n但在 `Angular` 因為要求使用 `TypeScript` 的關係，你必須清楚定義這個變數**是什麼型別**，像這樣：\n```javascript\nexport class myComponent {\n    myName:string : ''; // 這必須是一個字串！\n}\n```\n也許對撰寫的人而言，這樣比較麻煩，但試想專案一大、變數一多，難免會搞混每個變數應該裝什麼東西，而這樣就有助於你在看 code 的時候就先有個認知（`myName` 會是一個「字串」）這樣。對於其他維護專案的人而言，也比較好懂。難道你希望在維護別人寫的扣的時候，看到的是一堆亂七八糟的東西嗎！\n```javascript\nexport class componentA {\n    A_1 : ''; // 鬼才知道這是要放什麼！我會通靈嗎！\n}\n```\n\n至於其他的特性，因為我也剛接觸不久，還不算太熟悉，就讓我們來一起發掘吧！\n\n\n### 可以邊寫邊看的東西\n\n* 跟著官方提供的風格來撰寫 Agnular 專案是比較好的：[官方撰寫風格指南](https://angular.tw/guide/styleguide)\n* 加速撰寫的速度：[速查表](https://angular.tw/guide/cheatsheet)\n* `Angular` 有些獨有的專屬詞彙：[詞彙表](https://angular.tw/guide/glossary)\n\n---\n## `TypeScript`\n\n> [TypeScript 入門教程](https://ts.xcatliu.com/)\n\n接觸 `Angular` 之前需要先對 `TypeScript` 有一定程度的了解。這類的教學在網路上有相當多資源。\n\n### 定義類型\n\n* boolean\n* number\n* string\n* void（表示此函式不會返回任何值）\n* null & undefined\n* any（表示可以被賦予任何類型的值）\n\n### 聯合類型\n\n顧名思義就是可以一次宣告多個類型：\n```javascript\nlet myNumber: string | number;\nmyNumber = 'seven';\nmyNumber = 7;\n// 不會報錯\n```\n其他的部分，因為我也還在了解，就先不多談XD\n\n---\n## `Angular CLI`\n\n> [官方 `CLI` 指令一覽表](https://angular.tw/cli)\n\n終於進到本體了！當你很開心地想要創建一個 `Angular` 專案，卻發現你需要先搞好 `node` 跟 `npm`，於是決定放棄...沒啦，我們假設大家都會使用這套工具了，那就來安裝一下 CLI：\n```javascript\n$ npm install @angular/cli\n```\n移動到專案資料夾下，並透過指令產生新 `Angular` 專案：\n```javascript\n$ ng new myApp\n// 選擇是否要啟用 routing\n// 選擇 CSS format\n// 開始創建專案啦！\n```\n\n官方建議透過 `ng generate <名稱>` 來新增元件，透過這指令，新元件會自動 binding 進根元件 `app` 中，供整個 `app` 取用。\n\n透過 `CLI` 創建的 `Angular` 專案，有非常多內容，很容易頭昏眼花。[這篇文章](https://blog.gtwang.org/web-development/angular-framework-hello-world/) 有詳細的表可以參考哪個檔案的作用是什麼。\n\n---\n## `@angular/core`\n\n一些基本的資料操作都需要先導入 `@angular/core`，另外還有一些功能會需要導入其他的模組，例如 `@angular/forms`，相關的功能與模組可以參照官方提供的表：[速查表](https://angular.tw/guide/cheatsheet)\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/core\nimport { NgModule } from '@angular/core';\n```\n\n### 基本資料操作\n\n```javascript\n// 定義 myName 資料\nexport class myComponent {\n    myName:string : '小明';\n}\n\n<div>{{ myName }}</div> // 會印出小明\n```\n\n### 實現雙向綁定\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/forms\nimport { FormsModule } from '@angular/forms';\n```\n```javascript\n// 定義空的 myName 資料\nexport class myComponent {\n    myName:string : '';\n}\n\n<input [(value)]=\"myName\" />\n<div>{{ myName }}</div> // 會印出在 input 輸入的值\n```\n\n### 實現條件渲染\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/common\nimport { CommonModule } from '@angular/common';\n```\n\n```javascript\n// 如果條件符合 A，就渲染這個 template\n<ng-template *ngIf=\"A\">\n    <p>A!!</p>\n</ng-template>\n\n// 如果條件不符合 A，就渲染這個 template\n<ng-template *ngIfElse=\"!A\">\n    <p>Not A!!</p>\n</ng-template>\n```\n\n### 實現條件判斷樣式\n\n```javascript\n// 在目標 component.ts 裡導入 @angular/common\nimport { CommonModule } from '@angular/common';\n```\n\n```javascript\n// 如果條件符合 A，就 background-color='blue'，否則 'red'\n[style.background-color]=\"A ? 'blue' : 'red'\"\n\n// 或一次判斷多個樣式\n[ngStyle]=\"{\n    'background-color': A ? 'blue': 'red',\n    'border' : A ? '1px solid red' : 'none'\n}\"\n\n// 綁定 class\n[class.<className>]=\"<達成條件>\"\n\n// 更進一步綁定 class\n[ngClass]=\"myFunction()\"\n\nmyFunction() { // 須在 component 定義 function\n    let myClasses = {\n        classA: <條件A>,\n        classB: <條件B>\n    }\n    return myClasses;\n}\n```\n\n以上都相當基本，所以做個筆記就過去了。\n\n---\n## `Routing`\n\n如果一開始創建專案時沒有選擇要 `Routing` 但後來又想用的話，可以使用 `CLI` 產生 `Routing`。\n\n```javascript\n$ ng generate module app-routing --module=app\n// --module=app：將它註冊到 AppModule 的 imports 陣列中\n```\n\n---\n## `Component`\n\n透過 `CLI` 產生的 `Component`，會自動幫你綁定在 `app` 裡。\n\n```javascript\n$ ng generate component myApp\n// 或更偷懶的寫法：\n$ ng g c myApp\n```\n會在 `app` 資料夾中產生一個 `myApp` 資料夾，並在 `app/myApp` 裡產生四個檔案：\n```javascript\nmyApp.component.html\nmyApp.component.css\nmyApp.component.ts\nmyApp.component.spec.ts\n```\n\n其中 `spec` 檔是跑測試用的，對於規模較小的專案就比較不需要注意這個。其實也是因為我還沒了解，所以就先不談。\n\n---\n## `Service`\n\n一樣，用 `CLI` 來產生一個 `service`：\n```javascript\n$ ng generate service\n```\n\n接著，在 `Component` 中導入 `Service`：\n\n```javascript\n// 在目標 component.ts 檔案裡導入 service\nimport { HttpService } from '~/http.service';\n\n// 在 export 中做以下宣告\nexport class myComponent implements OnInit {\n    // 宣告一個叫 _myHttp 的私有 service\n    constructor( private _myHttp: HttpService ){}\n    \n    ngOnInit() {\n        // Init 時就啟用 myMethod() 方法\n        this._myHttp.myMethod();\n    }\n}\n```\n\n私有的概念就是不容許外部存取，有點類似 `scope` 的概念。\n\n---\n## `Observable` 與 `RxJS`\n\n專案有點規模了之後，總是會需要用到 async，在 `Angular` 中要使用 async 的方式就是 `Observable` 以及 `subscribe`（用法類似 `Promise` 跟 `.then`），不過其實我也還沒搞得很懂，所以就先筆記到這裡，之後比較清楚了再回來談。\n\n---\n## 結語\n\n`Angular` 實在不是個好理解的框架，但學習曲線高，值得好好學習。熟練之後，對於模組化的 coding style 也能有所幫助的吧。\n\n---\n參考資料：\n* [Angular 網頁應用程式 Hello World 教學](https://blog.gtwang.org/web-development/angular-framework-hello-world/)\n* [Learn Angular 8 from Scratch for Beginners - Crash Course](https://www.youtube.com/watch?v=_TLhUCjY9iA)\n* [希望是最淺顯易懂的 RxJS 教學](https://blog.techbridge.cc/2017/12/08/rxjs/)\n* [TypeScript 入門教程](https://ts.xcatliu.com/)","slug":"Angular-basic","published":1,"updated":"2022-03-12T12:58:19.021Z","_id":"cl0nuss4k0001z6us8jj37ko9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因為公司專案使用 <code>Angular</code>，為了能夠駕馭，就義無反顧地投入下去從頭學起啦！<code>Angular</code> 真的是個學習曲線很高的框架，規範相當嚴謹，但相對來說，前面規範細一點，後續維護就方便些，在這方面確實是比 <code>Vue</code> 有更多優勢的。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"About-Angular\"><a href=\"#About-Angular\" class=\"headerlink\" title=\"About Angular\"></a>About <code>Angular</code></h2><h3 id=\"Angular-特色\"><a href=\"#Angular-特色\" class=\"headerlink\" title=\"Angular 特色\"></a><code>Angular</code> 特色</h3><p>結論寫在前面：</p>\n<ul>\n<li><code>TypeScript</code> 定義資料型別</li>\n<li><code>Component</code> 元件化的撰寫風格 </li>\n<li><code>Services</code> 集中管理資料與方法</li>\n<li><code>Modules</code> 各種模組供使用</li>\n<li><code>RxJS Observables</code> 實現 async 作業</li>\n</ul>\n<p><code>Angular</code> 有很多特性，身為一個 JS 框架，最基本具備的就是「模組化」的能力，因此拆分成 Component 是肯定要的。不過 <code>Angular</code> 在母／子 Component 之間的導入與導出的關係這方面，定義得相當嚴謹。舉個例來說，你定義一個 class 內含的資料，原生 JS 只要寫個變數名跟賦值就好了，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    myName : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 先給他個空值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但在 <code>Angular</code> 因為要求使用 <code>TypeScript</code> 的關係，你必須清楚定義這個變數<strong>是什麼型別</strong>，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 這必須是一個字串！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也許對撰寫的人而言，這樣比較麻煩，但試想專案一大、變數一多，難免會搞混每個變數應該裝什麼東西，而這樣就有助於你在看 code 的時候就先有個認知（<code>myName</code> 會是一個「字串」）這樣。對於其他維護專案的人而言，也比較好懂。難道你希望在維護別人寫的扣的時候，看到的是一堆亂七八糟的東西嗎！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">componentA</span> &#123;</span><br><span class=\"line\">    <span class=\"variable constant_\">A_1</span> : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 鬼才知道這是要放什麼！我會通靈嗎！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至於其他的特性，因為我也剛接觸不久，還不算太熟悉，就讓我們來一起發掘吧！</p>\n<h3 id=\"可以邊寫邊看的東西\"><a href=\"#可以邊寫邊看的東西\" class=\"headerlink\" title=\"可以邊寫邊看的東西\"></a>可以邊寫邊看的東西</h3><ul>\n<li>跟著官方提供的風格來撰寫 Agnular 專案是比較好的：<a class=\"link\"   href=\"https://angular.tw/guide/styleguide\" >官方撰寫風格指南<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>加速撰寫的速度：<a class=\"link\"   href=\"https://angular.tw/guide/cheatsheet\" >速查表<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><code>Angular</code> 有些獨有的專屬詞彙：<a class=\"link\"   href=\"https://angular.tw/guide/glossary\" >詞彙表<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<hr>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a><code>TypeScript</code></h2><blockquote>\n<p><a class=\"link\"   href=\"https://ts.xcatliu.com/\" >TypeScript 入門教程<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>接觸 <code>Angular</code> 之前需要先對 <code>TypeScript</code> 有一定程度的了解。這類的教學在網路上有相當多資源。</p>\n<h3 id=\"定義類型\"><a href=\"#定義類型\" class=\"headerlink\" title=\"定義類型\"></a>定義類型</h3><ul>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>void（表示此函式不會返回任何值）</li>\n<li>null &amp; undefined</li>\n<li>any（表示可以被賦予任何類型的值）</li>\n</ul>\n<h3 id=\"聯合類型\"><a href=\"#聯合類型\" class=\"headerlink\" title=\"聯合類型\"></a>聯合類型</h3><p>顧名思義就是可以一次宣告多個類型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myNumber</span>: string | number;</span><br><span class=\"line\">myNumber = <span class=\"string\">&#x27;seven&#x27;</span>;</span><br><span class=\"line\">myNumber = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"comment\">// 不會報錯</span></span><br></pre></td></tr></table></figure>\n<p>其他的部分，因為我也還在了解，就先不多談XD</p>\n<hr>\n<h2 id=\"Angular-CLI\"><a href=\"#Angular-CLI\" class=\"headerlink\" title=\"Angular CLI\"></a><code>Angular CLI</code></h2><blockquote>\n<p><a href=\"https://angular.tw/cli\">官方 <code>CLI</code> 指令一覽表</a></p>\n</blockquote>\n<p>終於進到本體了！當你很開心地想要創建一個 <code>Angular</code> 專案，卻發現你需要先搞好 <code>node</code> 跟 <code>npm</code>，於是決定放棄…沒啦，我們假設大家都會使用這套工具了，那就來安裝一下 CLI：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @angular/cli</span><br></pre></td></tr></table></figure>\n<p>移動到專案資料夾下，並透過指令產生新 <code>Angular</code> 專案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng <span class=\"keyword\">new</span> myApp</span><br><span class=\"line\"><span class=\"comment\">// 選擇是否要啟用 routing</span></span><br><span class=\"line\"><span class=\"comment\">// 選擇 CSS format</span></span><br><span class=\"line\"><span class=\"comment\">// 開始創建專案啦！</span></span><br></pre></td></tr></table></figure>\n\n<p>官方建議透過 <code>ng generate &lt;名稱&gt;</code> 來新增元件，透過這指令，新元件會自動 binding 進根元件 <code>app</code> 中，供整個 <code>app</code> 取用。</p>\n<p>透過 <code>CLI</code> 創建的 <code>Angular</code> 專案，有非常多內容，很容易頭昏眼花。<a class=\"link\"   href=\"https://blog.gtwang.org/web-development/angular-framework-hello-world/\" >這篇文章<i class=\"fas fa-external-link-alt\"></i></a> 有詳細的表可以參考哪個檔案的作用是什麼。</p>\n<hr>\n<h2 id=\"angular-core\"><a href=\"#angular-core\" class=\"headerlink\" title=\"@angular/core\"></a><code>@angular/core</code></h2><p>一些基本的資料操作都需要先導入 <code>@angular/core</code>，另外還有一些功能會需要導入其他的模組，例如 <code>@angular/forms</code>，相關的功能與模組可以參照官方提供的表：<a class=\"link\"   href=\"https://angular.tw/guide/cheatsheet\" >速查表<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/core</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本資料操作\"><a href=\"#基本資料操作\" class=\"headerlink\" title=\"基本資料操作\"></a>基本資料操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義 myName 資料</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;小明&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123; myName &#125;&#125;&lt;<span class=\"regexp\">/div&gt; /</span><span class=\"regexp\">/ 會印出小明</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現雙向綁定\"><a href=\"#實現雙向綁定\" class=\"headerlink\" title=\"實現雙向綁定\"></a>實現雙向綁定</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/forms</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">FormsModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義空的 myName 資料</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input [(value)]=<span class=\"string\">&quot;myName&quot;</span> /&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; myName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">// 會印出在 input 輸入的值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現條件渲染\"><a href=\"#實現條件渲染\" class=\"headerlink\" title=\"實現條件渲染\"></a>實現條件渲染</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/common</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CommonModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/common&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果條件符合 A，就渲染這個 template</span></span><br><span class=\"line\">&lt;ng-template *ngIf=<span class=\"string\">&quot;A&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ng-template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果條件不符合 A，就渲染這個 template</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> *<span class=\"attr\">ngIfElse</span>=<span class=\"string\">&quot;!A&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Not A!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現條件判斷樣式\"><a href=\"#實現條件判斷樣式\" class=\"headerlink\" title=\"實現條件判斷樣式\"></a>實現條件判斷樣式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/common</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CommonModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/common&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果條件符合 A，就 background-color=&#x27;blue&#x27;，否則 &#x27;red&#x27;</span></span><br><span class=\"line\">[style.<span class=\"property\">background</span>-color]=<span class=\"string\">&quot;A ? &#x27;blue&#x27; : &#x27;red&#x27;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或一次判斷多個樣式</span></span><br><span class=\"line\">[ngStyle]=<span class=\"string\">&quot;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;background-color&#x27;: A ? &#x27;blue&#x27;: &#x27;red&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;border&#x27; : A ? &#x27;1px solid red&#x27; : &#x27;none&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 綁定 class</span></span><br><span class=\"line\">[<span class=\"keyword\">class</span>.&lt;className&gt;]=<span class=\"string\">&quot;&lt;達成條件&gt;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更進一步綁定 class</span></span><br><span class=\"line\">[ngClass]=<span class=\"string\">&quot;myFunction()&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123; <span class=\"comment\">// 須在 component 定義 function</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> myClasses = &#123;</span><br><span class=\"line\">        <span class=\"attr\">classA</span>: &lt;條件A&gt;,</span><br><span class=\"line\">        <span class=\"attr\">classB</span>: &lt;條件B&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> myClasses;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上都相當基本，所以做個筆記就過去了。</p>\n<hr>\n<h2 id=\"Routing\"><a href=\"#Routing\" class=\"headerlink\" title=\"Routing\"></a><code>Routing</code></h2><p>如果一開始創建專案時沒有選擇要 <code>Routing</code> 但後來又想用的話，可以使用 <code>CLI</code> 產生 <code>Routing</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate <span class=\"variable language_\">module</span> app-routing --<span class=\"variable language_\">module</span>=app</span><br><span class=\"line\"><span class=\"comment\">// --module=app：將它註冊到 AppModule 的 imports 陣列中</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a><code>Component</code></h2><p>透過 <code>CLI</code> 產生的 <code>Component</code>，會自動幫你綁定在 <code>app</code> 裡。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate component myApp</span><br><span class=\"line\"><span class=\"comment\">// 或更偷懶的寫法：</span></span><br><span class=\"line\">$ ng g c myApp</span><br></pre></td></tr></table></figure>\n<p>會在 <code>app</code> 資料夾中產生一個 <code>myApp</code> 資料夾，並在 <code>app/myApp</code> 裡產生四個檔案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">html</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">css</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">ts</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">spec</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>spec</code> 檔是跑測試用的，對於規模較小的專案就比較不需要注意這個。其實也是因為我還沒了解，所以就先不談。</p>\n<hr>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a><code>Service</code></h2><p>一樣，用 <code>CLI</code> 來產生一個 <code>service</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate service</span><br></pre></td></tr></table></figure>\n\n<p>接著，在 <code>Component</code> 中導入 <code>Service</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 檔案裡導入 service</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">HttpService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;~/http.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 export 中做以下宣告</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> implements <span class=\"title class_\">OnInit</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 宣告一個叫 _myHttp 的私有 service</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"> private _myHttp: HttpService </span>)&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">ngOnInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Init 時就啟用 myMethod() 方法</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_myHttp</span>.<span class=\"title function_\">myMethod</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>私有的概念就是不容許外部存取，有點類似 <code>scope</code> 的概念。</p>\n<hr>\n<h2 id=\"Observable-與-RxJS\"><a href=\"#Observable-與-RxJS\" class=\"headerlink\" title=\"Observable 與 RxJS\"></a><code>Observable</code> 與 <code>RxJS</code></h2><p>專案有點規模了之後，總是會需要用到 async，在 <code>Angular</code> 中要使用 async 的方式就是 <code>Observable</code> 以及 <code>subscribe</code>（用法類似 <code>Promise</code> 跟 <code>.then</code>），不過其實我也還沒搞得很懂，所以就先筆記到這裡，之後比較清楚了再回來談。</p>\n<hr>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p><code>Angular</code> 實在不是個好理解的框架，但學習曲線高，值得好好學習。熟練之後，對於模組化的 coding style 也能有所幫助的吧。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.gtwang.org/web-development/angular-framework-hello-world/\" >Angular 網頁應用程式 Hello World 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=_TLhUCjY9iA\" >Learn Angular 8 from Scratch for Beginners - Crash Course<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/12/08/rxjs/\" >希望是最淺顯易懂的 RxJS 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ts.xcatliu.com/\" >TypeScript 入門教程<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>因為公司專案使用 <code>Angular</code>，為了能夠駕馭，就義無反顧地投入下去從頭學起啦！<code>Angular</code> 真的是個學習曲線很高的框架，規範相當嚴謹，但相對來說，前面規範細一點，後續維護就方便些，在這方面確實是比 <code>Vue</code> 有更多優勢的。</p>","more":"<hr>\n<h2 id=\"About-Angular\"><a href=\"#About-Angular\" class=\"headerlink\" title=\"About Angular\"></a>About <code>Angular</code></h2><h3 id=\"Angular-特色\"><a href=\"#Angular-特色\" class=\"headerlink\" title=\"Angular 特色\"></a><code>Angular</code> 特色</h3><p>結論寫在前面：</p>\n<ul>\n<li><code>TypeScript</code> 定義資料型別</li>\n<li><code>Component</code> 元件化的撰寫風格 </li>\n<li><code>Services</code> 集中管理資料與方法</li>\n<li><code>Modules</code> 各種模組供使用</li>\n<li><code>RxJS Observables</code> 實現 async 作業</li>\n</ul>\n<p><code>Angular</code> 有很多特性，身為一個 JS 框架，最基本具備的就是「模組化」的能力，因此拆分成 Component 是肯定要的。不過 <code>Angular</code> 在母／子 Component 之間的導入與導出的關係這方面，定義得相當嚴謹。舉個例來說，你定義一個 class 內含的資料，原生 JS 只要寫個變數名跟賦值就好了，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    myName : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 先給他個空值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但在 <code>Angular</code> 因為要求使用 <code>TypeScript</code> 的關係，你必須清楚定義這個變數<strong>是什麼型別</strong>，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 這必須是一個字串！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也許對撰寫的人而言，這樣比較麻煩，但試想專案一大、變數一多，難免會搞混每個變數應該裝什麼東西，而這樣就有助於你在看 code 的時候就先有個認知（<code>myName</code> 會是一個「字串」）這樣。對於其他維護專案的人而言，也比較好懂。難道你希望在維護別人寫的扣的時候，看到的是一堆亂七八糟的東西嗎！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">componentA</span> &#123;</span><br><span class=\"line\">    <span class=\"variable constant_\">A_1</span> : <span class=\"string\">&#x27;&#x27;</span>; <span class=\"comment\">// 鬼才知道這是要放什麼！我會通靈嗎！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至於其他的特性，因為我也剛接觸不久，還不算太熟悉，就讓我們來一起發掘吧！</p>\n<h3 id=\"可以邊寫邊看的東西\"><a href=\"#可以邊寫邊看的東西\" class=\"headerlink\" title=\"可以邊寫邊看的東西\"></a>可以邊寫邊看的東西</h3><ul>\n<li>跟著官方提供的風格來撰寫 Agnular 專案是比較好的：<a class=\"link\"   href=\"https://angular.tw/guide/styleguide\" >官方撰寫風格指南<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>加速撰寫的速度：<a class=\"link\"   href=\"https://angular.tw/guide/cheatsheet\" >速查表<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><code>Angular</code> 有些獨有的專屬詞彙：<a class=\"link\"   href=\"https://angular.tw/guide/glossary\" >詞彙表<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<hr>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a><code>TypeScript</code></h2><blockquote>\n<p><a class=\"link\"   href=\"https://ts.xcatliu.com/\" >TypeScript 入門教程<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>接觸 <code>Angular</code> 之前需要先對 <code>TypeScript</code> 有一定程度的了解。這類的教學在網路上有相當多資源。</p>\n<h3 id=\"定義類型\"><a href=\"#定義類型\" class=\"headerlink\" title=\"定義類型\"></a>定義類型</h3><ul>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>void（表示此函式不會返回任何值）</li>\n<li>null &amp; undefined</li>\n<li>any（表示可以被賦予任何類型的值）</li>\n</ul>\n<h3 id=\"聯合類型\"><a href=\"#聯合類型\" class=\"headerlink\" title=\"聯合類型\"></a>聯合類型</h3><p>顧名思義就是可以一次宣告多個類型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">myNumber</span>: string | number;</span><br><span class=\"line\">myNumber = <span class=\"string\">&#x27;seven&#x27;</span>;</span><br><span class=\"line\">myNumber = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"comment\">// 不會報錯</span></span><br></pre></td></tr></table></figure>\n<p>其他的部分，因為我也還在了解，就先不多談XD</p>\n<hr>\n<h2 id=\"Angular-CLI\"><a href=\"#Angular-CLI\" class=\"headerlink\" title=\"Angular CLI\"></a><code>Angular CLI</code></h2><blockquote>\n<p><a href=\"https://angular.tw/cli\">官方 <code>CLI</code> 指令一覽表</a></p>\n</blockquote>\n<p>終於進到本體了！當你很開心地想要創建一個 <code>Angular</code> 專案，卻發現你需要先搞好 <code>node</code> 跟 <code>npm</code>，於是決定放棄…沒啦，我們假設大家都會使用這套工具了，那就來安裝一下 CLI：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install @angular/cli</span><br></pre></td></tr></table></figure>\n<p>移動到專案資料夾下，並透過指令產生新 <code>Angular</code> 專案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng <span class=\"keyword\">new</span> myApp</span><br><span class=\"line\"><span class=\"comment\">// 選擇是否要啟用 routing</span></span><br><span class=\"line\"><span class=\"comment\">// 選擇 CSS format</span></span><br><span class=\"line\"><span class=\"comment\">// 開始創建專案啦！</span></span><br></pre></td></tr></table></figure>\n\n<p>官方建議透過 <code>ng generate &lt;名稱&gt;</code> 來新增元件，透過這指令，新元件會自動 binding 進根元件 <code>app</code> 中，供整個 <code>app</code> 取用。</p>\n<p>透過 <code>CLI</code> 創建的 <code>Angular</code> 專案，有非常多內容，很容易頭昏眼花。<a class=\"link\"   href=\"https://blog.gtwang.org/web-development/angular-framework-hello-world/\" >這篇文章<i class=\"fas fa-external-link-alt\"></i></a> 有詳細的表可以參考哪個檔案的作用是什麼。</p>\n<hr>\n<h2 id=\"angular-core\"><a href=\"#angular-core\" class=\"headerlink\" title=\"@angular/core\"></a><code>@angular/core</code></h2><p>一些基本的資料操作都需要先導入 <code>@angular/core</code>，另外還有一些功能會需要導入其他的模組，例如 <code>@angular/forms</code>，相關的功能與模組可以參照官方提供的表：<a class=\"link\"   href=\"https://angular.tw/guide/cheatsheet\" >速查表<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/core</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">NgModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本資料操作\"><a href=\"#基本資料操作\" class=\"headerlink\" title=\"基本資料操作\"></a>基本資料操作</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義 myName 資料</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;小明&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123; myName &#125;&#125;&lt;<span class=\"regexp\">/div&gt; /</span><span class=\"regexp\">/ 會印出小明</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現雙向綁定\"><a href=\"#實現雙向綁定\" class=\"headerlink\" title=\"實現雙向綁定\"></a>實現雙向綁定</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/forms</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">FormsModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義空的 myName 資料</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">myName</span>:string : <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;input [(value)]=<span class=\"string\">&quot;myName&quot;</span> /&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123; myName &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> <span class=\"comment\">// 會印出在 input 輸入的值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現條件渲染\"><a href=\"#實現條件渲染\" class=\"headerlink\" title=\"實現條件渲染\"></a>實現條件渲染</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/common</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CommonModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/common&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果條件符合 A，就渲染這個 template</span></span><br><span class=\"line\">&lt;ng-template *ngIf=<span class=\"string\">&quot;A&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>A!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ng-template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果條件不符合 A，就渲染這個 template</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ng-template</span> *<span class=\"attr\">ngIfElse</span>=<span class=\"string\">&quot;!A&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Not A!!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">ng-template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實現條件判斷樣式\"><a href=\"#實現條件判斷樣式\" class=\"headerlink\" title=\"實現條件判斷樣式\"></a>實現條件判斷樣式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 裡導入 @angular/common</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">CommonModule</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/common&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果條件符合 A，就 background-color=&#x27;blue&#x27;，否則 &#x27;red&#x27;</span></span><br><span class=\"line\">[style.<span class=\"property\">background</span>-color]=<span class=\"string\">&quot;A ? &#x27;blue&#x27; : &#x27;red&#x27;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或一次判斷多個樣式</span></span><br><span class=\"line\">[ngStyle]=<span class=\"string\">&quot;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;background-color&#x27;: A ? &#x27;blue&#x27;: &#x27;red&#x27;,</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;border&#x27; : A ? &#x27;1px solid red&#x27; : &#x27;none&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 綁定 class</span></span><br><span class=\"line\">[<span class=\"keyword\">class</span>.&lt;className&gt;]=<span class=\"string\">&quot;&lt;達成條件&gt;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更進一步綁定 class</span></span><br><span class=\"line\">[ngClass]=<span class=\"string\">&quot;myFunction()&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123; <span class=\"comment\">// 須在 component 定義 function</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> myClasses = &#123;</span><br><span class=\"line\">        <span class=\"attr\">classA</span>: &lt;條件A&gt;,</span><br><span class=\"line\">        <span class=\"attr\">classB</span>: &lt;條件B&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> myClasses;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上都相當基本，所以做個筆記就過去了。</p>\n<hr>\n<h2 id=\"Routing\"><a href=\"#Routing\" class=\"headerlink\" title=\"Routing\"></a><code>Routing</code></h2><p>如果一開始創建專案時沒有選擇要 <code>Routing</code> 但後來又想用的話，可以使用 <code>CLI</code> 產生 <code>Routing</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate <span class=\"variable language_\">module</span> app-routing --<span class=\"variable language_\">module</span>=app</span><br><span class=\"line\"><span class=\"comment\">// --module=app：將它註冊到 AppModule 的 imports 陣列中</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"Component\"></a><code>Component</code></h2><p>透過 <code>CLI</code> 產生的 <code>Component</code>，會自動幫你綁定在 <code>app</code> 裡。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate component myApp</span><br><span class=\"line\"><span class=\"comment\">// 或更偷懶的寫法：</span></span><br><span class=\"line\">$ ng g c myApp</span><br></pre></td></tr></table></figure>\n<p>會在 <code>app</code> 資料夾中產生一個 <code>myApp</code> 資料夾，並在 <code>app/myApp</code> 裡產生四個檔案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">html</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">css</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">ts</span></span><br><span class=\"line\">myApp.<span class=\"property\">component</span>.<span class=\"property\">spec</span>.<span class=\"property\">ts</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>spec</code> 檔是跑測試用的，對於規模較小的專案就比較不需要注意這個。其實也是因為我還沒了解，所以就先不談。</p>\n<hr>\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a><code>Service</code></h2><p>一樣，用 <code>CLI</code> 來產生一個 <code>service</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ng generate service</span><br></pre></td></tr></table></figure>\n\n<p>接著，在 <code>Component</code> 中導入 <code>Service</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在目標 component.ts 檔案裡導入 service</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">HttpService</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;~/http.service&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 export 中做以下宣告</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myComponent</span> implements <span class=\"title class_\">OnInit</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 宣告一個叫 _myHttp 的私有 service</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"> private _myHttp: HttpService </span>)&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">ngOnInit</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Init 時就啟用 myMethod() 方法</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_myHttp</span>.<span class=\"title function_\">myMethod</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>私有的概念就是不容許外部存取，有點類似 <code>scope</code> 的概念。</p>\n<hr>\n<h2 id=\"Observable-與-RxJS\"><a href=\"#Observable-與-RxJS\" class=\"headerlink\" title=\"Observable 與 RxJS\"></a><code>Observable</code> 與 <code>RxJS</code></h2><p>專案有點規模了之後，總是會需要用到 async，在 <code>Angular</code> 中要使用 async 的方式就是 <code>Observable</code> 以及 <code>subscribe</code>（用法類似 <code>Promise</code> 跟 <code>.then</code>），不過其實我也還沒搞得很懂，所以就先筆記到這裡，之後比較清楚了再回來談。</p>\n<hr>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p><code>Angular</code> 實在不是個好理解的框架，但學習曲線高，值得好好學習。熟練之後，對於模組化的 coding style 也能有所幫助的吧。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.gtwang.org/web-development/angular-framework-hello-world/\" >Angular 網頁應用程式 Hello World 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=_TLhUCjY9iA\" >Learn Angular 8 from Scratch for Beginners - Crash Course<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/12/08/rxjs/\" >希望是最淺顯易懂的 RxJS 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ts.xcatliu.com/\" >TypeScript 入門教程<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Angular 學習筆記 - 生命週期","date":"2019-10-23T14:37:52.000Z","_content":"\n既然 `Vue` 有一堆生命週期，那想當然 `Angular` 應該也有吧？除了最常用到的 `ngOnInit` 之外，來瞭解看看其他生命週期階段，能幫助我們在寫扣時更完整地去控制一個元件在各階段應該對資料有什麼反應。\n\n<!--more-->\n\n---\n## Component 的生命週期\n\n### 順序與互相關聯\n\n|生命週期鉤子|使用時機|\n|-|-|\n|`ngOnChanges()`| 在`ngOnInit()`之前，及所綁定的輸入屬性值變更時都會呼叫|\n|`ngOnInit()`| 第一輪 `ngOnChanges()` 完成後呼叫，只調用一次|\n|`ngDoCheck()`| 緊跟在`ngOnChanges()`和`ngOnInit()`後面呼叫|\n|`ngAfterContentInit()`| 第一次`ngDoCheck()`之後呼叫，只調用一次|\n|`ngAfterContentChecked()`| `ngAfterContentInit()`和每次`ngDoCheck()`之後呼叫|\n|`ngAfterViewInit()`| 第一次`ngAfterContentChecked()`後呼叫，只調用一次|\n|`ngAfterViewChecked()`| `ngAfterViewInit()`和每次`ngAfterContentChecked()`後呼叫|\n|`ngOnDestroy()`| 在元件銷毀之前呼叫|\n\n\n### `OnChanges`\n\n當元件有 `@Input()` 且從外部傳入資料時，會在初始化之前呼叫 `ngOnChanges()`，且每次傳入的值改變時，都會呼叫一次。\n\n### `OnInit`\n\n我們熟知的 `ngOnInit()`。在第一輪 `ngOnChanges()` 之後呼叫，元件初始化時會觸發的方法大多集中在這邊。\n\n### `DoCheck`\n\n`ngDoCheck()` 會在 `Angular` 核心程式執行變更偵測後呼叫，可以在這裡面寫點方法來額外處理變更偵測所無法偵測到的部分。\n\n### `AfterContentInit`\n\n在 `OnInit` 時還無法取得元件內容，在 `AfterContentInit` 之後就可以取得元件內容的實體。\n\n### `AfterContentChecked`\n\n在 `DoCheck` 週期後，會立刻觸發 `AfterContentInit` 週期，之後每當有變更偵測發生時，在 `DoCheck` 後觸發 `AfterContentChecked`。\n\n### `AfterViewInit` 與 `AfterViewChecked`\n\n在 `AfterContentInit` 觸發後，會觸發 `AfterViewInit`，之後觸發 `AfterViewChecked`，而在每次變更偵測後也會觸發 `AfterViewChecked`。\n\n### `OnDestroy`\n\n在元件消失時觸發，通常拿來清理資料或處理 `RxJS` 的 `subscribe` 退訂的動作，以免產生重複訂閱的行為。\n\n---\n參考資料：\n* [Angular 官網](https://angular.tw/guide/lifecycle-hooks)\n* [[Angular 大師之路] Day 04 - 認識 Angular 的生命週期](https://ithelp.ithome.com.tw/articles/10203203)","source":"_posts/Angular-lifecycle.md","raw":"---\ntitle: Angular 學習筆記 - 生命週期\ndate: 2019-10-23 22:37:52\ntags: [Angular, JavaScript, LifeCycle]\n---\n\n既然 `Vue` 有一堆生命週期，那想當然 `Angular` 應該也有吧？除了最常用到的 `ngOnInit` 之外，來瞭解看看其他生命週期階段，能幫助我們在寫扣時更完整地去控制一個元件在各階段應該對資料有什麼反應。\n\n<!--more-->\n\n---\n## Component 的生命週期\n\n### 順序與互相關聯\n\n|生命週期鉤子|使用時機|\n|-|-|\n|`ngOnChanges()`| 在`ngOnInit()`之前，及所綁定的輸入屬性值變更時都會呼叫|\n|`ngOnInit()`| 第一輪 `ngOnChanges()` 完成後呼叫，只調用一次|\n|`ngDoCheck()`| 緊跟在`ngOnChanges()`和`ngOnInit()`後面呼叫|\n|`ngAfterContentInit()`| 第一次`ngDoCheck()`之後呼叫，只調用一次|\n|`ngAfterContentChecked()`| `ngAfterContentInit()`和每次`ngDoCheck()`之後呼叫|\n|`ngAfterViewInit()`| 第一次`ngAfterContentChecked()`後呼叫，只調用一次|\n|`ngAfterViewChecked()`| `ngAfterViewInit()`和每次`ngAfterContentChecked()`後呼叫|\n|`ngOnDestroy()`| 在元件銷毀之前呼叫|\n\n\n### `OnChanges`\n\n當元件有 `@Input()` 且從外部傳入資料時，會在初始化之前呼叫 `ngOnChanges()`，且每次傳入的值改變時，都會呼叫一次。\n\n### `OnInit`\n\n我們熟知的 `ngOnInit()`。在第一輪 `ngOnChanges()` 之後呼叫，元件初始化時會觸發的方法大多集中在這邊。\n\n### `DoCheck`\n\n`ngDoCheck()` 會在 `Angular` 核心程式執行變更偵測後呼叫，可以在這裡面寫點方法來額外處理變更偵測所無法偵測到的部分。\n\n### `AfterContentInit`\n\n在 `OnInit` 時還無法取得元件內容，在 `AfterContentInit` 之後就可以取得元件內容的實體。\n\n### `AfterContentChecked`\n\n在 `DoCheck` 週期後，會立刻觸發 `AfterContentInit` 週期，之後每當有變更偵測發生時，在 `DoCheck` 後觸發 `AfterContentChecked`。\n\n### `AfterViewInit` 與 `AfterViewChecked`\n\n在 `AfterContentInit` 觸發後，會觸發 `AfterViewInit`，之後觸發 `AfterViewChecked`，而在每次變更偵測後也會觸發 `AfterViewChecked`。\n\n### `OnDestroy`\n\n在元件消失時觸發，通常拿來清理資料或處理 `RxJS` 的 `subscribe` 退訂的動作，以免產生重複訂閱的行為。\n\n---\n參考資料：\n* [Angular 官網](https://angular.tw/guide/lifecycle-hooks)\n* [[Angular 大師之路] Day 04 - 認識 Angular 的生命週期](https://ithelp.ithome.com.tw/articles/10203203)","slug":"Angular-lifecycle","published":1,"updated":"2022-03-12T12:58:19.136Z","_id":"cl0nuss730006z6us7cgj8fg3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>既然 <code>Vue</code> 有一堆生命週期，那想當然 <code>Angular</code> 應該也有吧？除了最常用到的 <code>ngOnInit</code> 之外，來瞭解看看其他生命週期階段，能幫助我們在寫扣時更完整地去控制一個元件在各階段應該對資料有什麼反應。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"Component-的生命週期\"><a href=\"#Component-的生命週期\" class=\"headerlink\" title=\"Component 的生命週期\"></a>Component 的生命週期</h2><h3 id=\"順序與互相關聯\"><a href=\"#順序與互相關聯\" class=\"headerlink\" title=\"順序與互相關聯\"></a>順序與互相關聯</h3><table>\n<thead>\n<tr>\n<th>生命週期鉤子</th>\n<th>使用時機</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ngOnChanges()</code></td>\n<td>在<code>ngOnInit()</code>之前，及所綁定的輸入屬性值變更時都會呼叫</td>\n</tr>\n<tr>\n<td><code>ngOnInit()</code></td>\n<td>第一輪 <code>ngOnChanges()</code> 完成後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngDoCheck()</code></td>\n<td>緊跟在<code>ngOnChanges()</code>和<code>ngOnInit()</code>後面呼叫</td>\n</tr>\n<tr>\n<td><code>ngAfterContentInit()</code></td>\n<td>第一次<code>ngDoCheck()</code>之後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngAfterContentChecked()</code></td>\n<td><code>ngAfterContentInit()</code>和每次<code>ngDoCheck()</code>之後呼叫</td>\n</tr>\n<tr>\n<td><code>ngAfterViewInit()</code></td>\n<td>第一次<code>ngAfterContentChecked()</code>後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngAfterViewChecked()</code></td>\n<td><code>ngAfterViewInit()</code>和每次<code>ngAfterContentChecked()</code>後呼叫</td>\n</tr>\n<tr>\n<td><code>ngOnDestroy()</code></td>\n<td>在元件銷毀之前呼叫</td>\n</tr>\n</tbody></table>\n<h3 id=\"OnChanges\"><a href=\"#OnChanges\" class=\"headerlink\" title=\"OnChanges\"></a><code>OnChanges</code></h3><p>當元件有 <code>@Input()</code> 且從外部傳入資料時，會在初始化之前呼叫 <code>ngOnChanges()</code>，且每次傳入的值改變時，都會呼叫一次。</p>\n<h3 id=\"OnInit\"><a href=\"#OnInit\" class=\"headerlink\" title=\"OnInit\"></a><code>OnInit</code></h3><p>我們熟知的 <code>ngOnInit()</code>。在第一輪 <code>ngOnChanges()</code> 之後呼叫，元件初始化時會觸發的方法大多集中在這邊。</p>\n<h3 id=\"DoCheck\"><a href=\"#DoCheck\" class=\"headerlink\" title=\"DoCheck\"></a><code>DoCheck</code></h3><p><code>ngDoCheck()</code> 會在 <code>Angular</code> 核心程式執行變更偵測後呼叫，可以在這裡面寫點方法來額外處理變更偵測所無法偵測到的部分。</p>\n<h3 id=\"AfterContentInit\"><a href=\"#AfterContentInit\" class=\"headerlink\" title=\"AfterContentInit\"></a><code>AfterContentInit</code></h3><p>在 <code>OnInit</code> 時還無法取得元件內容，在 <code>AfterContentInit</code> 之後就可以取得元件內容的實體。</p>\n<h3 id=\"AfterContentChecked\"><a href=\"#AfterContentChecked\" class=\"headerlink\" title=\"AfterContentChecked\"></a><code>AfterContentChecked</code></h3><p>在 <code>DoCheck</code> 週期後，會立刻觸發 <code>AfterContentInit</code> 週期，之後每當有變更偵測發生時，在 <code>DoCheck</code> 後觸發 <code>AfterContentChecked</code>。</p>\n<h3 id=\"AfterViewInit-與-AfterViewChecked\"><a href=\"#AfterViewInit-與-AfterViewChecked\" class=\"headerlink\" title=\"AfterViewInit 與 AfterViewChecked\"></a><code>AfterViewInit</code> 與 <code>AfterViewChecked</code></h3><p>在 <code>AfterContentInit</code> 觸發後，會觸發 <code>AfterViewInit</code>，之後觸發 <code>AfterViewChecked</code>，而在每次變更偵測後也會觸發 <code>AfterViewChecked</code>。</p>\n<h3 id=\"OnDestroy\"><a href=\"#OnDestroy\" class=\"headerlink\" title=\"OnDestroy\"></a><code>OnDestroy</code></h3><p>在元件消失時觸發，通常拿來清理資料或處理 <code>RxJS</code> 的 <code>subscribe</code> 退訂的動作，以免產生重複訂閱的行為。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://angular.tw/guide/lifecycle-hooks\" >Angular 官網<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10203203\" >[Angular 大師之路] Day 04 - 認識 Angular 的生命週期<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>既然 <code>Vue</code> 有一堆生命週期，那想當然 <code>Angular</code> 應該也有吧？除了最常用到的 <code>ngOnInit</code> 之外，來瞭解看看其他生命週期階段，能幫助我們在寫扣時更完整地去控制一個元件在各階段應該對資料有什麼反應。</p>","more":"<hr>\n<h2 id=\"Component-的生命週期\"><a href=\"#Component-的生命週期\" class=\"headerlink\" title=\"Component 的生命週期\"></a>Component 的生命週期</h2><h3 id=\"順序與互相關聯\"><a href=\"#順序與互相關聯\" class=\"headerlink\" title=\"順序與互相關聯\"></a>順序與互相關聯</h3><table>\n<thead>\n<tr>\n<th>生命週期鉤子</th>\n<th>使用時機</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ngOnChanges()</code></td>\n<td>在<code>ngOnInit()</code>之前，及所綁定的輸入屬性值變更時都會呼叫</td>\n</tr>\n<tr>\n<td><code>ngOnInit()</code></td>\n<td>第一輪 <code>ngOnChanges()</code> 完成後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngDoCheck()</code></td>\n<td>緊跟在<code>ngOnChanges()</code>和<code>ngOnInit()</code>後面呼叫</td>\n</tr>\n<tr>\n<td><code>ngAfterContentInit()</code></td>\n<td>第一次<code>ngDoCheck()</code>之後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngAfterContentChecked()</code></td>\n<td><code>ngAfterContentInit()</code>和每次<code>ngDoCheck()</code>之後呼叫</td>\n</tr>\n<tr>\n<td><code>ngAfterViewInit()</code></td>\n<td>第一次<code>ngAfterContentChecked()</code>後呼叫，只調用一次</td>\n</tr>\n<tr>\n<td><code>ngAfterViewChecked()</code></td>\n<td><code>ngAfterViewInit()</code>和每次<code>ngAfterContentChecked()</code>後呼叫</td>\n</tr>\n<tr>\n<td><code>ngOnDestroy()</code></td>\n<td>在元件銷毀之前呼叫</td>\n</tr>\n</tbody></table>\n<h3 id=\"OnChanges\"><a href=\"#OnChanges\" class=\"headerlink\" title=\"OnChanges\"></a><code>OnChanges</code></h3><p>當元件有 <code>@Input()</code> 且從外部傳入資料時，會在初始化之前呼叫 <code>ngOnChanges()</code>，且每次傳入的值改變時，都會呼叫一次。</p>\n<h3 id=\"OnInit\"><a href=\"#OnInit\" class=\"headerlink\" title=\"OnInit\"></a><code>OnInit</code></h3><p>我們熟知的 <code>ngOnInit()</code>。在第一輪 <code>ngOnChanges()</code> 之後呼叫，元件初始化時會觸發的方法大多集中在這邊。</p>\n<h3 id=\"DoCheck\"><a href=\"#DoCheck\" class=\"headerlink\" title=\"DoCheck\"></a><code>DoCheck</code></h3><p><code>ngDoCheck()</code> 會在 <code>Angular</code> 核心程式執行變更偵測後呼叫，可以在這裡面寫點方法來額外處理變更偵測所無法偵測到的部分。</p>\n<h3 id=\"AfterContentInit\"><a href=\"#AfterContentInit\" class=\"headerlink\" title=\"AfterContentInit\"></a><code>AfterContentInit</code></h3><p>在 <code>OnInit</code> 時還無法取得元件內容，在 <code>AfterContentInit</code> 之後就可以取得元件內容的實體。</p>\n<h3 id=\"AfterContentChecked\"><a href=\"#AfterContentChecked\" class=\"headerlink\" title=\"AfterContentChecked\"></a><code>AfterContentChecked</code></h3><p>在 <code>DoCheck</code> 週期後，會立刻觸發 <code>AfterContentInit</code> 週期，之後每當有變更偵測發生時，在 <code>DoCheck</code> 後觸發 <code>AfterContentChecked</code>。</p>\n<h3 id=\"AfterViewInit-與-AfterViewChecked\"><a href=\"#AfterViewInit-與-AfterViewChecked\" class=\"headerlink\" title=\"AfterViewInit 與 AfterViewChecked\"></a><code>AfterViewInit</code> 與 <code>AfterViewChecked</code></h3><p>在 <code>AfterContentInit</code> 觸發後，會觸發 <code>AfterViewInit</code>，之後觸發 <code>AfterViewChecked</code>，而在每次變更偵測後也會觸發 <code>AfterViewChecked</code>。</p>\n<h3 id=\"OnDestroy\"><a href=\"#OnDestroy\" class=\"headerlink\" title=\"OnDestroy\"></a><code>OnDestroy</code></h3><p>在元件消失時觸發，通常拿來清理資料或處理 <code>RxJS</code> 的 <code>subscribe</code> 退訂的動作，以免產生重複訂閱的行為。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://angular.tw/guide/lifecycle-hooks\" >Angular 官網<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10203203\" >[Angular 大師之路] Day 04 - 認識 Angular 的生命週期<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Git 學習筆記 - 如何使用 Git 做版本控制","date":"2021-08-28T04:06:34.000Z","_content":"\n在前端的路途上，因為技術觀念尚不扎實，常常都是先做了再說，因此時常會遇到「咦？這個觀念不是跟我平常在用的 XXX 一樣嗎？」的情況，這次要討論的主題 `Git Flow` 正是其中之一。\n\n<!--more-->\n\n---\n## 什麼是 Git Flow？\n版本控管很重要，你知道，我知道，獨眼龍也知道，但實際上到底該如何執行版本控管？理論觀念不知如何落實到實踐，應該是許多人共同的苦惱吧（至少我是啦）。\n\n先前已經認識 `Git Flow` 這個詞，只是一直沒有去正視它，最近因緣際會又與開發者朋友聊起，才認真去看了一下這到底是什麼東西。\n\n一看之下才發覺，欸，這不就是我平常在做版控的流程嗎？不過，我做的是簡易版。\n\n---\n## 我的 Git Flow\n在公司裡與我相關的專案，都會盡量導入這套習慣，大致會有下列幾種 Git 分支：\n\n### `master`\n* 容許合併：`develop`\n* 用途：發佈正式版本\n\n### `develop`\n* 容許合併：`feat/`、`fix/`\n* 用途：用來做整合測試使用\n\n### `feat/xxx`\n* 容許合併：無\n* 用途：開發新功能，須從 `master` 開出分支，開發完後合併進 `develop`\n\n### `fix/xxx`\n* 容許合併：無\n* 用途：修復 issue，因現行產品幾乎沒有發生需要緊急修復的狀況，通常產生 issue 都會安排時程來修復，因此不會直接合併進 `master`，而是會併入 `develop`，跟著下一次的版本更新上線\n\n與 Vincent Driessen 的 `Git Flow`，差別在於 `hotfix` 的合併規則不同，且沒有一個 `release` 分支。了解了這些差異後，我認為並不需要特別去修改符合到 `Git Flow` 規範，畢竟理論規範是一套「理想」的情況，但若一味追求 100% 符合的話，反而會造成時間或資源的浪費。\n\n舉個例子來說，我會使用 `UML` 做系統分析並製作開發規劃文件，以方便跟同事討論系統的活動流程、使用者行為、類別等，但若我連開發一個小功能都需要畫出完整的 `UML` 圖，那無異是多此一舉，因為就算不畫得很完整，只要足以溝通，讓開發者都明白要怎麼開發，那不就夠了嗎！\n\n剛剛好就好的人生哲學，套用到專案控管上也是說得通的。\n\n---\n## 持續精進，追求幸福 coding\n\n目前因時常一人開發，為求盡快上線，commit 就亂打（~~心態糟~~），雖說暫時不會發生問題，但這樣下去只會留下難以查閱的紀錄，不是很好的習慣。\n\n在讀完 [Kuma 老師的這篇文章](https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f) 後，非常認同使用 git flow 的目的，就是利用簡單明確的 **工作流程**，讓專案不管在開發、測試、部署、維護階段都能以最小的代價，在問題發生的前期就解決，也就是一種 **風險控制** 手段。\n\n開發者會導入一堆有的沒的套件、工作流程，不就是為了培養好習慣，讓開發更順利，生活更幸福嗎？既然如此，持續不斷地改善工作流程，才是讓生活愈來愈美好的關鍵。\n\n---\n參考資料：\n* [高見龍 - Git Flow 是什麼？為什麼需要這種東西？\n](https://gitbook.tw/chapters/gitflow/why-need-git-flow.html)\n* [Kuma 老師 - Git怎麼這麼難用？Git Flow + 好習慣 = 不再苦惱](https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f)","source":"_posts/git-flow.md","raw":"---\ntitle: Git 學習筆記 - 如何使用 Git 做版本控制\ndate: 2021-08-28 12:06:34\ntags: git\n---\n\n在前端的路途上，因為技術觀念尚不扎實，常常都是先做了再說，因此時常會遇到「咦？這個觀念不是跟我平常在用的 XXX 一樣嗎？」的情況，這次要討論的主題 `Git Flow` 正是其中之一。\n\n<!--more-->\n\n---\n## 什麼是 Git Flow？\n版本控管很重要，你知道，我知道，獨眼龍也知道，但實際上到底該如何執行版本控管？理論觀念不知如何落實到實踐，應該是許多人共同的苦惱吧（至少我是啦）。\n\n先前已經認識 `Git Flow` 這個詞，只是一直沒有去正視它，最近因緣際會又與開發者朋友聊起，才認真去看了一下這到底是什麼東西。\n\n一看之下才發覺，欸，這不就是我平常在做版控的流程嗎？不過，我做的是簡易版。\n\n---\n## 我的 Git Flow\n在公司裡與我相關的專案，都會盡量導入這套習慣，大致會有下列幾種 Git 分支：\n\n### `master`\n* 容許合併：`develop`\n* 用途：發佈正式版本\n\n### `develop`\n* 容許合併：`feat/`、`fix/`\n* 用途：用來做整合測試使用\n\n### `feat/xxx`\n* 容許合併：無\n* 用途：開發新功能，須從 `master` 開出分支，開發完後合併進 `develop`\n\n### `fix/xxx`\n* 容許合併：無\n* 用途：修復 issue，因現行產品幾乎沒有發生需要緊急修復的狀況，通常產生 issue 都會安排時程來修復，因此不會直接合併進 `master`，而是會併入 `develop`，跟著下一次的版本更新上線\n\n與 Vincent Driessen 的 `Git Flow`，差別在於 `hotfix` 的合併規則不同，且沒有一個 `release` 分支。了解了這些差異後，我認為並不需要特別去修改符合到 `Git Flow` 規範，畢竟理論規範是一套「理想」的情況，但若一味追求 100% 符合的話，反而會造成時間或資源的浪費。\n\n舉個例子來說，我會使用 `UML` 做系統分析並製作開發規劃文件，以方便跟同事討論系統的活動流程、使用者行為、類別等，但若我連開發一個小功能都需要畫出完整的 `UML` 圖，那無異是多此一舉，因為就算不畫得很完整，只要足以溝通，讓開發者都明白要怎麼開發，那不就夠了嗎！\n\n剛剛好就好的人生哲學，套用到專案控管上也是說得通的。\n\n---\n## 持續精進，追求幸福 coding\n\n目前因時常一人開發，為求盡快上線，commit 就亂打（~~心態糟~~），雖說暫時不會發生問題，但這樣下去只會留下難以查閱的紀錄，不是很好的習慣。\n\n在讀完 [Kuma 老師的這篇文章](https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f) 後，非常認同使用 git flow 的目的，就是利用簡單明確的 **工作流程**，讓專案不管在開發、測試、部署、維護階段都能以最小的代價，在問題發生的前期就解決，也就是一種 **風險控制** 手段。\n\n開發者會導入一堆有的沒的套件、工作流程，不就是為了培養好習慣，讓開發更順利，生活更幸福嗎？既然如此，持續不斷地改善工作流程，才是讓生活愈來愈美好的關鍵。\n\n---\n參考資料：\n* [高見龍 - Git Flow 是什麼？為什麼需要這種東西？\n](https://gitbook.tw/chapters/gitflow/why-need-git-flow.html)\n* [Kuma 老師 - Git怎麼這麼難用？Git Flow + 好習慣 = 不再苦惱](https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f)","slug":"git-flow","published":1,"updated":"2022-03-12T12:58:19.530Z","_id":"cl0nussjc000bz6ush0gs9why","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前端的路途上，因為技術觀念尚不扎實，常常都是先做了再說，因此時常會遇到「咦？這個觀念不是跟我平常在用的 XXX 一樣嗎？」的情況，這次要討論的主題 <code>Git Flow</code> 正是其中之一。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"什麼是-Git-Flow？\"><a href=\"#什麼是-Git-Flow？\" class=\"headerlink\" title=\"什麼是 Git Flow？\"></a>什麼是 Git Flow？</h2><p>版本控管很重要，你知道，我知道，獨眼龍也知道，但實際上到底該如何執行版本控管？理論觀念不知如何落實到實踐，應該是許多人共同的苦惱吧（至少我是啦）。</p>\n<p>先前已經認識 <code>Git Flow</code> 這個詞，只是一直沒有去正視它，最近因緣際會又與開發者朋友聊起，才認真去看了一下這到底是什麼東西。</p>\n<p>一看之下才發覺，欸，這不就是我平常在做版控的流程嗎？不過，我做的是簡易版。</p>\n<hr>\n<h2 id=\"我的-Git-Flow\"><a href=\"#我的-Git-Flow\" class=\"headerlink\" title=\"我的 Git Flow\"></a>我的 Git Flow</h2><p>在公司裡與我相關的專案，都會盡量導入這套習慣，大致會有下列幾種 Git 分支：</p>\n<h3 id=\"master\"><a href=\"#master\" class=\"headerlink\" title=\"master\"></a><code>master</code></h3><ul>\n<li>容許合併：<code>develop</code></li>\n<li>用途：發佈正式版本</li>\n</ul>\n<h3 id=\"develop\"><a href=\"#develop\" class=\"headerlink\" title=\"develop\"></a><code>develop</code></h3><ul>\n<li>容許合併：<code>feat/</code>、<code>fix/</code></li>\n<li>用途：用來做整合測試使用</li>\n</ul>\n<h3 id=\"feat-xxx\"><a href=\"#feat-xxx\" class=\"headerlink\" title=\"feat/xxx\"></a><code>feat/xxx</code></h3><ul>\n<li>容許合併：無</li>\n<li>用途：開發新功能，須從 <code>master</code> 開出分支，開發完後合併進 <code>develop</code></li>\n</ul>\n<h3 id=\"fix-xxx\"><a href=\"#fix-xxx\" class=\"headerlink\" title=\"fix/xxx\"></a><code>fix/xxx</code></h3><ul>\n<li>容許合併：無</li>\n<li>用途：修復 issue，因現行產品幾乎沒有發生需要緊急修復的狀況，通常產生 issue 都會安排時程來修復，因此不會直接合併進 <code>master</code>，而是會併入 <code>develop</code>，跟著下一次的版本更新上線</li>\n</ul>\n<p>與 Vincent Driessen 的 <code>Git Flow</code>，差別在於 <code>hotfix</code> 的合併規則不同，且沒有一個 <code>release</code> 分支。了解了這些差異後，我認為並不需要特別去修改符合到 <code>Git Flow</code> 規範，畢竟理論規範是一套「理想」的情況，但若一味追求 100% 符合的話，反而會造成時間或資源的浪費。</p>\n<p>舉個例子來說，我會使用 <code>UML</code> 做系統分析並製作開發規劃文件，以方便跟同事討論系統的活動流程、使用者行為、類別等，但若我連開發一個小功能都需要畫出完整的 <code>UML</code> 圖，那無異是多此一舉，因為就算不畫得很完整，只要足以溝通，讓開發者都明白要怎麼開發，那不就夠了嗎！</p>\n<p>剛剛好就好的人生哲學，套用到專案控管上也是說得通的。</p>\n<hr>\n<h2 id=\"持續精進，追求幸福-coding\"><a href=\"#持續精進，追求幸福-coding\" class=\"headerlink\" title=\"持續精進，追求幸福 coding\"></a>持續精進，追求幸福 coding</h2><p>目前因時常一人開發，為求盡快上線，commit 就亂打（<del>心態糟</del>），雖說暫時不會發生問題，但這樣下去只會留下難以查閱的紀錄，不是很好的習慣。</p>\n<p>在讀完 <a class=\"link\"   href=\"https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f\" >Kuma 老師的這篇文章<i class=\"fas fa-external-link-alt\"></i></a> 後，非常認同使用 git flow 的目的，就是利用簡單明確的 <strong>工作流程</strong>，讓專案不管在開發、測試、部署、維護階段都能以最小的代價，在問題發生的前期就解決，也就是一種 <strong>風險控制</strong> 手段。</p>\n<p>開發者會導入一堆有的沒的套件、工作流程，不就是為了培養好習慣，讓開發更順利，生活更幸福嗎？既然如此，持續不斷地改善工作流程，才是讓生活愈來愈美好的關鍵。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://gitbook.tw/chapters/gitflow/why-need-git-flow.html\" >高見龍 - Git Flow 是什麼？為什麼需要這種東西？\n<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f\" >Kuma 老師 - Git怎麼這麼難用？Git Flow + 好習慣 &#x3D; 不再苦惱<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在前端的路途上，因為技術觀念尚不扎實，常常都是先做了再說，因此時常會遇到「咦？這個觀念不是跟我平常在用的 XXX 一樣嗎？」的情況，這次要討論的主題 <code>Git Flow</code> 正是其中之一。</p>","more":"<hr>\n<h2 id=\"什麼是-Git-Flow？\"><a href=\"#什麼是-Git-Flow？\" class=\"headerlink\" title=\"什麼是 Git Flow？\"></a>什麼是 Git Flow？</h2><p>版本控管很重要，你知道，我知道，獨眼龍也知道，但實際上到底該如何執行版本控管？理論觀念不知如何落實到實踐，應該是許多人共同的苦惱吧（至少我是啦）。</p>\n<p>先前已經認識 <code>Git Flow</code> 這個詞，只是一直沒有去正視它，最近因緣際會又與開發者朋友聊起，才認真去看了一下這到底是什麼東西。</p>\n<p>一看之下才發覺，欸，這不就是我平常在做版控的流程嗎？不過，我做的是簡易版。</p>\n<hr>\n<h2 id=\"我的-Git-Flow\"><a href=\"#我的-Git-Flow\" class=\"headerlink\" title=\"我的 Git Flow\"></a>我的 Git Flow</h2><p>在公司裡與我相關的專案，都會盡量導入這套習慣，大致會有下列幾種 Git 分支：</p>\n<h3 id=\"master\"><a href=\"#master\" class=\"headerlink\" title=\"master\"></a><code>master</code></h3><ul>\n<li>容許合併：<code>develop</code></li>\n<li>用途：發佈正式版本</li>\n</ul>\n<h3 id=\"develop\"><a href=\"#develop\" class=\"headerlink\" title=\"develop\"></a><code>develop</code></h3><ul>\n<li>容許合併：<code>feat/</code>、<code>fix/</code></li>\n<li>用途：用來做整合測試使用</li>\n</ul>\n<h3 id=\"feat-xxx\"><a href=\"#feat-xxx\" class=\"headerlink\" title=\"feat/xxx\"></a><code>feat/xxx</code></h3><ul>\n<li>容許合併：無</li>\n<li>用途：開發新功能，須從 <code>master</code> 開出分支，開發完後合併進 <code>develop</code></li>\n</ul>\n<h3 id=\"fix-xxx\"><a href=\"#fix-xxx\" class=\"headerlink\" title=\"fix/xxx\"></a><code>fix/xxx</code></h3><ul>\n<li>容許合併：無</li>\n<li>用途：修復 issue，因現行產品幾乎沒有發生需要緊急修復的狀況，通常產生 issue 都會安排時程來修復，因此不會直接合併進 <code>master</code>，而是會併入 <code>develop</code>，跟著下一次的版本更新上線</li>\n</ul>\n<p>與 Vincent Driessen 的 <code>Git Flow</code>，差別在於 <code>hotfix</code> 的合併規則不同，且沒有一個 <code>release</code> 分支。了解了這些差異後，我認為並不需要特別去修改符合到 <code>Git Flow</code> 規範，畢竟理論規範是一套「理想」的情況，但若一味追求 100% 符合的話，反而會造成時間或資源的浪費。</p>\n<p>舉個例子來說，我會使用 <code>UML</code> 做系統分析並製作開發規劃文件，以方便跟同事討論系統的活動流程、使用者行為、類別等，但若我連開發一個小功能都需要畫出完整的 <code>UML</code> 圖，那無異是多此一舉，因為就算不畫得很完整，只要足以溝通，讓開發者都明白要怎麼開發，那不就夠了嗎！</p>\n<p>剛剛好就好的人生哲學，套用到專案控管上也是說得通的。</p>\n<hr>\n<h2 id=\"持續精進，追求幸福-coding\"><a href=\"#持續精進，追求幸福-coding\" class=\"headerlink\" title=\"持續精進，追求幸福 coding\"></a>持續精進，追求幸福 coding</h2><p>目前因時常一人開發，為求盡快上線，commit 就亂打（<del>心態糟</del>），雖說暫時不會發生問題，但這樣下去只會留下難以查閱的紀錄，不是很好的習慣。</p>\n<p>在讀完 <a class=\"link\"   href=\"https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f\" >Kuma 老師的這篇文章<i class=\"fas fa-external-link-alt\"></i></a> 後，非常認同使用 git flow 的目的，就是利用簡單明確的 <strong>工作流程</strong>，讓專案不管在開發、測試、部署、維護階段都能以最小的代價，在問題發生的前期就解決，也就是一種 <strong>風險控制</strong> 手段。</p>\n<p>開發者會導入一堆有的沒的套件、工作流程，不就是為了培養好習慣，讓開發更順利，生活更幸福嗎？既然如此，持續不斷地改善工作流程，才是讓生活愈來愈美好的關鍵。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://gitbook.tw/chapters/gitflow/why-need-git-flow.html\" >高見龍 - Git Flow 是什麼？為什麼需要這種東西？\n<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/kuma%E8%80%81%E5%B8%AB%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%95%99%E5%AE%A4/%E5%9F%BA%E7%A4%8E-git-flow-%E5%B7%A5%E4%BD%9C%E6%B3%95-fa50b1dddc4f\" >Kuma 老師 - Git怎麼這麼難用？Git Flow + 好習慣 &#x3D; 不再苦惱<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Git 學習筆記 - 如何使用 Git 做版本控制","date":"2019-10-24T14:16:32.000Z","_content":"身為一位工程師，版本控制的重要性就應該刻在你的靈魂深處。不做版控，表示你必需冒著風險修復更動程式碼之後出現的 bug，也代表你的網站被攻擊之後，沒辦法恢復到原來的狀態。\n\n<!--more-->\n\n所謂版本控制不只是備份專案，更主要的是將專案切成小塊，透過版本紀錄，可以清楚知道專案的進度、每一個版本改動了哪些東西、程式碼之間的差異。\n\n總而言之，版控是一定要的。\n\n---\n\n## 使用 Git 的流程\n\n因為 `git` 相當博大精深，指令超多，我們在一般專案操作及協作上，有個基本的認知的就可以了。平常用到的都是基本功能，哪天遇到奇怪的狀況，再查資料想辦法解決就好了。\n\n那麼，開始吧！\n\n### 配置 git\n\n> 先安裝才能使用啊：[Git 安裝教學](https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8)\n\n```bash\n# 顯示目前的 git 配置\n$ git config --list\n\n# 設定使用者\n$ git config user.name \"GK\"\n$ git config user.email \"gk@fat.com\"\n```\n\n### 產生 git 目錄\n\n開始寫扣之前，先產生一個 `git` 目錄。有人習慣用 sourcetree，也可以，但我比較喜歡用 command line 敲指令，因為這樣比較帥（喂）。\n\n```bash\n# 產生專案資料夾\n$ mkdir myProject\n\n# 移動到專案目錄\n$ cd myProject\n\n# 初始化 git\n$ git init\n\n# 看到這條訊息，表示成功 init 了\nInitialized empty Git repository in 你的專案目錄/myProject/.git/\n```\n\n### Commit 流程\n\n現在有了 `git`，可以開始做版本控管了。那麼先來看看目前是什麼情況吧。\n\n```bash\n$ git log\nfatal: your current branch 'master' does not have any commits yet\n```\n\n因為你還沒做過任何 commit，所以 `master` 主支目前是空的狀態。讓我們來試著 commit 一下。\n\n```bash\n# 將檔案添加到暫存區\n$ git add .\n\n# 將暫存區提交到倉庫\n$ git commit -m \"First Commit\"\nOn branch master\nInitial commit\nnothing to commit\n```\n\n結果因為沒有任何檔案，所以不讓你 commit。\n\n好啦，開始寫扣囉。\n\n專案進行到一個階段後，到達設定的里程碑了，打算來更新版本。假設實作好了「新增／刪除產品」的功能，此時先用上個步驟的添加文件，把進度加到暫存區，然後將暫存區提交到倉庫，完成一個版本更新。\n\n```bash\n# 將檔案添加到暫存區\n$ git add .\n\n# 將暫存區提交到倉庫\n$ git commit -m \"Update Add Product Features\"\n\n# 假如你發現 commit message 打錯了想要更改，可以這樣改寫最後一次的 commit\n$ git commit --amend -m \"Update Add & Delete Product Features\"\n\n# 如果後悔了，想要撤銷暫存區的檔案，恢復到工作區\n$ git checkout .\n```\n\n`-m` 後面那一串代表的是這次版本更新攜帶的訊息，方便之後 `git log` 時查看，這邊推薦使用英文，方便查詢。\n\n或許你會想知道能不能修改更早之前的 commit，答案是可以，只是你需要先移動到該次 commit，再用上面那招更改。\n\n### 增加／刪除文件\n\n不一定每次都要把全部更動的文件加到暫存，可以一次只加一個文件／資料夾。這樣，還沒做好的檔案就可以繼續保持狀態，而更新過的檔案就讓他進去 commit。\n\n```bash\n# 添加目前目錄的所有文件到暫存區\n$ git add .\n\n# 添加指定文件到暫存區\n$ git add [fileName]\n\n# 刪除指定文件，並把刪除的動作加入暫存區\n$ git rm [fileName]\n\n# 停止追蹤文件，但不刪除文件\n$ git rm --cached [fileName]\n```\n\n### 分支的操作\n\n分支 `branch` 非常方便，你可以想像把一整份項目的檔案全部拷貝出來，修改完其中一個部分，並確定能正常執行後，再合併回去項目本身，這就是分支的概念。\n\n特別是當多人協作的時候，每個人都可以從特定的版本去拷貝一份出來，進行自己那部份的修改，再合併回去。\n\n```bash\n# 列出所有本地分支\n$ git branch\n\n# 從當前分支新增一個分支，但停留在當前分支\n$ git branch [newBranch]\n\n# 新建一個分支並切換過去\n$ git checkout -b [newBranch]\n\n# 切換到指定分支，同時更新工作區\n$ git checkout [branchName]\n\n# 合併指定分支到目前分支\n$ git merge [branchName]\n\n# 刪除分支\n$ git branch -d [branchName]\n```\n\n### 其他操作\n\n```bash\n# 顯示目前分支的版本歷史\n$ git log\n\n# 查詢 commit 歷史\n$ git log -S [keyword]\n```\n\n---\n\n## 遠程協同作業\n\n上面是在本地端操作 `git` 的部分，那今天當多人要協作時，又是什麼情況呢？假設今天選用的遠端倉庫是 GitHub。\n\n### 與 GitHub 連動\n\n> 直接看保哥的教學比較快：[第 25 天：使用 GitHub 遠端儲存庫 - 觀念篇](https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/25.md)\n\n```bash\n# 新增一個遠端倉庫\n$ git remote add [shortName] [url]\n\n# 下載一個遠端倉庫的完整 git 歷史\n$ git clone [url]\n\n# 下載遠端倉庫的所有變動\n$ git fetch [remote]\n\n# 下載遠端倉庫的所有內容，並將遠端的 origin/master 合併到本地 master\n$ git pull\n\n# 將本地的所有變動與歷史推送到遠端倉庫\n$ git push\n```\n\n以上就是我常用的 `git` 指令。如果想對 `git` 有更深入的理解（其實我還有很多不懂的地方），就繼續找資源來鑽研吧！\n\n---\n參考資料：\n* [Git 安裝教學](https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8)\n* [30 天精通 Git 版本控管](https://github.com/doggy8088/Learn-Git-in-30-days)","source":"_posts/git.md","raw":"---\ntitle: Git 學習筆記 - 如何使用 Git 做版本控制\ndate: 2019-10-24 22:16:32\ntags: git\n---\n身為一位工程師，版本控制的重要性就應該刻在你的靈魂深處。不做版控，表示你必需冒著風險修復更動程式碼之後出現的 bug，也代表你的網站被攻擊之後，沒辦法恢復到原來的狀態。\n\n<!--more-->\n\n所謂版本控制不只是備份專案，更主要的是將專案切成小塊，透過版本紀錄，可以清楚知道專案的進度、每一個版本改動了哪些東西、程式碼之間的差異。\n\n總而言之，版控是一定要的。\n\n---\n\n## 使用 Git 的流程\n\n因為 `git` 相當博大精深，指令超多，我們在一般專案操作及協作上，有個基本的認知的就可以了。平常用到的都是基本功能，哪天遇到奇怪的狀況，再查資料想辦法解決就好了。\n\n那麼，開始吧！\n\n### 配置 git\n\n> 先安裝才能使用啊：[Git 安裝教學](https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8)\n\n```bash\n# 顯示目前的 git 配置\n$ git config --list\n\n# 設定使用者\n$ git config user.name \"GK\"\n$ git config user.email \"gk@fat.com\"\n```\n\n### 產生 git 目錄\n\n開始寫扣之前，先產生一個 `git` 目錄。有人習慣用 sourcetree，也可以，但我比較喜歡用 command line 敲指令，因為這樣比較帥（喂）。\n\n```bash\n# 產生專案資料夾\n$ mkdir myProject\n\n# 移動到專案目錄\n$ cd myProject\n\n# 初始化 git\n$ git init\n\n# 看到這條訊息，表示成功 init 了\nInitialized empty Git repository in 你的專案目錄/myProject/.git/\n```\n\n### Commit 流程\n\n現在有了 `git`，可以開始做版本控管了。那麼先來看看目前是什麼情況吧。\n\n```bash\n$ git log\nfatal: your current branch 'master' does not have any commits yet\n```\n\n因為你還沒做過任何 commit，所以 `master` 主支目前是空的狀態。讓我們來試著 commit 一下。\n\n```bash\n# 將檔案添加到暫存區\n$ git add .\n\n# 將暫存區提交到倉庫\n$ git commit -m \"First Commit\"\nOn branch master\nInitial commit\nnothing to commit\n```\n\n結果因為沒有任何檔案，所以不讓你 commit。\n\n好啦，開始寫扣囉。\n\n專案進行到一個階段後，到達設定的里程碑了，打算來更新版本。假設實作好了「新增／刪除產品」的功能，此時先用上個步驟的添加文件，把進度加到暫存區，然後將暫存區提交到倉庫，完成一個版本更新。\n\n```bash\n# 將檔案添加到暫存區\n$ git add .\n\n# 將暫存區提交到倉庫\n$ git commit -m \"Update Add Product Features\"\n\n# 假如你發現 commit message 打錯了想要更改，可以這樣改寫最後一次的 commit\n$ git commit --amend -m \"Update Add & Delete Product Features\"\n\n# 如果後悔了，想要撤銷暫存區的檔案，恢復到工作區\n$ git checkout .\n```\n\n`-m` 後面那一串代表的是這次版本更新攜帶的訊息，方便之後 `git log` 時查看，這邊推薦使用英文，方便查詢。\n\n或許你會想知道能不能修改更早之前的 commit，答案是可以，只是你需要先移動到該次 commit，再用上面那招更改。\n\n### 增加／刪除文件\n\n不一定每次都要把全部更動的文件加到暫存，可以一次只加一個文件／資料夾。這樣，還沒做好的檔案就可以繼續保持狀態，而更新過的檔案就讓他進去 commit。\n\n```bash\n# 添加目前目錄的所有文件到暫存區\n$ git add .\n\n# 添加指定文件到暫存區\n$ git add [fileName]\n\n# 刪除指定文件，並把刪除的動作加入暫存區\n$ git rm [fileName]\n\n# 停止追蹤文件，但不刪除文件\n$ git rm --cached [fileName]\n```\n\n### 分支的操作\n\n分支 `branch` 非常方便，你可以想像把一整份項目的檔案全部拷貝出來，修改完其中一個部分，並確定能正常執行後，再合併回去項目本身，這就是分支的概念。\n\n特別是當多人協作的時候，每個人都可以從特定的版本去拷貝一份出來，進行自己那部份的修改，再合併回去。\n\n```bash\n# 列出所有本地分支\n$ git branch\n\n# 從當前分支新增一個分支，但停留在當前分支\n$ git branch [newBranch]\n\n# 新建一個分支並切換過去\n$ git checkout -b [newBranch]\n\n# 切換到指定分支，同時更新工作區\n$ git checkout [branchName]\n\n# 合併指定分支到目前分支\n$ git merge [branchName]\n\n# 刪除分支\n$ git branch -d [branchName]\n```\n\n### 其他操作\n\n```bash\n# 顯示目前分支的版本歷史\n$ git log\n\n# 查詢 commit 歷史\n$ git log -S [keyword]\n```\n\n---\n\n## 遠程協同作業\n\n上面是在本地端操作 `git` 的部分，那今天當多人要協作時，又是什麼情況呢？假設今天選用的遠端倉庫是 GitHub。\n\n### 與 GitHub 連動\n\n> 直接看保哥的教學比較快：[第 25 天：使用 GitHub 遠端儲存庫 - 觀念篇](https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/25.md)\n\n```bash\n# 新增一個遠端倉庫\n$ git remote add [shortName] [url]\n\n# 下載一個遠端倉庫的完整 git 歷史\n$ git clone [url]\n\n# 下載遠端倉庫的所有變動\n$ git fetch [remote]\n\n# 下載遠端倉庫的所有內容，並將遠端的 origin/master 合併到本地 master\n$ git pull\n\n# 將本地的所有變動與歷史推送到遠端倉庫\n$ git push\n```\n\n以上就是我常用的 `git` 指令。如果想對 `git` 有更深入的理解（其實我還有很多不懂的地方），就繼續找資源來鑽研吧！\n\n---\n參考資料：\n* [Git 安裝教學](https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8)\n* [30 天精通 Git 版本控管](https://github.com/doggy8088/Learn-Git-in-30-days)","slug":"git","published":1,"updated":"2022-03-12T12:58:19.618Z","_id":"cl0nusskv000ez6us5crb0y0x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>身為一位工程師，版本控制的重要性就應該刻在你的靈魂深處。不做版控，表示你必需冒著風險修復更動程式碼之後出現的 bug，也代表你的網站被攻擊之後，沒辦法恢復到原來的狀態。</p>\n<span id=\"more\"></span>\n\n<p>所謂版本控制不只是備份專案，更主要的是將專案切成小塊，透過版本紀錄，可以清楚知道專案的進度、每一個版本改動了哪些東西、程式碼之間的差異。</p>\n<p>總而言之，版控是一定要的。</p>\n<hr>\n<h2 id=\"使用-Git-的流程\"><a href=\"#使用-Git-的流程\" class=\"headerlink\" title=\"使用 Git 的流程\"></a>使用 Git 的流程</h2><p>因為 <code>git</code> 相當博大精深，指令超多，我們在一般專案操作及協作上，有個基本的認知的就可以了。平常用到的都是基本功能，哪天遇到奇怪的狀況，再查資料想辦法解決就好了。</p>\n<p>那麼，開始吧！</p>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><blockquote>\n<p>先安裝才能使用啊：<a class=\"link\"   href=\"https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8\" >Git 安裝教學<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 顯示目前的 git 配置</span></span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者</span></span><br><span class=\"line\">$ git config user.name <span class=\"string\">&quot;GK&quot;</span></span><br><span class=\"line\">$ git config user.email <span class=\"string\">&quot;gk@fat.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"產生-git-目錄\"><a href=\"#產生-git-目錄\" class=\"headerlink\" title=\"產生 git 目錄\"></a>產生 git 目錄</h3><p>開始寫扣之前，先產生一個 <code>git</code> 目錄。有人習慣用 sourcetree，也可以，但我比較喜歡用 command line 敲指令，因為這樣比較帥（喂）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 產生專案資料夾</span></span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> myProject</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移動到專案目錄</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> myProject</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化 git</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 看到這條訊息，表示成功 init 了</span></span><br><span class=\"line\">Initialized empty Git repository <span class=\"keyword\">in</span> 你的專案目錄/myProject/.git/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Commit-流程\"><a href=\"#Commit-流程\" class=\"headerlink\" title=\"Commit 流程\"></a>Commit 流程</h3><p>現在有了 <code>git</code>，可以開始做版本控管了。那麼先來看看目前是什麼情況吧。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\">fatal: your current branch <span class=\"string\">&#x27;master&#x27;</span> does not have any commits yet</span><br></pre></td></tr></table></figure>\n\n<p>因為你還沒做過任何 commit，所以 <code>master</code> 主支目前是空的狀態。讓我們來試著 commit 一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 將檔案添加到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將暫存區提交到倉庫</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;First Commit&quot;</span></span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Initial commit</span><br><span class=\"line\">nothing to commit</span><br></pre></td></tr></table></figure>\n\n<p>結果因為沒有任何檔案，所以不讓你 commit。</p>\n<p>好啦，開始寫扣囉。</p>\n<p>專案進行到一個階段後，到達設定的里程碑了，打算來更新版本。假設實作好了「新增／刪除產品」的功能，此時先用上個步驟的添加文件，把進度加到暫存區，然後將暫存區提交到倉庫，完成一個版本更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 將檔案添加到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將暫存區提交到倉庫</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;Update Add Product Features&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假如你發現 commit message 打錯了想要更改，可以這樣改寫最後一次的 commit</span></span><br><span class=\"line\">$ git commit --amend -m <span class=\"string\">&quot;Update Add &amp; Delete Product Features&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果後悔了，想要撤銷暫存區的檔案，恢復到工作區</span></span><br><span class=\"line\">$ git checkout .</span><br></pre></td></tr></table></figure>\n\n<p><code>-m</code> 後面那一串代表的是這次版本更新攜帶的訊息，方便之後 <code>git log</code> 時查看，這邊推薦使用英文，方便查詢。</p>\n<p>或許你會想知道能不能修改更早之前的 commit，答案是可以，只是你需要先移動到該次 commit，再用上面那招更改。</p>\n<h3 id=\"增加／刪除文件\"><a href=\"#增加／刪除文件\" class=\"headerlink\" title=\"增加／刪除文件\"></a>增加／刪除文件</h3><p>不一定每次都要把全部更動的文件加到暫存，可以一次只加一個文件／資料夾。這樣，還沒做好的檔案就可以繼續保持狀態，而更新過的檔案就讓他進去 commit。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加目前目錄的所有文件到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件到暫存區</span></span><br><span class=\"line\">$ git add [fileName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 刪除指定文件，並把刪除的動作加入暫存區</span></span><br><span class=\"line\">$ git <span class=\"built_in\">rm</span> [fileName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止追蹤文件，但不刪除文件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">rm</span> --cached [fileName]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分支的操作\"><a href=\"#分支的操作\" class=\"headerlink\" title=\"分支的操作\"></a>分支的操作</h3><p>分支 <code>branch</code> 非常方便，你可以想像把一整份項目的檔案全部拷貝出來，修改完其中一個部分，並確定能正常執行後，再合併回去項目本身，這就是分支的概念。</p>\n<p>特別是當多人協作的時候，每個人都可以從特定的版本去拷貝一份出來，進行自己那部份的修改，再合併回去。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 從當前分支新增一個分支，但停留在當前分支</span></span><br><span class=\"line\">$ git branch [newBranch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一個分支並切換過去</span></span><br><span class=\"line\">$ git checkout -b [newBranch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切換到指定分支，同時更新工作區</span></span><br><span class=\"line\">$ git checkout [branchName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合併指定分支到目前分支</span></span><br><span class=\"line\">$ git merge [branchName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 刪除分支</span></span><br><span class=\"line\">$ git branch -d [branchName]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 顯示目前分支的版本歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查詢 commit 歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"遠程協同作業\"><a href=\"#遠程協同作業\" class=\"headerlink\" title=\"遠程協同作業\"></a>遠程協同作業</h2><p>上面是在本地端操作 <code>git</code> 的部分，那今天當多人要協作時，又是什麼情況呢？假設今天選用的遠端倉庫是 GitHub。</p>\n<h3 id=\"與-GitHub-連動\"><a href=\"#與-GitHub-連動\" class=\"headerlink\" title=\"與 GitHub 連動\"></a>與 GitHub 連動</h3><blockquote>\n<p>直接看保哥的教學比較快：<a class=\"link\"   href=\"https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/25.md\" >第 25 天：使用 GitHub 遠端儲存庫 - 觀念篇<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新增一個遠端倉庫</span></span><br><span class=\"line\">$ git remote add [shortName] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載一個遠端倉庫的完整 git 歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載遠端倉庫的所有變動</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載遠端倉庫的所有內容，並將遠端的 origin/master 合併到本地 master</span></span><br><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將本地的所有變動與歷史推送到遠端倉庫</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我常用的 <code>git</code> 指令。如果想對 <code>git</code> 有更深入的理解（其實我還有很多不懂的地方），就繼續找資源來鑽研吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8\" >Git 安裝教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/doggy8088/Learn-Git-in-30-days\" >30 天精通 Git 版本控管<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>身為一位工程師，版本控制的重要性就應該刻在你的靈魂深處。不做版控，表示你必需冒著風險修復更動程式碼之後出現的 bug，也代表你的網站被攻擊之後，沒辦法恢復到原來的狀態。</p>","more":"<p>所謂版本控制不只是備份專案，更主要的是將專案切成小塊，透過版本紀錄，可以清楚知道專案的進度、每一個版本改動了哪些東西、程式碼之間的差異。</p>\n<p>總而言之，版控是一定要的。</p>\n<hr>\n<h2 id=\"使用-Git-的流程\"><a href=\"#使用-Git-的流程\" class=\"headerlink\" title=\"使用 Git 的流程\"></a>使用 Git 的流程</h2><p>因為 <code>git</code> 相當博大精深，指令超多，我們在一般專案操作及協作上，有個基本的認知的就可以了。平常用到的都是基本功能，哪天遇到奇怪的狀況，再查資料想辦法解決就好了。</p>\n<p>那麼，開始吧！</p>\n<h3 id=\"配置-git\"><a href=\"#配置-git\" class=\"headerlink\" title=\"配置 git\"></a>配置 git</h3><blockquote>\n<p>先安裝才能使用啊：<a class=\"link\"   href=\"https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8\" >Git 安裝教學<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 顯示目前的 git 配置</span></span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者</span></span><br><span class=\"line\">$ git config user.name <span class=\"string\">&quot;GK&quot;</span></span><br><span class=\"line\">$ git config user.email <span class=\"string\">&quot;gk@fat.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"產生-git-目錄\"><a href=\"#產生-git-目錄\" class=\"headerlink\" title=\"產生 git 目錄\"></a>產生 git 目錄</h3><p>開始寫扣之前，先產生一個 <code>git</code> 目錄。有人習慣用 sourcetree，也可以，但我比較喜歡用 command line 敲指令，因為這樣比較帥（喂）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 產生專案資料夾</span></span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> myProject</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 移動到專案目錄</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> myProject</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化 git</span></span><br><span class=\"line\">$ git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 看到這條訊息，表示成功 init 了</span></span><br><span class=\"line\">Initialized empty Git repository <span class=\"keyword\">in</span> 你的專案目錄/myProject/.git/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Commit-流程\"><a href=\"#Commit-流程\" class=\"headerlink\" title=\"Commit 流程\"></a>Commit 流程</h3><p>現在有了 <code>git</code>，可以開始做版本控管了。那麼先來看看目前是什麼情況吧。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\">fatal: your current branch <span class=\"string\">&#x27;master&#x27;</span> does not have any commits yet</span><br></pre></td></tr></table></figure>\n\n<p>因為你還沒做過任何 commit，所以 <code>master</code> 主支目前是空的狀態。讓我們來試著 commit 一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 將檔案添加到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將暫存區提交到倉庫</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;First Commit&quot;</span></span><br><span class=\"line\">On branch master</span><br><span class=\"line\">Initial commit</span><br><span class=\"line\">nothing to commit</span><br></pre></td></tr></table></figure>\n\n<p>結果因為沒有任何檔案，所以不讓你 commit。</p>\n<p>好啦，開始寫扣囉。</p>\n<p>專案進行到一個階段後，到達設定的里程碑了，打算來更新版本。假設實作好了「新增／刪除產品」的功能，此時先用上個步驟的添加文件，把進度加到暫存區，然後將暫存區提交到倉庫，完成一個版本更新。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 將檔案添加到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將暫存區提交到倉庫</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">&quot;Update Add Product Features&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假如你發現 commit message 打錯了想要更改，可以這樣改寫最後一次的 commit</span></span><br><span class=\"line\">$ git commit --amend -m <span class=\"string\">&quot;Update Add &amp; Delete Product Features&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果後悔了，想要撤銷暫存區的檔案，恢復到工作區</span></span><br><span class=\"line\">$ git checkout .</span><br></pre></td></tr></table></figure>\n\n<p><code>-m</code> 後面那一串代表的是這次版本更新攜帶的訊息，方便之後 <code>git log</code> 時查看，這邊推薦使用英文，方便查詢。</p>\n<p>或許你會想知道能不能修改更早之前的 commit，答案是可以，只是你需要先移動到該次 commit，再用上面那招更改。</p>\n<h3 id=\"增加／刪除文件\"><a href=\"#增加／刪除文件\" class=\"headerlink\" title=\"增加／刪除文件\"></a>增加／刪除文件</h3><p>不一定每次都要把全部更動的文件加到暫存，可以一次只加一個文件／資料夾。這樣，還沒做好的檔案就可以繼續保持狀態，而更新過的檔案就讓他進去 commit。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 添加目前目錄的所有文件到暫存區</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加指定文件到暫存區</span></span><br><span class=\"line\">$ git add [fileName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 刪除指定文件，並把刪除的動作加入暫存區</span></span><br><span class=\"line\">$ git <span class=\"built_in\">rm</span> [fileName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止追蹤文件，但不刪除文件</span></span><br><span class=\"line\">$ git <span class=\"built_in\">rm</span> --cached [fileName]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分支的操作\"><a href=\"#分支的操作\" class=\"headerlink\" title=\"分支的操作\"></a>分支的操作</h3><p>分支 <code>branch</code> 非常方便，你可以想像把一整份項目的檔案全部拷貝出來，修改完其中一個部分，並確定能正常執行後，再合併回去項目本身，這就是分支的概念。</p>\n<p>特別是當多人協作的時候，每個人都可以從特定的版本去拷貝一份出來，進行自己那部份的修改，再合併回去。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出所有本地分支</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 從當前分支新增一個分支，但停留在當前分支</span></span><br><span class=\"line\">$ git branch [newBranch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一個分支並切換過去</span></span><br><span class=\"line\">$ git checkout -b [newBranch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切換到指定分支，同時更新工作區</span></span><br><span class=\"line\">$ git checkout [branchName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合併指定分支到目前分支</span></span><br><span class=\"line\">$ git merge [branchName]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 刪除分支</span></span><br><span class=\"line\">$ git branch -d [branchName]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 顯示目前分支的版本歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查詢 commit 歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> -S [keyword]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"遠程協同作業\"><a href=\"#遠程協同作業\" class=\"headerlink\" title=\"遠程協同作業\"></a>遠程協同作業</h2><p>上面是在本地端操作 <code>git</code> 的部分，那今天當多人要協作時，又是什麼情況呢？假設今天選用的遠端倉庫是 GitHub。</p>\n<h3 id=\"與-GitHub-連動\"><a href=\"#與-GitHub-連動\" class=\"headerlink\" title=\"與 GitHub 連動\"></a>與 GitHub 連動</h3><blockquote>\n<p>直接看保哥的教學比較快：<a class=\"link\"   href=\"https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/25.md\" >第 25 天：使用 GitHub 遠端儲存庫 - 觀念篇<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新增一個遠端倉庫</span></span><br><span class=\"line\">$ git remote add [shortName] [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載一個遠端倉庫的完整 git 歷史</span></span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> [url]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載遠端倉庫的所有變動</span></span><br><span class=\"line\">$ git fetch [remote]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 下載遠端倉庫的所有內容，並將遠端的 origin/master 合併到本地 master</span></span><br><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 將本地的所有變動與歷史推送到遠端倉庫</span></span><br><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我常用的 <code>git</code> 指令。如果想對 <code>git</code> 有更深入的理解（其實我還有很多不懂的地方），就繼續找資源來鑽研吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://git-scm.com/book/zh-tw/v2/%E9%96%8B%E5%A7%8B-Git-%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8\" >Git 安裝教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/doggy8088/Learn-Git-in-30-days\" >30 天精通 Git 版本控管<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Golang 學習筆記 - 初步接觸 Go!","date":"2021-09-05T00:34:03.000Z","_content":"\n為了看懂後端主管寫的專案原始碼，趁著最近專案開發中間空檔，趕快來學習一下 Golang！基於自學習慣，我會先概覽這個語言的基礎，之後再針對遇到的主題進一步研究。\n\n<!--more-->\n\n本次整理出三個部分：\n* [Go 的資料型別](##Go的資料型別)\n* [Go 的套件](##Go的套件)\n* [Go 的撰寫風格](##Go的撰寫風格)\n\n---\n## Go的資料型別\n#### 數字（Number）\n* 無號整數：`uint`、`uint8`、`uint16`、`uint32`、`uint64`\n* 有號整數：`int`、`int8`、`int16`、`int32`、`int64`\n* 浮點數：`float32`、`float64`\n* 複數：`complex64`、`complex128`\n#### 字串（String）\n* `string`：UTF-8 編碼的字串\n* `byte`：不以編碼處理的字串\n* `rune`：型別為`int32` 的值\n#### 布林（Boolean）\n* `true`：真\n* `false`：偽\n#### 陣列（Array）\n* 以數字為索引的線性容器，長度固定。\n#### 結構（Struct）\n* 宣告一個資料結構（非實體），具有哪些參數以及型別。\n#### 指標（Pointer）\n* 指向儲存其他值的「位址」，透過指標可間接存取值。\n#### 切片（Slice）\n* 以數字為索引的線性容器，長度可以伸縮。\n#### 映射（Map）\n* 以 key-value pair 的非線性資料結構，以雜湊方式儲存在記憶體中。\n#### 函式（Function）\n* 提供具有行為的函式，作為型別來定義變數。\n#### 通道（Channel）\n* 在 Goroutine 之間傳遞資料。\n#### 介面（Interface）\n* 抽象型別，不顯露內部的值，而只提供可操作的行為。\n\n\n---\n## Go的套件\nGo 以 package 來組織程式，因此每個原始碼檔案的開頭都會是 `package <fileName>`，以作為一個 package 來讓其他檔案調用。\n\n下面整理 Go 內建的一些常用套件。\n\n### `fmt`：格式化輸出以及掃描輸入\n#### 轉換格式：`fmt.Print()`、`fmt.Printf()`、`fmt.Println()`\n轉換格式後輸出值，如下例：\n```go=\nappleColor := \"red\"\nfmt.Printf(\"Color of apple: %v\\n\", appleColor)\n// 印出 Color of apple: red\n\nfmt.Printf(\"Color of apple: %q\\n\", appleColor)\n// 印出 Color of apple: \"red\"\n\nfmt.Printf(\"Color of apple: %T\\n\", appleColor)\n// 印出 Color of apple: string\n```\n\n||常用轉換格式|\n|-|-|\n|%v|值自然格式|\n|%s|字串|\n|%q|加引號的字串|\n|%T|值型別|\n\n#### 組合字串：`fmt.Sprint()`、`fmt.Sprintln()`、`fmt.Sprintf()`\n不會印出東西，而是拿來組合字串用的。\n```go=\nv1 := \"I\"\nv2 := \"am\"\nv3 := \"Iron Man\"\n\ncombineString := fmt.Sprintln(v1, v2, v3)\nfmt.Println(combineString)\n// 印出 I am Iron Man\n```\n\n### `os`、`io`、`bufio`：存取作業系統\n#### 存取作業系統：`os.Open()`、`os.Create()`、`os.Remove()`、`os.Mkdir()`\n建立、編輯或移除作業系統中的資料夾、檔案。\n#### 存取命令列參數：`os.Args[1:]`\n取得開啟檔案時命令列的參數，`[1:]` 為刪除掉第一個參數（程式執行的路徑）。\n#### 存取作業系統：`io/ioutil.ReadFile()`、`io/ioutil.ReadDir()`\n建立、編輯或移除作業系統中的資料夾、檔案。\n#### 存取作業系統：`bufio.NewWriter()`\n實作了 `io` 的一些介面，能更方便地建立、編輯或移除作業系統中的資料夾、檔案。\n。\n\n> 如果你跟我一樣，覺得這些 Package 都很像，產生了「這麼多種，到底什麼時候要用哪個？差別在哪裡？」的疑惑，可以看看這篇：[掘金 - Go指南10-谈谈对Golang IO读写的困惑](https://juejin.cn/post/6864886461746855949)\n> \n### `flag`：從命令列取得參數在程式碼中使用\n#### 設置外來變數：`flag.String()`、`flag.Bool()`、`flag.Int()`、`flag.Var()`\n使用這個套件，可以讓使用者在啟動專案時代入參數，進而達到一份專案中包含多功能的效果。\n\n---\n## Go的撰寫風格\n### 使用指標（Pointer）來做變數處理\n\n在宣告一個變數時，會在記憶體中給予其一個位址來存放它的相關設定（型別、值），而 Go 提供一種方法來取用該變數的位址或者指向它做變更，這樣就不用拷貝該變數，多消耗一個記憶體位址。當需要跨函式對同一變數做存取時，這個方法相當有幫助。\n\n* `*`：Point to，指向某個記憶體位址的值\n* `&`：Address of，某個變數的記憶體位址\n\n```go=\na := 7   // 宣告一個 int 變數\np := &a  // 宣告一個變數 p，指向 a 的位址\n\nfmt.Printf(\"Value of a:%v\\n\", a)\n// 印出 Value of a:7\n\nfmt.Printf(\"Address of a:%v\\n\", &a)\n// 印出 Address of a:0xc000118000\n\nfmt.Printf(\"Value of p:%v\\n\", p)\n// 印出 Value of p:0xc000118000\n\n*p = 8   // 修改 *p 的值，影響到 a\nfmt.Printf(\"Value of a:%v\\n\", a)\n// 印出 Value of a:8\n```\n\n從上述例子可以看出，`p` 這個變數儲存的是 `a` 的記憶體位址，而修改 `*p` 的值，等於修改到 `a` 的值。若將 `p`（a.k.a:`a` 的記憶體位址）作為變數在函式之間傳遞使用，再用指標指向 `*p`，就可以在各函式之間對同一個變數做處理，不用一直耗費記憶體來建立新的變數。\n\n\n### 利用 `defer`（延遲觸發）來做例外處理\n對於例外處理的這一塊，因為還沒有實際寫出一個 Go 專案，因此還不是很能領會實作方式。\n\n#### `defer`（延遲處理）\n* 使用 `defer` 將工作延遲到想要的時間點執行。\n* 當程式結束時，多個 `defer` 處理將以反向順序執行，也就是 LIFO（Last In First Out）。\n#### `panic`（中斷）\n* 當發生錯誤（也就是常見的 `err != nil`）時，透過 `panic` 來將函式中斷。\n#### `recover`（恢復）\n* 在發生了 `panic` 而導致流程中斷後，如果想要讓程式繼續做別的處理，就可以使用 `recover`。但 `recover` 必須在 `defer` 中執行，否則回傳值會是 `nil`。\n\n\n---\n### 利用 `goroutine` 來做併發處理\nGo 特色之一就是對於 concurrency 的處理，而 Go 提供的作法就是使用 goroutine。\n\n#### `Goroutine`（執行緒）\n只要在函式前加上 `go`，就會開啟一個新的 goroutine。\n```go=\nf()    // 呼叫執行 f()\ngo f() // 建立一個新的 goroutine 來呼叫執行 f()\n```\nGoroutine 能讓各個函式同時進行，而不用相互等待，我以前端的 `Ajax`，或 Python 的 `Thread` 來理解，就比較能想像了。\n\n#### `Channel`（通道）+ `Select`（選擇）\nChannel 是運行中的 goroutine 之間的連線管道，可以讓其中一個 goroutine 發送訊息給其他 goroutine。要建構 channel，可以這樣做：\n```go=\nch := make(chan int)     // 建構一個型別為 chan int 的 channel\nch2 := make(chan string) // 建構一個型別為 chan string 的 channel\nch3 := make(chan bool)   // 建構一個型別為 chan bool 的 channel\n```\nChannel 具有 **發送** 與 **接收** 兩種基本操作，通稱為 **通訊**。\n```go=\nch <- x   // 發送 x 給 channel\ny  <- ch  // y 接收來自 ch 的值\n<- ch     // 拋棄結果\nclose(ch) // 關閉 channel\n```\n可以透過 **關閉** 操作來讓 channel 不再接收值，若再發送值到此 channel，會引發 panic。在已經關閉的 channel 上取值，會取出直到沒有值為止，之後的接收操作會得到 nil。\n\n對 channel 的進一步討論，我會另外再整理一篇心得。\n\n#### `Mutex`（互斥鎖）\n當有多個 gouroutine 在運行中時，有時會出現互相影響的狀況，此時需要設定讓其中一個 goroutine 先執行完畢，才能開放給其他 goroutine 使用，而這樣的方式就是 `Mutex.Lock()`。《精通 Go 程式設計》中舉了以下例子：\n```go=\nimport \"sync\"\n\nvar (\n    mu sync.Mutex\n    balance int\n)\n\nfunc Deposit(amount int) {\n    mu.Lock()                   // 上鎖\n    balance = balance + amount  // 確保一次只有一個 goroutine 能改變餘額\n    mu.Unlock()                 // 釋放鎖\n}\n\nfunc Balance() int {\n    mu.Lock()\n    b := balance\n    mu.Unlock()\n    return b\n}\n```\n\n#### `WaitGroup`（等待群組）\n若今天要等到所有 goroutine 都處理完畢再進行下一個動作，除了 channel 之外，`sync` 套件也提供了 WaitGroup 的方式來達到這樣的效果（以 UML 來說，就是「等待分支節點結合 Join」）。\n\n詳細的 WaitGroup 使用方式就不贅述。\n\n#### `Context`（背景）\n叫做背景可能不太精確，context 是在剛開始用 `gin` 寫 http server 的時候就很常見的一個東西，但實際上還是不太了解它的意思。經過粗淺的研究後，才知道 context 的主要用途，是在背景管理所有不定數量的 goroutine。\n\n對於目前的我來說，理解 context 還太早，等之後對 goroutine 的使用更熟悉了，再回頭來重新認識 context，會是比較有效率的學習方式。\n\n\n---\n## 小結\n經過本文的整理，對 Go 有了基本淺層的認識，也大致上知道 Go 的優勢以及風格是什麼，這樣應該會對理解主管的專案程式碼有些許的幫助（吧）。愈學愈覺得，Go 是個很棒的語言，主要是他的規範很嚴格，但又相當好懂，對於整理與維護來說非常友善！雖然目前的自己都在寫義大利麵 code，但心中也是有著寫 clean code 的嚮往啊！\n\n總而言之，大家一起學 Go 吧！\n\n\n---\n參考資料：\n* Alan A.A. Donovan - 精通 Go 程式設計\n* [PJCHENder - [Golang] Struct](https://pjchender.dev/golang/structs/)\n* [iT邦幫忙 - Golang 入門到進階實戰：Day 18 常用基本庫介紹](https://ithelp.ithome.com.tw/articles/10223934/)\n* [掘金 - Go指南10-谈谈对Golang IO读写的困惑](https://juejin.cn/post/6864886461746855949)\n* [小惡魔 - AppleBOY - 在 Go 語言內管理 Concurrency 的三種方式](https://blog.wu-boy.com/2020/08/three-ways-to-manage-concurrency-in-go/)\n* [iT邦幫忙 - Go劍復國-30天導入Golang：Golang Concurrency Pattern](https://ithelp.ithome.com.tw/articles/10208936)","source":"_posts/golang-basic.md","raw":"---\ntitle: Golang 學習筆記 - 初步接觸 Go!\ndate: 2021-09-05 08:34:03\ntags: [後端開發, Go]\n---\n\n為了看懂後端主管寫的專案原始碼，趁著最近專案開發中間空檔，趕快來學習一下 Golang！基於自學習慣，我會先概覽這個語言的基礎，之後再針對遇到的主題進一步研究。\n\n<!--more-->\n\n本次整理出三個部分：\n* [Go 的資料型別](##Go的資料型別)\n* [Go 的套件](##Go的套件)\n* [Go 的撰寫風格](##Go的撰寫風格)\n\n---\n## Go的資料型別\n#### 數字（Number）\n* 無號整數：`uint`、`uint8`、`uint16`、`uint32`、`uint64`\n* 有號整數：`int`、`int8`、`int16`、`int32`、`int64`\n* 浮點數：`float32`、`float64`\n* 複數：`complex64`、`complex128`\n#### 字串（String）\n* `string`：UTF-8 編碼的字串\n* `byte`：不以編碼處理的字串\n* `rune`：型別為`int32` 的值\n#### 布林（Boolean）\n* `true`：真\n* `false`：偽\n#### 陣列（Array）\n* 以數字為索引的線性容器，長度固定。\n#### 結構（Struct）\n* 宣告一個資料結構（非實體），具有哪些參數以及型別。\n#### 指標（Pointer）\n* 指向儲存其他值的「位址」，透過指標可間接存取值。\n#### 切片（Slice）\n* 以數字為索引的線性容器，長度可以伸縮。\n#### 映射（Map）\n* 以 key-value pair 的非線性資料結構，以雜湊方式儲存在記憶體中。\n#### 函式（Function）\n* 提供具有行為的函式，作為型別來定義變數。\n#### 通道（Channel）\n* 在 Goroutine 之間傳遞資料。\n#### 介面（Interface）\n* 抽象型別，不顯露內部的值，而只提供可操作的行為。\n\n\n---\n## Go的套件\nGo 以 package 來組織程式，因此每個原始碼檔案的開頭都會是 `package <fileName>`，以作為一個 package 來讓其他檔案調用。\n\n下面整理 Go 內建的一些常用套件。\n\n### `fmt`：格式化輸出以及掃描輸入\n#### 轉換格式：`fmt.Print()`、`fmt.Printf()`、`fmt.Println()`\n轉換格式後輸出值，如下例：\n```go=\nappleColor := \"red\"\nfmt.Printf(\"Color of apple: %v\\n\", appleColor)\n// 印出 Color of apple: red\n\nfmt.Printf(\"Color of apple: %q\\n\", appleColor)\n// 印出 Color of apple: \"red\"\n\nfmt.Printf(\"Color of apple: %T\\n\", appleColor)\n// 印出 Color of apple: string\n```\n\n||常用轉換格式|\n|-|-|\n|%v|值自然格式|\n|%s|字串|\n|%q|加引號的字串|\n|%T|值型別|\n\n#### 組合字串：`fmt.Sprint()`、`fmt.Sprintln()`、`fmt.Sprintf()`\n不會印出東西，而是拿來組合字串用的。\n```go=\nv1 := \"I\"\nv2 := \"am\"\nv3 := \"Iron Man\"\n\ncombineString := fmt.Sprintln(v1, v2, v3)\nfmt.Println(combineString)\n// 印出 I am Iron Man\n```\n\n### `os`、`io`、`bufio`：存取作業系統\n#### 存取作業系統：`os.Open()`、`os.Create()`、`os.Remove()`、`os.Mkdir()`\n建立、編輯或移除作業系統中的資料夾、檔案。\n#### 存取命令列參數：`os.Args[1:]`\n取得開啟檔案時命令列的參數，`[1:]` 為刪除掉第一個參數（程式執行的路徑）。\n#### 存取作業系統：`io/ioutil.ReadFile()`、`io/ioutil.ReadDir()`\n建立、編輯或移除作業系統中的資料夾、檔案。\n#### 存取作業系統：`bufio.NewWriter()`\n實作了 `io` 的一些介面，能更方便地建立、編輯或移除作業系統中的資料夾、檔案。\n。\n\n> 如果你跟我一樣，覺得這些 Package 都很像，產生了「這麼多種，到底什麼時候要用哪個？差別在哪裡？」的疑惑，可以看看這篇：[掘金 - Go指南10-谈谈对Golang IO读写的困惑](https://juejin.cn/post/6864886461746855949)\n> \n### `flag`：從命令列取得參數在程式碼中使用\n#### 設置外來變數：`flag.String()`、`flag.Bool()`、`flag.Int()`、`flag.Var()`\n使用這個套件，可以讓使用者在啟動專案時代入參數，進而達到一份專案中包含多功能的效果。\n\n---\n## Go的撰寫風格\n### 使用指標（Pointer）來做變數處理\n\n在宣告一個變數時，會在記憶體中給予其一個位址來存放它的相關設定（型別、值），而 Go 提供一種方法來取用該變數的位址或者指向它做變更，這樣就不用拷貝該變數，多消耗一個記憶體位址。當需要跨函式對同一變數做存取時，這個方法相當有幫助。\n\n* `*`：Point to，指向某個記憶體位址的值\n* `&`：Address of，某個變數的記憶體位址\n\n```go=\na := 7   // 宣告一個 int 變數\np := &a  // 宣告一個變數 p，指向 a 的位址\n\nfmt.Printf(\"Value of a:%v\\n\", a)\n// 印出 Value of a:7\n\nfmt.Printf(\"Address of a:%v\\n\", &a)\n// 印出 Address of a:0xc000118000\n\nfmt.Printf(\"Value of p:%v\\n\", p)\n// 印出 Value of p:0xc000118000\n\n*p = 8   // 修改 *p 的值，影響到 a\nfmt.Printf(\"Value of a:%v\\n\", a)\n// 印出 Value of a:8\n```\n\n從上述例子可以看出，`p` 這個變數儲存的是 `a` 的記憶體位址，而修改 `*p` 的值，等於修改到 `a` 的值。若將 `p`（a.k.a:`a` 的記憶體位址）作為變數在函式之間傳遞使用，再用指標指向 `*p`，就可以在各函式之間對同一個變數做處理，不用一直耗費記憶體來建立新的變數。\n\n\n### 利用 `defer`（延遲觸發）來做例外處理\n對於例外處理的這一塊，因為還沒有實際寫出一個 Go 專案，因此還不是很能領會實作方式。\n\n#### `defer`（延遲處理）\n* 使用 `defer` 將工作延遲到想要的時間點執行。\n* 當程式結束時，多個 `defer` 處理將以反向順序執行，也就是 LIFO（Last In First Out）。\n#### `panic`（中斷）\n* 當發生錯誤（也就是常見的 `err != nil`）時，透過 `panic` 來將函式中斷。\n#### `recover`（恢復）\n* 在發生了 `panic` 而導致流程中斷後，如果想要讓程式繼續做別的處理，就可以使用 `recover`。但 `recover` 必須在 `defer` 中執行，否則回傳值會是 `nil`。\n\n\n---\n### 利用 `goroutine` 來做併發處理\nGo 特色之一就是對於 concurrency 的處理，而 Go 提供的作法就是使用 goroutine。\n\n#### `Goroutine`（執行緒）\n只要在函式前加上 `go`，就會開啟一個新的 goroutine。\n```go=\nf()    // 呼叫執行 f()\ngo f() // 建立一個新的 goroutine 來呼叫執行 f()\n```\nGoroutine 能讓各個函式同時進行，而不用相互等待，我以前端的 `Ajax`，或 Python 的 `Thread` 來理解，就比較能想像了。\n\n#### `Channel`（通道）+ `Select`（選擇）\nChannel 是運行中的 goroutine 之間的連線管道，可以讓其中一個 goroutine 發送訊息給其他 goroutine。要建構 channel，可以這樣做：\n```go=\nch := make(chan int)     // 建構一個型別為 chan int 的 channel\nch2 := make(chan string) // 建構一個型別為 chan string 的 channel\nch3 := make(chan bool)   // 建構一個型別為 chan bool 的 channel\n```\nChannel 具有 **發送** 與 **接收** 兩種基本操作，通稱為 **通訊**。\n```go=\nch <- x   // 發送 x 給 channel\ny  <- ch  // y 接收來自 ch 的值\n<- ch     // 拋棄結果\nclose(ch) // 關閉 channel\n```\n可以透過 **關閉** 操作來讓 channel 不再接收值，若再發送值到此 channel，會引發 panic。在已經關閉的 channel 上取值，會取出直到沒有值為止，之後的接收操作會得到 nil。\n\n對 channel 的進一步討論，我會另外再整理一篇心得。\n\n#### `Mutex`（互斥鎖）\n當有多個 gouroutine 在運行中時，有時會出現互相影響的狀況，此時需要設定讓其中一個 goroutine 先執行完畢，才能開放給其他 goroutine 使用，而這樣的方式就是 `Mutex.Lock()`。《精通 Go 程式設計》中舉了以下例子：\n```go=\nimport \"sync\"\n\nvar (\n    mu sync.Mutex\n    balance int\n)\n\nfunc Deposit(amount int) {\n    mu.Lock()                   // 上鎖\n    balance = balance + amount  // 確保一次只有一個 goroutine 能改變餘額\n    mu.Unlock()                 // 釋放鎖\n}\n\nfunc Balance() int {\n    mu.Lock()\n    b := balance\n    mu.Unlock()\n    return b\n}\n```\n\n#### `WaitGroup`（等待群組）\n若今天要等到所有 goroutine 都處理完畢再進行下一個動作，除了 channel 之外，`sync` 套件也提供了 WaitGroup 的方式來達到這樣的效果（以 UML 來說，就是「等待分支節點結合 Join」）。\n\n詳細的 WaitGroup 使用方式就不贅述。\n\n#### `Context`（背景）\n叫做背景可能不太精確，context 是在剛開始用 `gin` 寫 http server 的時候就很常見的一個東西，但實際上還是不太了解它的意思。經過粗淺的研究後，才知道 context 的主要用途，是在背景管理所有不定數量的 goroutine。\n\n對於目前的我來說，理解 context 還太早，等之後對 goroutine 的使用更熟悉了，再回頭來重新認識 context，會是比較有效率的學習方式。\n\n\n---\n## 小結\n經過本文的整理，對 Go 有了基本淺層的認識，也大致上知道 Go 的優勢以及風格是什麼，這樣應該會對理解主管的專案程式碼有些許的幫助（吧）。愈學愈覺得，Go 是個很棒的語言，主要是他的規範很嚴格，但又相當好懂，對於整理與維護來說非常友善！雖然目前的自己都在寫義大利麵 code，但心中也是有著寫 clean code 的嚮往啊！\n\n總而言之，大家一起學 Go 吧！\n\n\n---\n參考資料：\n* Alan A.A. Donovan - 精通 Go 程式設計\n* [PJCHENder - [Golang] Struct](https://pjchender.dev/golang/structs/)\n* [iT邦幫忙 - Golang 入門到進階實戰：Day 18 常用基本庫介紹](https://ithelp.ithome.com.tw/articles/10223934/)\n* [掘金 - Go指南10-谈谈对Golang IO读写的困惑](https://juejin.cn/post/6864886461746855949)\n* [小惡魔 - AppleBOY - 在 Go 語言內管理 Concurrency 的三種方式](https://blog.wu-boy.com/2020/08/three-ways-to-manage-concurrency-in-go/)\n* [iT邦幫忙 - Go劍復國-30天導入Golang：Golang Concurrency Pattern](https://ithelp.ithome.com.tw/articles/10208936)","slug":"golang-basic","published":1,"updated":"2022-03-12T12:58:19.708Z","_id":"cl0nusskz000fz6us2olq3k7x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>為了看懂後端主管寫的專案原始碼，趁著最近專案開發中間空檔，趕快來學習一下 Golang！基於自學習慣，我會先概覽這個語言的基礎，之後再針對遇到的主題進一步研究。</p>\n<span id=\"more\"></span>\n\n<p>本次整理出三個部分：</p>\n<ul>\n<li><a href=\"##Go%E7%9A%84%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\">Go 的資料型別</a></li>\n<li><a href=\"##Go%E7%9A%84%E5%A5%97%E4%BB%B6\">Go 的套件</a></li>\n<li><a href=\"##Go%E7%9A%84%E6%92%B0%E5%AF%AB%E9%A2%A8%E6%A0%BC\">Go 的撰寫風格</a></li>\n</ul>\n<hr>\n<h2 id=\"Go的資料型別\"><a href=\"#Go的資料型別\" class=\"headerlink\" title=\"Go的資料型別\"></a>Go的資料型別</h2><h4 id=\"數字（Number）\"><a href=\"#數字（Number）\" class=\"headerlink\" title=\"數字（Number）\"></a>數字（Number）</h4><ul>\n<li>無號整數：<code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code></li>\n<li>有號整數：<code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code></li>\n<li>浮點數：<code>float32</code>、<code>float64</code></li>\n<li>複數：<code>complex64</code>、<code>complex128</code><h4 id=\"字串（String）\"><a href=\"#字串（String）\" class=\"headerlink\" title=\"字串（String）\"></a>字串（String）</h4></li>\n<li><code>string</code>：UTF-8 編碼的字串</li>\n<li><code>byte</code>：不以編碼處理的字串</li>\n<li><code>rune</code>：型別為<code>int32</code> 的值<h4 id=\"布林（Boolean）\"><a href=\"#布林（Boolean）\" class=\"headerlink\" title=\"布林（Boolean）\"></a>布林（Boolean）</h4></li>\n<li><code>true</code>：真</li>\n<li><code>false</code>：偽<h4 id=\"陣列（Array）\"><a href=\"#陣列（Array）\" class=\"headerlink\" title=\"陣列（Array）\"></a>陣列（Array）</h4></li>\n<li>以數字為索引的線性容器，長度固定。<h4 id=\"結構（Struct）\"><a href=\"#結構（Struct）\" class=\"headerlink\" title=\"結構（Struct）\"></a>結構（Struct）</h4></li>\n<li>宣告一個資料結構（非實體），具有哪些參數以及型別。<h4 id=\"指標（Pointer）\"><a href=\"#指標（Pointer）\" class=\"headerlink\" title=\"指標（Pointer）\"></a>指標（Pointer）</h4></li>\n<li>指向儲存其他值的「位址」，透過指標可間接存取值。<h4 id=\"切片（Slice）\"><a href=\"#切片（Slice）\" class=\"headerlink\" title=\"切片（Slice）\"></a>切片（Slice）</h4></li>\n<li>以數字為索引的線性容器，長度可以伸縮。<h4 id=\"映射（Map）\"><a href=\"#映射（Map）\" class=\"headerlink\" title=\"映射（Map）\"></a>映射（Map）</h4></li>\n<li>以 key-value pair 的非線性資料結構，以雜湊方式儲存在記憶體中。<h4 id=\"函式（Function）\"><a href=\"#函式（Function）\" class=\"headerlink\" title=\"函式（Function）\"></a>函式（Function）</h4></li>\n<li>提供具有行為的函式，作為型別來定義變數。<h4 id=\"通道（Channel）\"><a href=\"#通道（Channel）\" class=\"headerlink\" title=\"通道（Channel）\"></a>通道（Channel）</h4></li>\n<li>在 Goroutine 之間傳遞資料。<h4 id=\"介面（Interface）\"><a href=\"#介面（Interface）\" class=\"headerlink\" title=\"介面（Interface）\"></a>介面（Interface）</h4></li>\n<li>抽象型別，不顯露內部的值，而只提供可操作的行為。</li>\n</ul>\n<hr>\n<h2 id=\"Go的套件\"><a href=\"#Go的套件\" class=\"headerlink\" title=\"Go的套件\"></a>Go的套件</h2><p>Go 以 package 來組織程式，因此每個原始碼檔案的開頭都會是 <code>package &lt;fileName&gt;</code>，以作為一個 package 來讓其他檔案調用。</p>\n<p>下面整理 Go 內建的一些常用套件。</p>\n<h3 id=\"fmt：格式化輸出以及掃描輸入\"><a href=\"#fmt：格式化輸出以及掃描輸入\" class=\"headerlink\" title=\"fmt：格式化輸出以及掃描輸入\"></a><code>fmt</code>：格式化輸出以及掃描輸入</h3><h4 id=\"轉換格式：fmt-Print-、fmt-Printf-、fmt-Println\"><a href=\"#轉換格式：fmt-Print-、fmt-Printf-、fmt-Println\" class=\"headerlink\" title=\"轉換格式：fmt.Print()、fmt.Printf()、fmt.Println()\"></a>轉換格式：<code>fmt.Print()</code>、<code>fmt.Printf()</code>、<code>fmt.Println()</code></h4><p>轉換格式後輸出值，如下例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appleColor := <span class=\"string\">&quot;red&quot;</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %v\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: red</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %q\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: &quot;red&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %T\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: string</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>常用轉換格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%v</td>\n<td>值自然格式</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字串</td>\n</tr>\n<tr>\n<td>%q</td>\n<td>加引號的字串</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>值型別</td>\n</tr>\n</tbody></table>\n<h4 id=\"組合字串：fmt-Sprint-、fmt-Sprintln-、fmt-Sprintf\"><a href=\"#組合字串：fmt-Sprint-、fmt-Sprintln-、fmt-Sprintf\" class=\"headerlink\" title=\"組合字串：fmt.Sprint()、fmt.Sprintln()、fmt.Sprintf()\"></a>組合字串：<code>fmt.Sprint()</code>、<code>fmt.Sprintln()</code>、<code>fmt.Sprintf()</code></h4><p>不會印出東西，而是拿來組合字串用的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 := <span class=\"string\">&quot;I&quot;</span></span><br><span class=\"line\">v2 := <span class=\"string\">&quot;am&quot;</span></span><br><span class=\"line\">v3 := <span class=\"string\">&quot;Iron Man&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">combineString := fmt.Sprintln(v1, v2, v3)</span><br><span class=\"line\">fmt.Println(combineString)</span><br><span class=\"line\"><span class=\"comment\">// 印出 I am Iron Man</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"os、io、bufio：存取作業系統\"><a href=\"#os、io、bufio：存取作業系統\" class=\"headerlink\" title=\"os、io、bufio：存取作業系統\"></a><code>os</code>、<code>io</code>、<code>bufio</code>：存取作業系統</h3><h4 id=\"存取作業系統：os-Open-、os-Create-、os-Remove-、os-Mkdir\"><a href=\"#存取作業系統：os-Open-、os-Create-、os-Remove-、os-Mkdir\" class=\"headerlink\" title=\"存取作業系統：os.Open()、os.Create()、os.Remove()、os.Mkdir()\"></a>存取作業系統：<code>os.Open()</code>、<code>os.Create()</code>、<code>os.Remove()</code>、<code>os.Mkdir()</code></h4><p>建立、編輯或移除作業系統中的資料夾、檔案。</p>\n<h4 id=\"存取命令列參數：os-Args-1\"><a href=\"#存取命令列參數：os-Args-1\" class=\"headerlink\" title=\"存取命令列參數：os.Args[1:]\"></a>存取命令列參數：<code>os.Args[1:]</code></h4><p>取得開啟檔案時命令列的參數，<code>[1:]</code> 為刪除掉第一個參數（程式執行的路徑）。</p>\n<h4 id=\"存取作業系統：io-ioutil-ReadFile-、io-ioutil-ReadDir\"><a href=\"#存取作業系統：io-ioutil-ReadFile-、io-ioutil-ReadDir\" class=\"headerlink\" title=\"存取作業系統：io/ioutil.ReadFile()、io/ioutil.ReadDir()\"></a>存取作業系統：<code>io/ioutil.ReadFile()</code>、<code>io/ioutil.ReadDir()</code></h4><p>建立、編輯或移除作業系統中的資料夾、檔案。</p>\n<h4 id=\"存取作業系統：bufio-NewWriter\"><a href=\"#存取作業系統：bufio-NewWriter\" class=\"headerlink\" title=\"存取作業系統：bufio.NewWriter()\"></a>存取作業系統：<code>bufio.NewWriter()</code></h4><p>實作了 <code>io</code> 的一些介面，能更方便地建立、編輯或移除作業系統中的資料夾、檔案。<br>。</p>\n<blockquote>\n<p>如果你跟我一樣，覺得這些 Package 都很像，產生了「這麼多種，到底什麼時候要用哪個？差別在哪裡？」的疑惑，可以看看這篇：<a class=\"link\"   href=\"https://juejin.cn/post/6864886461746855949\" >掘金 - Go指南10-谈谈对Golang IO读写的困惑<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<h3 id=\"flag：從命令列取得參數在程式碼中使用\"><a href=\"#flag：從命令列取得參數在程式碼中使用\" class=\"headerlink\" title=\"flag：從命令列取得參數在程式碼中使用\"></a><code>flag</code>：從命令列取得參數在程式碼中使用</h3><h4 id=\"設置外來變數：flag-String-、flag-Bool-、flag-Int-、flag-Var\"><a href=\"#設置外來變數：flag-String-、flag-Bool-、flag-Int-、flag-Var\" class=\"headerlink\" title=\"設置外來變數：flag.String()、flag.Bool()、flag.Int()、flag.Var()\"></a>設置外來變數：<code>flag.String()</code>、<code>flag.Bool()</code>、<code>flag.Int()</code>、<code>flag.Var()</code></h4><p>使用這個套件，可以讓使用者在啟動專案時代入參數，進而達到一份專案中包含多功能的效果。</p>\n<hr>\n<h2 id=\"Go的撰寫風格\"><a href=\"#Go的撰寫風格\" class=\"headerlink\" title=\"Go的撰寫風格\"></a>Go的撰寫風格</h2><h3 id=\"使用指標（Pointer）來做變數處理\"><a href=\"#使用指標（Pointer）來做變數處理\" class=\"headerlink\" title=\"使用指標（Pointer）來做變數處理\"></a>使用指標（Pointer）來做變數處理</h3><p>在宣告一個變數時，會在記憶體中給予其一個位址來存放它的相關設定（型別、值），而 Go 提供一種方法來取用該變數的位址或者指向它做變更，這樣就不用拷貝該變數，多消耗一個記憶體位址。當需要跨函式對同一變數做存取時，這個方法相當有幫助。</p>\n<ul>\n<li><code>*</code>：Point to，指向某個記憶體位址的值</li>\n<li><code>&amp;</code>：Address of，某個變數的記憶體位址</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">7</span>   <span class=\"comment\">// 宣告一個 int 變數</span></span><br><span class=\"line\">p := &amp;a  <span class=\"comment\">// 宣告一個變數 p，指向 a 的位址</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of a:%v\\n&quot;</span>, a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of a:7</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Address of a:%v\\n&quot;</span>, &amp;a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Address of a:0xc000118000</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of p:%v\\n&quot;</span>, p)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of p:0xc000118000</span></span><br><span class=\"line\"></span><br><span class=\"line\">*p = <span class=\"number\">8</span>   <span class=\"comment\">// 修改 *p 的值，影響到 a</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of a:%v\\n&quot;</span>, a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of a:8</span></span><br></pre></td></tr></table></figure>\n\n<p>從上述例子可以看出，<code>p</code> 這個變數儲存的是 <code>a</code> 的記憶體位址，而修改 <code>*p</code> 的值，等於修改到 <code>a</code> 的值。若將 <code>p</code>（a.k.a:<code>a</code> 的記憶體位址）作為變數在函式之間傳遞使用，再用指標指向 <code>*p</code>，就可以在各函式之間對同一個變數做處理，不用一直耗費記憶體來建立新的變數。</p>\n<h3 id=\"利用-defer（延遲觸發）來做例外處理\"><a href=\"#利用-defer（延遲觸發）來做例外處理\" class=\"headerlink\" title=\"利用 defer（延遲觸發）來做例外處理\"></a>利用 <code>defer</code>（延遲觸發）來做例外處理</h3><p>對於例外處理的這一塊，因為還沒有實際寫出一個 Go 專案，因此還不是很能領會實作方式。</p>\n<h4 id=\"defer（延遲處理）\"><a href=\"#defer（延遲處理）\" class=\"headerlink\" title=\"defer（延遲處理）\"></a><code>defer</code>（延遲處理）</h4><ul>\n<li>使用 <code>defer</code> 將工作延遲到想要的時間點執行。</li>\n<li>當程式結束時，多個 <code>defer</code> 處理將以反向順序執行，也就是 LIFO（Last In First Out）。<h4 id=\"panic（中斷）\"><a href=\"#panic（中斷）\" class=\"headerlink\" title=\"panic（中斷）\"></a><code>panic</code>（中斷）</h4></li>\n<li>當發生錯誤（也就是常見的 <code>err != nil</code>）時，透過 <code>panic</code> 來將函式中斷。<h4 id=\"recover（恢復）\"><a href=\"#recover（恢復）\" class=\"headerlink\" title=\"recover（恢復）\"></a><code>recover</code>（恢復）</h4></li>\n<li>在發生了 <code>panic</code> 而導致流程中斷後，如果想要讓程式繼續做別的處理，就可以使用 <code>recover</code>。但 <code>recover</code> 必須在 <code>defer</code> 中執行，否則回傳值會是 <code>nil</code>。</li>\n</ul>\n<hr>\n<h3 id=\"利用-goroutine-來做併發處理\"><a href=\"#利用-goroutine-來做併發處理\" class=\"headerlink\" title=\"利用 goroutine 來做併發處理\"></a>利用 <code>goroutine</code> 來做併發處理</h3><p>Go 特色之一就是對於 concurrency 的處理，而 Go 提供的作法就是使用 goroutine。</p>\n<h4 id=\"Goroutine（執行緒）\"><a href=\"#Goroutine（執行緒）\" class=\"headerlink\" title=\"Goroutine（執行緒）\"></a><code>Goroutine</code>（執行緒）</h4><p>只要在函式前加上 <code>go</code>，就會開啟一個新的 goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f()    <span class=\"comment\">// 呼叫執行 f()</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f() <span class=\"comment\">// 建立一個新的 goroutine 來呼叫執行 f()</span></span><br></pre></td></tr></table></figure>\n<p>Goroutine 能讓各個函式同時進行，而不用相互等待，我以前端的 <code>Ajax</code>，或 Python 的 <code>Thread</code> 來理解，就比較能想像了。</p>\n<h4 id=\"Channel（通道）-Select（選擇）\"><a href=\"#Channel（通道）-Select（選擇）\" class=\"headerlink\" title=\"Channel（通道）+ Select（選擇）\"></a><code>Channel</code>（通道）+ <code>Select</code>（選擇）</h4><p>Channel 是運行中的 goroutine 之間的連線管道，可以讓其中一個 goroutine 發送訊息給其他 goroutine。要建構 channel，可以這樣做：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)     <span class=\"comment\">// 建構一個型別為 chan int 的 channel</span></span><br><span class=\"line\">ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>) <span class=\"comment\">// 建構一個型別為 chan string 的 channel</span></span><br><span class=\"line\">ch3 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">bool</span>)   <span class=\"comment\">// 建構一個型別為 chan bool 的 channel</span></span><br></pre></td></tr></table></figure>\n<p>Channel 具有 <strong>發送</strong> 與 <strong>接收</strong> 兩種基本操作，通稱為 <strong>通訊</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- x   <span class=\"comment\">// 發送 x 給 channel</span></span><br><span class=\"line\">y  &lt;- ch  <span class=\"comment\">// y 接收來自 ch 的值</span></span><br><span class=\"line\">&lt;- ch     <span class=\"comment\">// 拋棄結果</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 關閉 channel</span></span><br></pre></td></tr></table></figure>\n<p>可以透過 <strong>關閉</strong> 操作來讓 channel 不再接收值，若再發送值到此 channel，會引發 panic。在已經關閉的 channel 上取值，會取出直到沒有值為止，之後的接收操作會得到 nil。</p>\n<p>對 channel 的進一步討論，我會另外再整理一篇心得。</p>\n<h4 id=\"Mutex（互斥鎖）\"><a href=\"#Mutex（互斥鎖）\" class=\"headerlink\" title=\"Mutex（互斥鎖）\"></a><code>Mutex</code>（互斥鎖）</h4><p>當有多個 gouroutine 在運行中時，有時會出現互相影響的狀況，此時需要設定讓其中一個 goroutine 先執行完畢，才能開放給其他 goroutine 使用，而這樣的方式就是 <code>Mutex.Lock()</code>。《精通 Go 程式設計》中舉了以下例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    mu sync.Mutex</span><br><span class=\"line\">    balance <span class=\"type\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()                   <span class=\"comment\">// 上鎖</span></span><br><span class=\"line\">    balance = balance + amount  <span class=\"comment\">// 確保一次只有一個 goroutine 能改變餘額</span></span><br><span class=\"line\">    mu.Unlock()                 <span class=\"comment\">// 釋放鎖</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    b := balance</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WaitGroup（等待群組）\"><a href=\"#WaitGroup（等待群組）\" class=\"headerlink\" title=\"WaitGroup（等待群組）\"></a><code>WaitGroup</code>（等待群組）</h4><p>若今天要等到所有 goroutine 都處理完畢再進行下一個動作，除了 channel 之外，<code>sync</code> 套件也提供了 WaitGroup 的方式來達到這樣的效果（以 UML 來說，就是「等待分支節點結合 Join」）。</p>\n<p>詳細的 WaitGroup 使用方式就不贅述。</p>\n<h4 id=\"Context（背景）\"><a href=\"#Context（背景）\" class=\"headerlink\" title=\"Context（背景）\"></a><code>Context</code>（背景）</h4><p>叫做背景可能不太精確，context 是在剛開始用 <code>gin</code> 寫 http server 的時候就很常見的一個東西，但實際上還是不太了解它的意思。經過粗淺的研究後，才知道 context 的主要用途，是在背景管理所有不定數量的 goroutine。</p>\n<p>對於目前的我來說，理解 context 還太早，等之後對 goroutine 的使用更熟悉了，再回頭來重新認識 context，會是比較有效率的學習方式。</p>\n<hr>\n<h2 id=\"小結\"><a href=\"#小結\" class=\"headerlink\" title=\"小結\"></a>小結</h2><p>經過本文的整理，對 Go 有了基本淺層的認識，也大致上知道 Go 的優勢以及風格是什麼，這樣應該會對理解主管的專案程式碼有些許的幫助（吧）。愈學愈覺得，Go 是個很棒的語言，主要是他的規範很嚴格，但又相當好懂，對於整理與維護來說非常友善！雖然目前的自己都在寫義大利麵 code，但心中也是有著寫 clean code 的嚮往啊！</p>\n<p>總而言之，大家一起學 Go 吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li>Alan A.A. Donovan - 精通 Go 程式設計</li>\n<li><a class=\"link\"   href=\"https://pjchender.dev/golang/structs/\" >PJCHENder - [Golang] Struct<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10223934/\" >iT邦幫忙 - Golang 入門到進階實戰：Day 18 常用基本庫介紹<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.cn/post/6864886461746855949\" >掘金 - Go指南10-谈谈对Golang IO读写的困惑<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.wu-boy.com/2020/08/three-ways-to-manage-concurrency-in-go/\" >小惡魔 - AppleBOY - 在 Go 語言內管理 Concurrency 的三種方式<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10208936\" >iT邦幫忙 - Go劍復國-30天導入Golang：Golang Concurrency Pattern<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>為了看懂後端主管寫的專案原始碼，趁著最近專案開發中間空檔，趕快來學習一下 Golang！基於自學習慣，我會先概覽這個語言的基礎，之後再針對遇到的主題進一步研究。</p>","more":"<p>本次整理出三個部分：</p>\n<ul>\n<li><a href=\"##Go%E7%9A%84%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5\">Go 的資料型別</a></li>\n<li><a href=\"##Go%E7%9A%84%E5%A5%97%E4%BB%B6\">Go 的套件</a></li>\n<li><a href=\"##Go%E7%9A%84%E6%92%B0%E5%AF%AB%E9%A2%A8%E6%A0%BC\">Go 的撰寫風格</a></li>\n</ul>\n<hr>\n<h2 id=\"Go的資料型別\"><a href=\"#Go的資料型別\" class=\"headerlink\" title=\"Go的資料型別\"></a>Go的資料型別</h2><h4 id=\"數字（Number）\"><a href=\"#數字（Number）\" class=\"headerlink\" title=\"數字（Number）\"></a>數字（Number）</h4><ul>\n<li>無號整數：<code>uint</code>、<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code></li>\n<li>有號整數：<code>int</code>、<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code></li>\n<li>浮點數：<code>float32</code>、<code>float64</code></li>\n<li>複數：<code>complex64</code>、<code>complex128</code><h4 id=\"字串（String）\"><a href=\"#字串（String）\" class=\"headerlink\" title=\"字串（String）\"></a>字串（String）</h4></li>\n<li><code>string</code>：UTF-8 編碼的字串</li>\n<li><code>byte</code>：不以編碼處理的字串</li>\n<li><code>rune</code>：型別為<code>int32</code> 的值<h4 id=\"布林（Boolean）\"><a href=\"#布林（Boolean）\" class=\"headerlink\" title=\"布林（Boolean）\"></a>布林（Boolean）</h4></li>\n<li><code>true</code>：真</li>\n<li><code>false</code>：偽<h4 id=\"陣列（Array）\"><a href=\"#陣列（Array）\" class=\"headerlink\" title=\"陣列（Array）\"></a>陣列（Array）</h4></li>\n<li>以數字為索引的線性容器，長度固定。<h4 id=\"結構（Struct）\"><a href=\"#結構（Struct）\" class=\"headerlink\" title=\"結構（Struct）\"></a>結構（Struct）</h4></li>\n<li>宣告一個資料結構（非實體），具有哪些參數以及型別。<h4 id=\"指標（Pointer）\"><a href=\"#指標（Pointer）\" class=\"headerlink\" title=\"指標（Pointer）\"></a>指標（Pointer）</h4></li>\n<li>指向儲存其他值的「位址」，透過指標可間接存取值。<h4 id=\"切片（Slice）\"><a href=\"#切片（Slice）\" class=\"headerlink\" title=\"切片（Slice）\"></a>切片（Slice）</h4></li>\n<li>以數字為索引的線性容器，長度可以伸縮。<h4 id=\"映射（Map）\"><a href=\"#映射（Map）\" class=\"headerlink\" title=\"映射（Map）\"></a>映射（Map）</h4></li>\n<li>以 key-value pair 的非線性資料結構，以雜湊方式儲存在記憶體中。<h4 id=\"函式（Function）\"><a href=\"#函式（Function）\" class=\"headerlink\" title=\"函式（Function）\"></a>函式（Function）</h4></li>\n<li>提供具有行為的函式，作為型別來定義變數。<h4 id=\"通道（Channel）\"><a href=\"#通道（Channel）\" class=\"headerlink\" title=\"通道（Channel）\"></a>通道（Channel）</h4></li>\n<li>在 Goroutine 之間傳遞資料。<h4 id=\"介面（Interface）\"><a href=\"#介面（Interface）\" class=\"headerlink\" title=\"介面（Interface）\"></a>介面（Interface）</h4></li>\n<li>抽象型別，不顯露內部的值，而只提供可操作的行為。</li>\n</ul>\n<hr>\n<h2 id=\"Go的套件\"><a href=\"#Go的套件\" class=\"headerlink\" title=\"Go的套件\"></a>Go的套件</h2><p>Go 以 package 來組織程式，因此每個原始碼檔案的開頭都會是 <code>package &lt;fileName&gt;</code>，以作為一個 package 來讓其他檔案調用。</p>\n<p>下面整理 Go 內建的一些常用套件。</p>\n<h3 id=\"fmt：格式化輸出以及掃描輸入\"><a href=\"#fmt：格式化輸出以及掃描輸入\" class=\"headerlink\" title=\"fmt：格式化輸出以及掃描輸入\"></a><code>fmt</code>：格式化輸出以及掃描輸入</h3><h4 id=\"轉換格式：fmt-Print-、fmt-Printf-、fmt-Println\"><a href=\"#轉換格式：fmt-Print-、fmt-Printf-、fmt-Println\" class=\"headerlink\" title=\"轉換格式：fmt.Print()、fmt.Printf()、fmt.Println()\"></a>轉換格式：<code>fmt.Print()</code>、<code>fmt.Printf()</code>、<code>fmt.Println()</code></h4><p>轉換格式後輸出值，如下例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">appleColor := <span class=\"string\">&quot;red&quot;</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %v\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: red</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %q\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: &quot;red&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Color of apple: %T\\n&quot;</span>, appleColor)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Color of apple: string</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>常用轉換格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%v</td>\n<td>值自然格式</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字串</td>\n</tr>\n<tr>\n<td>%q</td>\n<td>加引號的字串</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>值型別</td>\n</tr>\n</tbody></table>\n<h4 id=\"組合字串：fmt-Sprint-、fmt-Sprintln-、fmt-Sprintf\"><a href=\"#組合字串：fmt-Sprint-、fmt-Sprintln-、fmt-Sprintf\" class=\"headerlink\" title=\"組合字串：fmt.Sprint()、fmt.Sprintln()、fmt.Sprintf()\"></a>組合字串：<code>fmt.Sprint()</code>、<code>fmt.Sprintln()</code>、<code>fmt.Sprintf()</code></h4><p>不會印出東西，而是拿來組合字串用的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 := <span class=\"string\">&quot;I&quot;</span></span><br><span class=\"line\">v2 := <span class=\"string\">&quot;am&quot;</span></span><br><span class=\"line\">v3 := <span class=\"string\">&quot;Iron Man&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">combineString := fmt.Sprintln(v1, v2, v3)</span><br><span class=\"line\">fmt.Println(combineString)</span><br><span class=\"line\"><span class=\"comment\">// 印出 I am Iron Man</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"os、io、bufio：存取作業系統\"><a href=\"#os、io、bufio：存取作業系統\" class=\"headerlink\" title=\"os、io、bufio：存取作業系統\"></a><code>os</code>、<code>io</code>、<code>bufio</code>：存取作業系統</h3><h4 id=\"存取作業系統：os-Open-、os-Create-、os-Remove-、os-Mkdir\"><a href=\"#存取作業系統：os-Open-、os-Create-、os-Remove-、os-Mkdir\" class=\"headerlink\" title=\"存取作業系統：os.Open()、os.Create()、os.Remove()、os.Mkdir()\"></a>存取作業系統：<code>os.Open()</code>、<code>os.Create()</code>、<code>os.Remove()</code>、<code>os.Mkdir()</code></h4><p>建立、編輯或移除作業系統中的資料夾、檔案。</p>\n<h4 id=\"存取命令列參數：os-Args-1\"><a href=\"#存取命令列參數：os-Args-1\" class=\"headerlink\" title=\"存取命令列參數：os.Args[1:]\"></a>存取命令列參數：<code>os.Args[1:]</code></h4><p>取得開啟檔案時命令列的參數，<code>[1:]</code> 為刪除掉第一個參數（程式執行的路徑）。</p>\n<h4 id=\"存取作業系統：io-ioutil-ReadFile-、io-ioutil-ReadDir\"><a href=\"#存取作業系統：io-ioutil-ReadFile-、io-ioutil-ReadDir\" class=\"headerlink\" title=\"存取作業系統：io/ioutil.ReadFile()、io/ioutil.ReadDir()\"></a>存取作業系統：<code>io/ioutil.ReadFile()</code>、<code>io/ioutil.ReadDir()</code></h4><p>建立、編輯或移除作業系統中的資料夾、檔案。</p>\n<h4 id=\"存取作業系統：bufio-NewWriter\"><a href=\"#存取作業系統：bufio-NewWriter\" class=\"headerlink\" title=\"存取作業系統：bufio.NewWriter()\"></a>存取作業系統：<code>bufio.NewWriter()</code></h4><p>實作了 <code>io</code> 的一些介面，能更方便地建立、編輯或移除作業系統中的資料夾、檔案。<br>。</p>\n<blockquote>\n<p>如果你跟我一樣，覺得這些 Package 都很像，產生了「這麼多種，到底什麼時候要用哪個？差別在哪裡？」的疑惑，可以看看這篇：<a class=\"link\"   href=\"https://juejin.cn/post/6864886461746855949\" >掘金 - Go指南10-谈谈对Golang IO读写的困惑<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<h3 id=\"flag：從命令列取得參數在程式碼中使用\"><a href=\"#flag：從命令列取得參數在程式碼中使用\" class=\"headerlink\" title=\"flag：從命令列取得參數在程式碼中使用\"></a><code>flag</code>：從命令列取得參數在程式碼中使用</h3><h4 id=\"設置外來變數：flag-String-、flag-Bool-、flag-Int-、flag-Var\"><a href=\"#設置外來變數：flag-String-、flag-Bool-、flag-Int-、flag-Var\" class=\"headerlink\" title=\"設置外來變數：flag.String()、flag.Bool()、flag.Int()、flag.Var()\"></a>設置外來變數：<code>flag.String()</code>、<code>flag.Bool()</code>、<code>flag.Int()</code>、<code>flag.Var()</code></h4><p>使用這個套件，可以讓使用者在啟動專案時代入參數，進而達到一份專案中包含多功能的效果。</p>\n<hr>\n<h2 id=\"Go的撰寫風格\"><a href=\"#Go的撰寫風格\" class=\"headerlink\" title=\"Go的撰寫風格\"></a>Go的撰寫風格</h2><h3 id=\"使用指標（Pointer）來做變數處理\"><a href=\"#使用指標（Pointer）來做變數處理\" class=\"headerlink\" title=\"使用指標（Pointer）來做變數處理\"></a>使用指標（Pointer）來做變數處理</h3><p>在宣告一個變數時，會在記憶體中給予其一個位址來存放它的相關設定（型別、值），而 Go 提供一種方法來取用該變數的位址或者指向它做變更，這樣就不用拷貝該變數，多消耗一個記憶體位址。當需要跨函式對同一變數做存取時，這個方法相當有幫助。</p>\n<ul>\n<li><code>*</code>：Point to，指向某個記憶體位址的值</li>\n<li><code>&amp;</code>：Address of，某個變數的記憶體位址</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"number\">7</span>   <span class=\"comment\">// 宣告一個 int 變數</span></span><br><span class=\"line\">p := &amp;a  <span class=\"comment\">// 宣告一個變數 p，指向 a 的位址</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of a:%v\\n&quot;</span>, a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of a:7</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Address of a:%v\\n&quot;</span>, &amp;a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Address of a:0xc000118000</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of p:%v\\n&quot;</span>, p)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of p:0xc000118000</span></span><br><span class=\"line\"></span><br><span class=\"line\">*p = <span class=\"number\">8</span>   <span class=\"comment\">// 修改 *p 的值，影響到 a</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;Value of a:%v\\n&quot;</span>, a)</span><br><span class=\"line\"><span class=\"comment\">// 印出 Value of a:8</span></span><br></pre></td></tr></table></figure>\n\n<p>從上述例子可以看出，<code>p</code> 這個變數儲存的是 <code>a</code> 的記憶體位址，而修改 <code>*p</code> 的值，等於修改到 <code>a</code> 的值。若將 <code>p</code>（a.k.a:<code>a</code> 的記憶體位址）作為變數在函式之間傳遞使用，再用指標指向 <code>*p</code>，就可以在各函式之間對同一個變數做處理，不用一直耗費記憶體來建立新的變數。</p>\n<h3 id=\"利用-defer（延遲觸發）來做例外處理\"><a href=\"#利用-defer（延遲觸發）來做例外處理\" class=\"headerlink\" title=\"利用 defer（延遲觸發）來做例外處理\"></a>利用 <code>defer</code>（延遲觸發）來做例外處理</h3><p>對於例外處理的這一塊，因為還沒有實際寫出一個 Go 專案，因此還不是很能領會實作方式。</p>\n<h4 id=\"defer（延遲處理）\"><a href=\"#defer（延遲處理）\" class=\"headerlink\" title=\"defer（延遲處理）\"></a><code>defer</code>（延遲處理）</h4><ul>\n<li>使用 <code>defer</code> 將工作延遲到想要的時間點執行。</li>\n<li>當程式結束時，多個 <code>defer</code> 處理將以反向順序執行，也就是 LIFO（Last In First Out）。<h4 id=\"panic（中斷）\"><a href=\"#panic（中斷）\" class=\"headerlink\" title=\"panic（中斷）\"></a><code>panic</code>（中斷）</h4></li>\n<li>當發生錯誤（也就是常見的 <code>err != nil</code>）時，透過 <code>panic</code> 來將函式中斷。<h4 id=\"recover（恢復）\"><a href=\"#recover（恢復）\" class=\"headerlink\" title=\"recover（恢復）\"></a><code>recover</code>（恢復）</h4></li>\n<li>在發生了 <code>panic</code> 而導致流程中斷後，如果想要讓程式繼續做別的處理，就可以使用 <code>recover</code>。但 <code>recover</code> 必須在 <code>defer</code> 中執行，否則回傳值會是 <code>nil</code>。</li>\n</ul>\n<hr>\n<h3 id=\"利用-goroutine-來做併發處理\"><a href=\"#利用-goroutine-來做併發處理\" class=\"headerlink\" title=\"利用 goroutine 來做併發處理\"></a>利用 <code>goroutine</code> 來做併發處理</h3><p>Go 特色之一就是對於 concurrency 的處理，而 Go 提供的作法就是使用 goroutine。</p>\n<h4 id=\"Goroutine（執行緒）\"><a href=\"#Goroutine（執行緒）\" class=\"headerlink\" title=\"Goroutine（執行緒）\"></a><code>Goroutine</code>（執行緒）</h4><p>只要在函式前加上 <code>go</code>，就會開啟一個新的 goroutine。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f()    <span class=\"comment\">// 呼叫執行 f()</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> f() <span class=\"comment\">// 建立一個新的 goroutine 來呼叫執行 f()</span></span><br></pre></td></tr></table></figure>\n<p>Goroutine 能讓各個函式同時進行，而不用相互等待，我以前端的 <code>Ajax</code>，或 Python 的 <code>Thread</code> 來理解，就比較能想像了。</p>\n<h4 id=\"Channel（通道）-Select（選擇）\"><a href=\"#Channel（通道）-Select（選擇）\" class=\"headerlink\" title=\"Channel（通道）+ Select（選擇）\"></a><code>Channel</code>（通道）+ <code>Select</code>（選擇）</h4><p>Channel 是運行中的 goroutine 之間的連線管道，可以讓其中一個 goroutine 發送訊息給其他 goroutine。要建構 channel，可以這樣做：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)     <span class=\"comment\">// 建構一個型別為 chan int 的 channel</span></span><br><span class=\"line\">ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">string</span>) <span class=\"comment\">// 建構一個型別為 chan string 的 channel</span></span><br><span class=\"line\">ch3 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">bool</span>)   <span class=\"comment\">// 建構一個型別為 chan bool 的 channel</span></span><br></pre></td></tr></table></figure>\n<p>Channel 具有 <strong>發送</strong> 與 <strong>接收</strong> 兩種基本操作，通稱為 <strong>通訊</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- x   <span class=\"comment\">// 發送 x 給 channel</span></span><br><span class=\"line\">y  &lt;- ch  <span class=\"comment\">// y 接收來自 ch 的值</span></span><br><span class=\"line\">&lt;- ch     <span class=\"comment\">// 拋棄結果</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(ch) <span class=\"comment\">// 關閉 channel</span></span><br></pre></td></tr></table></figure>\n<p>可以透過 <strong>關閉</strong> 操作來讓 channel 不再接收值，若再發送值到此 channel，會引發 panic。在已經關閉的 channel 上取值，會取出直到沒有值為止，之後的接收操作會得到 nil。</p>\n<p>對 channel 的進一步討論，我會另外再整理一篇心得。</p>\n<h4 id=\"Mutex（互斥鎖）\"><a href=\"#Mutex（互斥鎖）\" class=\"headerlink\" title=\"Mutex（互斥鎖）\"></a><code>Mutex</code>（互斥鎖）</h4><p>當有多個 gouroutine 在運行中時，有時會出現互相影響的狀況，此時需要設定讓其中一個 goroutine 先執行完畢，才能開放給其他 goroutine 使用，而這樣的方式就是 <code>Mutex.Lock()</code>。《精通 Go 程式設計》中舉了以下例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    mu sync.Mutex</span><br><span class=\"line\">    balance <span class=\"type\">int</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Deposit</span><span class=\"params\">(amount <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()                   <span class=\"comment\">// 上鎖</span></span><br><span class=\"line\">    balance = balance + amount  <span class=\"comment\">// 確保一次只有一個 goroutine 能改變餘額</span></span><br><span class=\"line\">    mu.Unlock()                 <span class=\"comment\">// 釋放鎖</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Balance</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    b := balance</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WaitGroup（等待群組）\"><a href=\"#WaitGroup（等待群組）\" class=\"headerlink\" title=\"WaitGroup（等待群組）\"></a><code>WaitGroup</code>（等待群組）</h4><p>若今天要等到所有 goroutine 都處理完畢再進行下一個動作，除了 channel 之外，<code>sync</code> 套件也提供了 WaitGroup 的方式來達到這樣的效果（以 UML 來說，就是「等待分支節點結合 Join」）。</p>\n<p>詳細的 WaitGroup 使用方式就不贅述。</p>\n<h4 id=\"Context（背景）\"><a href=\"#Context（背景）\" class=\"headerlink\" title=\"Context（背景）\"></a><code>Context</code>（背景）</h4><p>叫做背景可能不太精確，context 是在剛開始用 <code>gin</code> 寫 http server 的時候就很常見的一個東西，但實際上還是不太了解它的意思。經過粗淺的研究後，才知道 context 的主要用途，是在背景管理所有不定數量的 goroutine。</p>\n<p>對於目前的我來說，理解 context 還太早，等之後對 goroutine 的使用更熟悉了，再回頭來重新認識 context，會是比較有效率的學習方式。</p>\n<hr>\n<h2 id=\"小結\"><a href=\"#小結\" class=\"headerlink\" title=\"小結\"></a>小結</h2><p>經過本文的整理，對 Go 有了基本淺層的認識，也大致上知道 Go 的優勢以及風格是什麼，這樣應該會對理解主管的專案程式碼有些許的幫助（吧）。愈學愈覺得，Go 是個很棒的語言，主要是他的規範很嚴格，但又相當好懂，對於整理與維護來說非常友善！雖然目前的自己都在寫義大利麵 code，但心中也是有著寫 clean code 的嚮往啊！</p>\n<p>總而言之，大家一起學 Go 吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li>Alan A.A. Donovan - 精通 Go 程式設計</li>\n<li><a class=\"link\"   href=\"https://pjchender.dev/golang/structs/\" >PJCHENder - [Golang] Struct<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10223934/\" >iT邦幫忙 - Golang 入門到進階實戰：Day 18 常用基本庫介紹<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.cn/post/6864886461746855949\" >掘金 - Go指南10-谈谈对Golang IO读写的困惑<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.wu-boy.com/2020/08/three-ways-to-manage-concurrency-in-go/\" >小惡魔 - AppleBOY - 在 Go 語言內管理 Concurrency 的三種方式<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/articles/10208936\" >iT邦幫忙 - Go劍復國-30天導入Golang：Golang Concurrency Pattern<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"HTML 學習筆記 - HTML vs HTML5","date":"2019-09-06T11:16:29.000Z","_content":"我剛開始接觸網頁前端的時候，因為有太多東西要學了，就一頭栽下去學，總之先熟悉再說。忘記從什麼時候開始，這個疑問就懸在心頭：\n<!--more-->\n**HTML 等於 HTML5 嗎？**\n\n一直到最近，搞懂了網頁前端的架構之後，才終於有點餘力來研究這個問題。這篇文章將專注在 `HTML` 與 `HTML5` 之間的比較。\n\n---\n\n*HTML 與 HTML5 的定義*\n---\n\n以下是 Google 到的 HTML 定義：\n>HTML（HyperText Markup Language），是一種用於建立網頁的標準標記語言。瀏覽器能夠讀取 HTML 標籤，並渲染出來。\n\n而 HTML5 則是：\n>HTML5 是 HTML 最新的修訂版本，由 W3C 於 2014 年 10 月完成標準制定。目標是取代 1999 年制定的 HTML 4.01 和 XHTML 1.0 標準，以期能在網際網路應用迅速發展的時候，使網路標準達到符合當代的網路需求。\n\n也就是說，HTML5 是 HTML 的修訂版，但現今提到 HTML5 的時候，大多是指符合當代技術潮流標準的 HTML / CSS / JavaScript 技術組合。\n\n---\n*HTML5 新增功能*\n---\n為了能更符合 HTML5 標準地 coding，最好主動去學習一些 HTML5 新增的技術功能。\n\n* `video / audio`\n* `canvas`\n* `SVG`\n* `header / section / article / nav / footer`\n* 提供更多樣化的 API\n\n---\n*題外話：XHTML 與 HTML*\n---\n\n這邊很快地提一件之前曾經困擾我的問題，就是 XHTML 跟 HTML 又有哪裡不同？\n\n根據 W3C 的說法，差異如下：\n* `XHTML 元素必須被正確地嶔套`\n* `XHTML 元素必須有關閉標籤`\n* `XHTML 標籤名必須使用小寫`\n* `XHTML 文件必須擁有根元素`\n\n總結來說：XHTML 可說是 HTML 的嚴謹版本。\n\n---\n*總結*\n---\n\n總結來說：HTML5 是 HTML 的修訂版，內容包含更多語意化的標籤，目的是為了擴增 HTML 的泛用性與管理便利性，協助開發者打造更豐富的網路應用程式。\n\n為了讓自己寫的 code 能跟上當代潮流，學習 HTML5 標準是必要的。\n\n可以到這裡查看你的瀏覽器對 HTML5 的相容性：http://html5test.com\n\n---\n#### 參考資料\n* [MDN：HTML 基礎](https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics)\n* [小春天工坊：認識HTML5 (一)緣起與差異](https://otaru.tw/uncategorized/%E8%AA%8D%E8%AD%98html5)\n* [W3C：XHTML 與 HTML 的不同](https://www.w3school.com.cn/xhtml/xhtml_html.asp)","source":"_posts/html-html5.md","raw":"---\ntitle: HTML 學習筆記 - HTML vs HTML5\ndate: 2019-09-06 19:16:29\ntags: html\n---\n我剛開始接觸網頁前端的時候，因為有太多東西要學了，就一頭栽下去學，總之先熟悉再說。忘記從什麼時候開始，這個疑問就懸在心頭：\n<!--more-->\n**HTML 等於 HTML5 嗎？**\n\n一直到最近，搞懂了網頁前端的架構之後，才終於有點餘力來研究這個問題。這篇文章將專注在 `HTML` 與 `HTML5` 之間的比較。\n\n---\n\n*HTML 與 HTML5 的定義*\n---\n\n以下是 Google 到的 HTML 定義：\n>HTML（HyperText Markup Language），是一種用於建立網頁的標準標記語言。瀏覽器能夠讀取 HTML 標籤，並渲染出來。\n\n而 HTML5 則是：\n>HTML5 是 HTML 最新的修訂版本，由 W3C 於 2014 年 10 月完成標準制定。目標是取代 1999 年制定的 HTML 4.01 和 XHTML 1.0 標準，以期能在網際網路應用迅速發展的時候，使網路標準達到符合當代的網路需求。\n\n也就是說，HTML5 是 HTML 的修訂版，但現今提到 HTML5 的時候，大多是指符合當代技術潮流標準的 HTML / CSS / JavaScript 技術組合。\n\n---\n*HTML5 新增功能*\n---\n為了能更符合 HTML5 標準地 coding，最好主動去學習一些 HTML5 新增的技術功能。\n\n* `video / audio`\n* `canvas`\n* `SVG`\n* `header / section / article / nav / footer`\n* 提供更多樣化的 API\n\n---\n*題外話：XHTML 與 HTML*\n---\n\n這邊很快地提一件之前曾經困擾我的問題，就是 XHTML 跟 HTML 又有哪裡不同？\n\n根據 W3C 的說法，差異如下：\n* `XHTML 元素必須被正確地嶔套`\n* `XHTML 元素必須有關閉標籤`\n* `XHTML 標籤名必須使用小寫`\n* `XHTML 文件必須擁有根元素`\n\n總結來說：XHTML 可說是 HTML 的嚴謹版本。\n\n---\n*總結*\n---\n\n總結來說：HTML5 是 HTML 的修訂版，內容包含更多語意化的標籤，目的是為了擴增 HTML 的泛用性與管理便利性，協助開發者打造更豐富的網路應用程式。\n\n為了讓自己寫的 code 能跟上當代潮流，學習 HTML5 標準是必要的。\n\n可以到這裡查看你的瀏覽器對 HTML5 的相容性：http://html5test.com\n\n---\n#### 參考資料\n* [MDN：HTML 基礎](https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics)\n* [小春天工坊：認識HTML5 (一)緣起與差異](https://otaru.tw/uncategorized/%E8%AA%8D%E8%AD%98html5)\n* [W3C：XHTML 與 HTML 的不同](https://www.w3school.com.cn/xhtml/xhtml_html.asp)","slug":"html-html5","published":1,"updated":"2022-03-12T12:58:19.847Z","_id":"cl0nusss7000lz6us39sx8rbf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我剛開始接觸網頁前端的時候，因為有太多東西要學了，就一頭栽下去學，總之先熟悉再說。忘記從什麼時候開始，這個疑問就懸在心頭：</p>\n<span id=\"more\"></span>\n<p><strong>HTML 等於 HTML5 嗎？</strong></p>\n<p>一直到最近，搞懂了網頁前端的架構之後，才終於有點餘力來研究這個問題。這篇文章將專注在 <code>HTML</code> 與 <code>HTML5</code> 之間的比較。</p>\n<hr>\n<h2 id=\"HTML-與-HTML5-的定義\"><a href=\"#HTML-與-HTML5-的定義\" class=\"headerlink\" title=\"HTML 與 HTML5 的定義\"></a><em>HTML 與 HTML5 的定義</em></h2><p>以下是 Google 到的 HTML 定義：</p>\n<blockquote>\n<p>HTML（HyperText Markup Language），是一種用於建立網頁的標準標記語言。瀏覽器能夠讀取 HTML 標籤，並渲染出來。</p>\n</blockquote>\n<p>而 HTML5 則是：</p>\n<blockquote>\n<p>HTML5 是 HTML 最新的修訂版本，由 W3C 於 2014 年 10 月完成標準制定。目標是取代 1999 年制定的 HTML 4.01 和 XHTML 1.0 標準，以期能在網際網路應用迅速發展的時候，使網路標準達到符合當代的網路需求。</p>\n</blockquote>\n<p>也就是說，HTML5 是 HTML 的修訂版，但現今提到 HTML5 的時候，大多是指符合當代技術潮流標準的 HTML &#x2F; CSS &#x2F; JavaScript 技術組合。</p>\n<hr>\n<h2 id=\"HTML5-新增功能\"><a href=\"#HTML5-新增功能\" class=\"headerlink\" title=\"HTML5 新增功能\"></a><em>HTML5 新增功能</em></h2><p>為了能更符合 HTML5 標準地 coding，最好主動去學習一些 HTML5 新增的技術功能。</p>\n<ul>\n<li><code>video / audio</code></li>\n<li><code>canvas</code></li>\n<li><code>SVG</code></li>\n<li><code>header / section / article / nav / footer</code></li>\n<li>提供更多樣化的 API</li>\n</ul>\n<hr>\n<h2 id=\"題外話：XHTML-與-HTML\"><a href=\"#題外話：XHTML-與-HTML\" class=\"headerlink\" title=\"題外話：XHTML 與 HTML\"></a><em>題外話：XHTML 與 HTML</em></h2><p>這邊很快地提一件之前曾經困擾我的問題，就是 XHTML 跟 HTML 又有哪裡不同？</p>\n<p>根據 W3C 的說法，差異如下：</p>\n<ul>\n<li><code>XHTML 元素必須被正確地嶔套</code></li>\n<li><code>XHTML 元素必須有關閉標籤</code></li>\n<li><code>XHTML 標籤名必須使用小寫</code></li>\n<li><code>XHTML 文件必須擁有根元素</code></li>\n</ul>\n<p>總結來說：XHTML 可說是 HTML 的嚴謹版本。</p>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a><em>總結</em></h2><p>總結來說：HTML5 是 HTML 的修訂版，內容包含更多語意化的標籤，目的是為了擴增 HTML 的泛用性與管理便利性，協助開發者打造更豐富的網路應用程式。</p>\n<p>為了讓自己寫的 code 能跟上當代潮流，學習 HTML5 標準是必要的。</p>\n<p>可以到這裡查看你的瀏覽器對 HTML5 的相容性：<a class=\"link\"   href=\"http://html5test.com/\" >http://html5test.com<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics\" >MDN：HTML 基礎<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://otaru.tw/uncategorized/%E8%AA%8D%E8%AD%98html5\" >小春天工坊：認識HTML5 (一)緣起與差異<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.w3school.com.cn/xhtml/xhtml_html.asp\" >W3C：XHTML 與 HTML 的不同<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>我剛開始接觸網頁前端的時候，因為有太多東西要學了，就一頭栽下去學，總之先熟悉再說。忘記從什麼時候開始，這個疑問就懸在心頭：</p>","more":"<p><strong>HTML 等於 HTML5 嗎？</strong></p>\n<p>一直到最近，搞懂了網頁前端的架構之後，才終於有點餘力來研究這個問題。這篇文章將專注在 <code>HTML</code> 與 <code>HTML5</code> 之間的比較。</p>\n<hr>\n<h2 id=\"HTML-與-HTML5-的定義\"><a href=\"#HTML-與-HTML5-的定義\" class=\"headerlink\" title=\"HTML 與 HTML5 的定義\"></a><em>HTML 與 HTML5 的定義</em></h2><p>以下是 Google 到的 HTML 定義：</p>\n<blockquote>\n<p>HTML（HyperText Markup Language），是一種用於建立網頁的標準標記語言。瀏覽器能夠讀取 HTML 標籤，並渲染出來。</p>\n</blockquote>\n<p>而 HTML5 則是：</p>\n<blockquote>\n<p>HTML5 是 HTML 最新的修訂版本，由 W3C 於 2014 年 10 月完成標準制定。目標是取代 1999 年制定的 HTML 4.01 和 XHTML 1.0 標準，以期能在網際網路應用迅速發展的時候，使網路標準達到符合當代的網路需求。</p>\n</blockquote>\n<p>也就是說，HTML5 是 HTML 的修訂版，但現今提到 HTML5 的時候，大多是指符合當代技術潮流標準的 HTML &#x2F; CSS &#x2F; JavaScript 技術組合。</p>\n<hr>\n<h2 id=\"HTML5-新增功能\"><a href=\"#HTML5-新增功能\" class=\"headerlink\" title=\"HTML5 新增功能\"></a><em>HTML5 新增功能</em></h2><p>為了能更符合 HTML5 標準地 coding，最好主動去學習一些 HTML5 新增的技術功能。</p>\n<ul>\n<li><code>video / audio</code></li>\n<li><code>canvas</code></li>\n<li><code>SVG</code></li>\n<li><code>header / section / article / nav / footer</code></li>\n<li>提供更多樣化的 API</li>\n</ul>\n<hr>\n<h2 id=\"題外話：XHTML-與-HTML\"><a href=\"#題外話：XHTML-與-HTML\" class=\"headerlink\" title=\"題外話：XHTML 與 HTML\"></a><em>題外話：XHTML 與 HTML</em></h2><p>這邊很快地提一件之前曾經困擾我的問題，就是 XHTML 跟 HTML 又有哪裡不同？</p>\n<p>根據 W3C 的說法，差異如下：</p>\n<ul>\n<li><code>XHTML 元素必須被正確地嶔套</code></li>\n<li><code>XHTML 元素必須有關閉標籤</code></li>\n<li><code>XHTML 標籤名必須使用小寫</code></li>\n<li><code>XHTML 文件必須擁有根元素</code></li>\n</ul>\n<p>總結來說：XHTML 可說是 HTML 的嚴謹版本。</p>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a><em>總結</em></h2><p>總結來說：HTML5 是 HTML 的修訂版，內容包含更多語意化的標籤，目的是為了擴增 HTML 的泛用性與管理便利性，協助開發者打造更豐富的網路應用程式。</p>\n<p>為了讓自己寫的 code 能跟上當代潮流，學習 HTML5 標準是必要的。</p>\n<p>可以到這裡查看你的瀏覽器對 HTML5 的相容性：<a class=\"link\"   href=\"http://html5test.com/\" >http://html5test.com<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Learn/Getting_started_with_the_web/HTML_basics\" >MDN：HTML 基礎<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://otaru.tw/uncategorized/%E8%AA%8D%E8%AD%98html5\" >小春天工坊：認識HTML5 (一)緣起與差異<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.w3school.com.cn/xhtml/xhtml_html.asp\" >W3C：XHTML 與 HTML 的不同<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - AJAX","date":"2019-10-04T06:47:53.000Z","_content":"\n為了深入學習 `JavaScript`，不能單單只是會使用 `Ajax` ，而應進一步探討 `Asyncronous JavaScript And XML`（不過大多數的 `XML` 都已被 `JSON` 取代）。\n<!--more-->\n\n---\n\n## 首先看懂 `Ajax` 是什麼\n\n`Ajax`：`Asyncronous JavaScript And XML`\n\n#### `Ajax` 定義\n\n結論放前面，`Ajax` 就是：\n> 向 server 發送請求之後，可以不需等待結果，就先進行其他的任務。等 server 回傳結果，再行處理。\n\n#### 為什麼需要 `Ajax`？\n\n稍微了解 `JavaScript` 的人都明白，瀏覽器在讀取 JS 檔案時是一行接著一行讀取的，當一行程式碼還沒處理完畢，就不會去動下一行，也因此一行卡住了，所有人都會等它，這就是同步處理。\n\n反之，你不確定這串程式碼會花多久時間，或你已經知道這會需要一段時間來處理，不想要網頁因為等待這串程式碼而卡住，就叫瀏覽器跳過去，先解讀其他程式碼，這就叫異步處理。\n\n`Ajax` 就是為了完成異步處理（`Asyncronous`）而出現的手段。因為要呼叫 server 再得到回傳資料，你實在無法確定這會花多少時間，所以乾脆讓它在背景處理好之後再渲染到 DOM。\n\n延伸應用，這也能夠提升使用者體驗。舉例來說，當使用者做了某個動作，網頁上的某部分資料會變動，透過 `Ajax` 就不需要切換整份 HTML，而只要替換變動的那部分資料就好，這才是符合使用者體驗的行為。\n\n是不是很方便呢？\n\n---\n\n## 那麼，到哪裡才買得到呢？\n\n不是啦，我是說，要怎樣才能使用如此方便的 `Ajax`？\n\n#### `XMLHttpRequest`\n\n第一種方式，就是透過原生的 `JavaScript` 去操作，一步步定義好每個 `XMLHttpRequest` 的 method 與 function，然後送出。\n\n關於使用原生 JS 操作 `XMLHttpRequest`，可以參考我之前寫的 [這篇文章](https://gkfat.github.io/gk-blog/2019/09/12/JS-XMLHttpRequest/#more)。\n\n#### `jQuery`\n\n根據 [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html) 提供的範例，jQuery 在 Ajax 的操作中，提供了與操作 Promise 類似的作法。\n\n範例如下：\n```javascript\n$.ajax({\n    // 進行要求的網址(URL)\n    url: './sample.json',\n    // 要送出的資料\n    data: {\n        id: 'a001'\n    },\n    // 要使用的 method\n    type: 'GET',\n    // 資料的類型\n    dataType : 'json',\n})\n  .done(function( json ) {\n       // 要求成功時要執行的程式碼\n      })\n  .fail(function( xhr, status, errorThrown ) {\n       // 要求失敗時要執行的程式碼\n        console.log( '出現錯誤，無法完成!' )\n        console.log( 'Error: ' + errorThrown )\n        console.log( 'Status: ' + status )\n        console.dir( xhr )\n      })\n  // 不論成功或失敗都會執行的程式碼\n  .always(function( xhr, status ) {\n    console.log( '要求已完成!' )\n    });\n```\n\n老實說，我一直沒有去碰 jQuey，因為我覺得大部分時候，原生 JS 都能解決，因此一直在加深原生的基礎。\n\n#### `Fetch`\n\n這是一個 HTML5 的新 API，而非 ES6 的新語法。但同時，\n它也會需要使用到 ES6 的 Promise 來實作。\n\nFetch 如果成功的話，會回傳一個帶 response 的 Promise 物件。它的語法類似於 jQuery，但相較之下更單純：\n\n```javascript\nfetch( url, {method: 'get'} )\n    .then(function(response) {\n        // 在這裡處理 response\n    })\n    .catch(function(err) {\n        // 丟出 Error :(\n    });\n```\n\n不過要注意的是， Fetch 只要收到回應，都會回傳 Promise，因此需要多加注意分辨成功與失敗的狀態。\n\n---\n\n## `ES6 Promise` \n\n既然 Fetch 就是會回傳一個 Promise，那麼至少必須了解如何使用 Promsie。\n\n直接透過範例來看會更好懂：\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    // 異步處理\n    // 處理完後，調用 resolve 或 reject\n});\n\n// 或者這樣做\nfetch( url, {method: 'get'} ) //這裡會傳回 promise\n    .then(successCallback})\n    .catch(errorCallback);\n```\n\n簡單地說，Promise 的操作，就是用 `.then` 與 `.catch` 去對成功與失敗的結果分別調用 callback。\n\n---\n\n## `Async` `Await`\n\n既然有了實現異步處理的工具，再來就會渴求更多。如果能夠「指定」處理的順序，那當然再好不過了對吧！\n\n在認識 `async` 以前，我如果要設定處理順序，就會在「需要優先處理的 function」內包覆一個 callback，這樣在優先處理完 function 之後，才會去調用那個 callback，繼續處理接下來的部分（這樣寫又複雜又有機會出 bug）。\n\n但只要在 function 前加上 `async`，就不需要再寫 callback！只要在需要優先處理的 function 前加上 `await`，所有程式就都會等這個 function 處理完之後，才繼續執行。\n\n換句話說，`async` 會將 function 內的某部分程式碼變為「強迫單線程執行」。\n\n綜合以上的這些技術與知識，是不是覺得更能輕鬆實作 `Ajax` 了呢？\n\n---\n參考資料：\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html)\n* [JavaScript Promise 迷你書](http://liubin.org/promises-book/#chapter1-what-is-promise)","source":"_posts/JS-Ajax.md","raw":"---\ntitle: JavaScript 學習筆記 - AJAX\ndate: 2019-10-04 14:47:53\ntags: [JavaScript, Ajax]\n---\n\n為了深入學習 `JavaScript`，不能單單只是會使用 `Ajax` ，而應進一步探討 `Asyncronous JavaScript And XML`（不過大多數的 `XML` 都已被 `JSON` 取代）。\n<!--more-->\n\n---\n\n## 首先看懂 `Ajax` 是什麼\n\n`Ajax`：`Asyncronous JavaScript And XML`\n\n#### `Ajax` 定義\n\n結論放前面，`Ajax` 就是：\n> 向 server 發送請求之後，可以不需等待結果，就先進行其他的任務。等 server 回傳結果，再行處理。\n\n#### 為什麼需要 `Ajax`？\n\n稍微了解 `JavaScript` 的人都明白，瀏覽器在讀取 JS 檔案時是一行接著一行讀取的，當一行程式碼還沒處理完畢，就不會去動下一行，也因此一行卡住了，所有人都會等它，這就是同步處理。\n\n反之，你不確定這串程式碼會花多久時間，或你已經知道這會需要一段時間來處理，不想要網頁因為等待這串程式碼而卡住，就叫瀏覽器跳過去，先解讀其他程式碼，這就叫異步處理。\n\n`Ajax` 就是為了完成異步處理（`Asyncronous`）而出現的手段。因為要呼叫 server 再得到回傳資料，你實在無法確定這會花多少時間，所以乾脆讓它在背景處理好之後再渲染到 DOM。\n\n延伸應用，這也能夠提升使用者體驗。舉例來說，當使用者做了某個動作，網頁上的某部分資料會變動，透過 `Ajax` 就不需要切換整份 HTML，而只要替換變動的那部分資料就好，這才是符合使用者體驗的行為。\n\n是不是很方便呢？\n\n---\n\n## 那麼，到哪裡才買得到呢？\n\n不是啦，我是說，要怎樣才能使用如此方便的 `Ajax`？\n\n#### `XMLHttpRequest`\n\n第一種方式，就是透過原生的 `JavaScript` 去操作，一步步定義好每個 `XMLHttpRequest` 的 method 與 function，然後送出。\n\n關於使用原生 JS 操作 `XMLHttpRequest`，可以參考我之前寫的 [這篇文章](https://gkfat.github.io/gk-blog/2019/09/12/JS-XMLHttpRequest/#more)。\n\n#### `jQuery`\n\n根據 [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html) 提供的範例，jQuery 在 Ajax 的操作中，提供了與操作 Promise 類似的作法。\n\n範例如下：\n```javascript\n$.ajax({\n    // 進行要求的網址(URL)\n    url: './sample.json',\n    // 要送出的資料\n    data: {\n        id: 'a001'\n    },\n    // 要使用的 method\n    type: 'GET',\n    // 資料的類型\n    dataType : 'json',\n})\n  .done(function( json ) {\n       // 要求成功時要執行的程式碼\n      })\n  .fail(function( xhr, status, errorThrown ) {\n       // 要求失敗時要執行的程式碼\n        console.log( '出現錯誤，無法完成!' )\n        console.log( 'Error: ' + errorThrown )\n        console.log( 'Status: ' + status )\n        console.dir( xhr )\n      })\n  // 不論成功或失敗都會執行的程式碼\n  .always(function( xhr, status ) {\n    console.log( '要求已完成!' )\n    });\n```\n\n老實說，我一直沒有去碰 jQuey，因為我覺得大部分時候，原生 JS 都能解決，因此一直在加深原生的基礎。\n\n#### `Fetch`\n\n這是一個 HTML5 的新 API，而非 ES6 的新語法。但同時，\n它也會需要使用到 ES6 的 Promise 來實作。\n\nFetch 如果成功的話，會回傳一個帶 response 的 Promise 物件。它的語法類似於 jQuery，但相較之下更單純：\n\n```javascript\nfetch( url, {method: 'get'} )\n    .then(function(response) {\n        // 在這裡處理 response\n    })\n    .catch(function(err) {\n        // 丟出 Error :(\n    });\n```\n\n不過要注意的是， Fetch 只要收到回應，都會回傳 Promise，因此需要多加注意分辨成功與失敗的狀態。\n\n---\n\n## `ES6 Promise` \n\n既然 Fetch 就是會回傳一個 Promise，那麼至少必須了解如何使用 Promsie。\n\n直接透過範例來看會更好懂：\n```javascript\nlet promise = new Promise(function(resolve, reject){\n    // 異步處理\n    // 處理完後，調用 resolve 或 reject\n});\n\n// 或者這樣做\nfetch( url, {method: 'get'} ) //這裡會傳回 promise\n    .then(successCallback})\n    .catch(errorCallback);\n```\n\n簡單地說，Promise 的操作，就是用 `.then` 與 `.catch` 去對成功與失敗的結果分別調用 callback。\n\n---\n\n## `Async` `Await`\n\n既然有了實現異步處理的工具，再來就會渴求更多。如果能夠「指定」處理的順序，那當然再好不過了對吧！\n\n在認識 `async` 以前，我如果要設定處理順序，就會在「需要優先處理的 function」內包覆一個 callback，這樣在優先處理完 function 之後，才會去調用那個 callback，繼續處理接下來的部分（這樣寫又複雜又有機會出 bug）。\n\n但只要在 function 前加上 `async`，就不需要再寫 callback！只要在需要優先處理的 function 前加上 `await`，所有程式就都會等這個 function 處理完之後，才繼續執行。\n\n換句話說，`async` 會將 function 內的某部分程式碼變為「強迫單線程執行」。\n\n綜合以上的這些技術與知識，是不是覺得更能輕鬆實作 `Ajax` 了呢？\n\n---\n參考資料：\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html)\n* [JavaScript Promise 迷你書](http://liubin.org/promises-book/#chapter1-what-is-promise)","slug":"JS-Ajax","published":1,"updated":"2022-03-12T12:58:19.927Z","_id":"cl0nusswh000oz6us9ltwah3y","comments":1,"layout":"post","photos":[],"link":"","content":"<p>為了深入學習 <code>JavaScript</code>，不能單單只是會使用 <code>Ajax</code> ，而應進一步探討 <code>Asyncronous JavaScript And XML</code>（不過大多數的 <code>XML</code> 都已被 <code>JSON</code> 取代）。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"首先看懂-Ajax-是什麼\"><a href=\"#首先看懂-Ajax-是什麼\" class=\"headerlink\" title=\"首先看懂 Ajax 是什麼\"></a>首先看懂 <code>Ajax</code> 是什麼</h2><p><code>Ajax</code>：<code>Asyncronous JavaScript And XML</code></p>\n<h4 id=\"Ajax-定義\"><a href=\"#Ajax-定義\" class=\"headerlink\" title=\"Ajax 定義\"></a><code>Ajax</code> 定義</h4><p>結論放前面，<code>Ajax</code> 就是：</p>\n<blockquote>\n<p>向 server 發送請求之後，可以不需等待結果，就先進行其他的任務。等 server 回傳結果，再行處理。</p>\n</blockquote>\n<h4 id=\"為什麼需要-Ajax？\"><a href=\"#為什麼需要-Ajax？\" class=\"headerlink\" title=\"為什麼需要 Ajax？\"></a>為什麼需要 <code>Ajax</code>？</h4><p>稍微了解 <code>JavaScript</code> 的人都明白，瀏覽器在讀取 JS 檔案時是一行接著一行讀取的，當一行程式碼還沒處理完畢，就不會去動下一行，也因此一行卡住了，所有人都會等它，這就是同步處理。</p>\n<p>反之，你不確定這串程式碼會花多久時間，或你已經知道這會需要一段時間來處理，不想要網頁因為等待這串程式碼而卡住，就叫瀏覽器跳過去，先解讀其他程式碼，這就叫異步處理。</p>\n<p><code>Ajax</code> 就是為了完成異步處理（<code>Asyncronous</code>）而出現的手段。因為要呼叫 server 再得到回傳資料，你實在無法確定這會花多少時間，所以乾脆讓它在背景處理好之後再渲染到 DOM。</p>\n<p>延伸應用，這也能夠提升使用者體驗。舉例來說，當使用者做了某個動作，網頁上的某部分資料會變動，透過 <code>Ajax</code> 就不需要切換整份 HTML，而只要替換變動的那部分資料就好，這才是符合使用者體驗的行為。</p>\n<p>是不是很方便呢？</p>\n<hr>\n<h2 id=\"那麼，到哪裡才買得到呢？\"><a href=\"#那麼，到哪裡才買得到呢？\" class=\"headerlink\" title=\"那麼，到哪裡才買得到呢？\"></a>那麼，到哪裡才買得到呢？</h2><p>不是啦，我是說，要怎樣才能使用如此方便的 <code>Ajax</code>？</p>\n<h4 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><code>XMLHttpRequest</code></h4><p>第一種方式，就是透過原生的 <code>JavaScript</code> 去操作，一步步定義好每個 <code>XMLHttpRequest</code> 的 method 與 function，然後送出。</p>\n<p>關於使用原生 JS 操作 <code>XMLHttpRequest</code>，可以參考我之前寫的 <a href=\"https://gkfat.github.io/gk-blog/2019/09/12/JS-XMLHttpRequest/#more\">這篇文章</a>。</p>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a><code>jQuery</code></h4><p>根據 <a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a> 提供的範例，jQuery 在 Ajax 的操作中，提供了與操作 Promise 類似的作法。</p>\n<p>範例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.<span class=\"title function_\">ajax</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 進行要求的網址(URL)</span></span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;./sample.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 要送出的資料</span></span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">&#x27;a001&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 要使用的 method</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 資料的類型</span></span><br><span class=\"line\">    dataType : <span class=\"string\">&#x27;json&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">done</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> json </span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 要求成功時要執行的程式碼</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">fail</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> xhr, status, errorThrown </span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 要求失敗時要執行的程式碼</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;出現錯誤，無法完成!&#x27;</span> )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;Error: &#x27;</span> + errorThrown )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;Status: &#x27;</span> + status )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">dir</span>( xhr )</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 不論成功或失敗都會執行的程式碼</span></span><br><span class=\"line\">  .<span class=\"title function_\">always</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> xhr, status </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;要求已完成!&#x27;</span> )</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>老實說，我一直沒有去碰 jQuey，因為我覺得大部分時候，原生 JS 都能解決，因此一直在加深原生的基礎。</p>\n<h4 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a><code>Fetch</code></h4><p>這是一個 HTML5 的新 API，而非 ES6 的新語法。但同時，<br>它也會需要使用到 ES6 的 Promise 來實作。</p>\n<p>Fetch 如果成功的話，會回傳一個帶 response 的 Promise 物件。它的語法類似於 jQuery，但相較之下更單純：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>( url, &#123;<span class=\"attr\">method</span>: <span class=\"string\">&#x27;get&#x27;</span>&#125; )</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在這裡處理 response</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 丟出 Error :(</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不過要注意的是， Fetch 只要收到回應，都會回傳 Promise，因此需要多加注意分辨成功與失敗的狀態。</p>\n<hr>\n<h2 id=\"ES6-Promise\"><a href=\"#ES6-Promise\" class=\"headerlink\" title=\"ES6 Promise\"></a><code>ES6 Promise</code></h2><p>既然 Fetch 就是會回傳一個 Promise，那麼至少必須了解如何使用 Promsie。</p>\n<p>直接透過範例來看會更好懂：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 異步處理</span></span><br><span class=\"line\">    <span class=\"comment\">// 處理完後，調用 resolve 或 reject</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者這樣做</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>( url, &#123;<span class=\"attr\">method</span>: <span class=\"string\">&#x27;get&#x27;</span>&#125; ) <span class=\"comment\">//這裡會傳回 promise</span></span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(successCallback&#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(errorCallback);</span><br></pre></td></tr></table></figure>\n\n<p>簡單地說，Promise 的操作，就是用 <code>.then</code> 與 <code>.catch</code> 去對成功與失敗的結果分別調用 callback。</p>\n<hr>\n<h2 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async Await\"></a><code>Async</code> <code>Await</code></h2><p>既然有了實現異步處理的工具，再來就會渴求更多。如果能夠「指定」處理的順序，那當然再好不過了對吧！</p>\n<p>在認識 <code>async</code> 以前，我如果要設定處理順序，就會在「需要優先處理的 function」內包覆一個 callback，這樣在優先處理完 function 之後，才會去調用那個 callback，繼續處理接下來的部分（這樣寫又複雜又有機會出 bug）。</p>\n<p>但只要在 function 前加上 <code>async</code>，就不需要再寫 callback！只要在需要優先處理的 function 前加上 <code>await</code>，所有程式就都會等這個 function 處理完之後，才繼續執行。</p>\n<p>換句話說，<code>async</code> 會將 function 內的某部分程式碼變為「強迫單線程執行」。</p>\n<p>綜合以上的這些技術與知識，是不是覺得更能輕鬆實作 <code>Ajax</code> 了呢？</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"http://liubin.org/promises-book/#chapter1-what-is-promise\" >JavaScript Promise 迷你書<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>為了深入學習 <code>JavaScript</code>，不能單單只是會使用 <code>Ajax</code> ，而應進一步探討 <code>Asyncronous JavaScript And XML</code>（不過大多數的 <code>XML</code> 都已被 <code>JSON</code> 取代）。</p>","more":"<hr>\n<h2 id=\"首先看懂-Ajax-是什麼\"><a href=\"#首先看懂-Ajax-是什麼\" class=\"headerlink\" title=\"首先看懂 Ajax 是什麼\"></a>首先看懂 <code>Ajax</code> 是什麼</h2><p><code>Ajax</code>：<code>Asyncronous JavaScript And XML</code></p>\n<h4 id=\"Ajax-定義\"><a href=\"#Ajax-定義\" class=\"headerlink\" title=\"Ajax 定義\"></a><code>Ajax</code> 定義</h4><p>結論放前面，<code>Ajax</code> 就是：</p>\n<blockquote>\n<p>向 server 發送請求之後，可以不需等待結果，就先進行其他的任務。等 server 回傳結果，再行處理。</p>\n</blockquote>\n<h4 id=\"為什麼需要-Ajax？\"><a href=\"#為什麼需要-Ajax？\" class=\"headerlink\" title=\"為什麼需要 Ajax？\"></a>為什麼需要 <code>Ajax</code>？</h4><p>稍微了解 <code>JavaScript</code> 的人都明白，瀏覽器在讀取 JS 檔案時是一行接著一行讀取的，當一行程式碼還沒處理完畢，就不會去動下一行，也因此一行卡住了，所有人都會等它，這就是同步處理。</p>\n<p>反之，你不確定這串程式碼會花多久時間，或你已經知道這會需要一段時間來處理，不想要網頁因為等待這串程式碼而卡住，就叫瀏覽器跳過去，先解讀其他程式碼，這就叫異步處理。</p>\n<p><code>Ajax</code> 就是為了完成異步處理（<code>Asyncronous</code>）而出現的手段。因為要呼叫 server 再得到回傳資料，你實在無法確定這會花多少時間，所以乾脆讓它在背景處理好之後再渲染到 DOM。</p>\n<p>延伸應用，這也能夠提升使用者體驗。舉例來說，當使用者做了某個動作，網頁上的某部分資料會變動，透過 <code>Ajax</code> 就不需要切換整份 HTML，而只要替換變動的那部分資料就好，這才是符合使用者體驗的行為。</p>\n<p>是不是很方便呢？</p>\n<hr>\n<h2 id=\"那麼，到哪裡才買得到呢？\"><a href=\"#那麼，到哪裡才買得到呢？\" class=\"headerlink\" title=\"那麼，到哪裡才買得到呢？\"></a>那麼，到哪裡才買得到呢？</h2><p>不是啦，我是說，要怎樣才能使用如此方便的 <code>Ajax</code>？</p>\n<h4 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><code>XMLHttpRequest</code></h4><p>第一種方式，就是透過原生的 <code>JavaScript</code> 去操作，一步步定義好每個 <code>XMLHttpRequest</code> 的 method 與 function，然後送出。</p>\n<p>關於使用原生 JS 操作 <code>XMLHttpRequest</code>，可以參考我之前寫的 <a href=\"https://gkfat.github.io/gk-blog/2019/09/12/JS-XMLHttpRequest/#more\">這篇文章</a>。</p>\n<h4 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a><code>jQuery</code></h4><p>根據 <a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a> 提供的範例，jQuery 在 Ajax 的操作中，提供了與操作 Promise 類似的作法。</p>\n<p>範例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.<span class=\"title function_\">ajax</span>(&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 進行要求的網址(URL)</span></span><br><span class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">&#x27;./sample.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 要送出的資料</span></span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"string\">&#x27;a001&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 要使用的 method</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 資料的類型</span></span><br><span class=\"line\">    dataType : <span class=\"string\">&#x27;json&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">done</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> json </span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 要求成功時要執行的程式碼</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">fail</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> xhr, status, errorThrown </span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 要求失敗時要執行的程式碼</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;出現錯誤，無法完成!&#x27;</span> )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;Error: &#x27;</span> + errorThrown )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;Status: &#x27;</span> + status )</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">dir</span>( xhr )</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 不論成功或失敗都會執行的程式碼</span></span><br><span class=\"line\">  .<span class=\"title function_\">always</span>(<span class=\"keyword\">function</span>(<span class=\"params\"> xhr, status </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( <span class=\"string\">&#x27;要求已完成!&#x27;</span> )</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>老實說，我一直沒有去碰 jQuey，因為我覺得大部分時候，原生 JS 都能解決，因此一直在加深原生的基礎。</p>\n<h4 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a><code>Fetch</code></h4><p>這是一個 HTML5 的新 API，而非 ES6 的新語法。但同時，<br>它也會需要使用到 ES6 的 Promise 來實作。</p>\n<p>Fetch 如果成功的話，會回傳一個帶 response 的 Promise 物件。它的語法類似於 jQuery，但相較之下更單純：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>( url, &#123;<span class=\"attr\">method</span>: <span class=\"string\">&#x27;get&#x27;</span>&#125; )</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在這裡處理 response</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 丟出 Error :(</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>不過要注意的是， Fetch 只要收到回應，都會回傳 Promise，因此需要多加注意分辨成功與失敗的狀態。</p>\n<hr>\n<h2 id=\"ES6-Promise\"><a href=\"#ES6-Promise\" class=\"headerlink\" title=\"ES6 Promise\"></a><code>ES6 Promise</code></h2><p>既然 Fetch 就是會回傳一個 Promise，那麼至少必須了解如何使用 Promsie。</p>\n<p>直接透過範例來看會更好懂：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 異步處理</span></span><br><span class=\"line\">    <span class=\"comment\">// 處理完後，調用 resolve 或 reject</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者這樣做</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>( url, &#123;<span class=\"attr\">method</span>: <span class=\"string\">&#x27;get&#x27;</span>&#125; ) <span class=\"comment\">//這裡會傳回 promise</span></span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(successCallback&#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(errorCallback);</span><br></pre></td></tr></table></figure>\n\n<p>簡單地說，Promise 的操作，就是用 <code>.then</code> 與 <code>.catch</code> 去對成功與失敗的結果分別調用 callback。</p>\n<hr>\n<h2 id=\"Async-Await\"><a href=\"#Async-Await\" class=\"headerlink\" title=\"Async Await\"></a><code>Async</code> <code>Await</code></h2><p>既然有了實現異步處理的工具，再來就會渴求更多。如果能夠「指定」處理的順序，那當然再好不過了對吧！</p>\n<p>在認識 <code>async</code> 以前，我如果要設定處理順序，就會在「需要優先處理的 function」內包覆一個 callback，這樣在優先處理完 function 之後，才會去調用那個 callback，繼續處理接下來的部分（這樣寫又複雜又有機會出 bug）。</p>\n<p>但只要在 function 前加上 <code>async</code>，就不需要再寫 callback！只要在需要優先處理的 function 前加上 <code>await</code>，所有程式就都會等這個 function 處理完之後，才繼續執行。</p>\n<p>換句話說，<code>async</code> 會將 function 內的某部分程式碼變為「強迫單線程執行」。</p>\n<p>綜合以上的這些技術與知識，是不是覺得更能輕鬆實作 <code>Ajax</code> 了呢？</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/ajax_fetch.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"http://liubin.org/promises-book/#chapter1-what-is-promise\" >JavaScript Promise 迷你書<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - 陣列操作方法","date":"2019-09-14T07:08:04.000Z","_content":"\n在寫 JavaScript 時，很常會需要去操作陣列，為了加深自己對陣列操作方法的印象而整理了這一篇筆記。\n<!--more-->\n\n---\n\n## 操作陣列的目的\n\n為了更好地分類內容，我們會把性質相近的元素放在同一個陣列，然而時常又需要對這個陣列做查找、提取、新增、刪除、或其他操作。JavaScript 內建有非常多操作陣列的方法（Methods），不過常用的也只有幾種而已。\n\n陣列具有兩個重要的屬性： `length` 與 `index`，透過這兩個屬性，我們得以直接接觸到目標內容，就不需要迭代整個陣列。\n\n\n## 操作陣列的方法\n\n|方法|描述|\n|-|-|\n|forEach()|對每一個元素執行傳入的 `callback`|\n|map()|return 一個新陣列，每一個元素為執行傳入的 `callback` 後的結果|\n|filter()|return 一個在 `callback` 中返回 true 的元素的新陣列|\n|every()|如果陣列每一項元素都在 `callback` 中返回 true，則返回 true|\n|some()|如果陣列至少有一項元素在 `callback` 中返回 true，則返回 true|\n|reduce()|透過 `callback` 對陣列中每個元素做運算，並 return 一個單一的值|\n|concat()|合併兩個陣列，並 return 新陣列|\n|copyWithin()|複製陣列中某些元素，並取代陣列中指定 `index` 的元素|\n|fill()|將陣列中的元素，替換為傳入的值|\n|keys()|return 一個新陣列，每一個元素是原陣列中每個元素的 `index` 值|\n|find()|將陣列中每一個元素帶入 `callback` 判斷，並回傳第一個符合條件的元素|\n|findIndex()|將陣列中每一個元素帶入 `callback` 判斷，並回傳第一個符合條件的元素的 `index`|\n|indexOf()|在陣列中由前往後查找目標元素的 `index`|\n|lastIndexOf()|在陣列中由後往前查找目標元素的 `index`|\n|join()|將陣列內容合併成一個字串|\n|toString()|return 一個字串，內容是以逗號分隔的陣列元素|\n|shift()|移除並返回陣列的第一個元素|\n|pop()|移除並返回陣列的最後一個元素|\n|unshift()|在陣列的開頭新增傳入的元素|\n|push()|在陣列的最後新增傳入的元素|\n|reverse()|反轉陣列元素的排列順序|\n|sort()|排序陣列的元素|\n|slice()|return 一個新陣列，內容為指定 `index` 及長度的元素|\n|splice()|可新增或移除指定 `index` 的元素|\n|isArray()|判斷一個物件是否為陣列，return true / false|\n|from()|將物件依照 `callback` 轉換為陣列|\n|includes()|判斷陣列中是否含有某個元素，return true / false|\n\n---\n\n## 常用的方法\n\n僅管操作陣列的方法有這麼多種，其實平常也不會全部都用到。以下整理了幾個我本身較常使用的方法。\n\n### `forEach()` `map()`\n當想要對一個陣列中每個元素做操作，這兩種方法就很好用。 若只是想對每個元素進行操作，就用`forEach()`（有點類似使用 `for` 迴圈，不過寫法更簡潔）；若操作完後要直接回傳一個陣列，就用 `map()`。\n\n### `filter()` `every()` `some()`\n在實現篩選功能的時候，這幾個方法就很適合。\n\n若需要較複雜的篩選條件，就用`filter()` 遍歷整個陣列，並直接返回一個新陣列；而 `every()` 與 `some()` 可以拿來做比較簡單的篩選，只需判斷 `true` / `false`。\n\n### `sort()`\n需要對陣列做排序的時候使用。若要做大小排序，只需代入下列匿名函式：\n```javascript\narray.sort(function(a, b) {\n  return a - b;\n});\n```\n當然還可以做更複雜的排序。\n\n### `reduce()`\n有點類似 `forEach()` 與 `map()` 的用法，但更適合在要對整個陣列運算出一個單一結果時使用。\n\n### `find()` `findIndex()`\n能夠用抽象的描述找到符合條件元素的 `index`。通常接著會搭配使用其他的方法，像是取出該元素或複製、刪除等等。\n\n### `indexOf()` `lastIndexOf()`\n如果已經知道目標元素的長相，這兩個方法能夠直接查詢 `index`，方便你做接下來的操作。\n\n### `splice()`\n能夠很方便地在陣列中指定位置刪除／新增元素，有三個參數可以代入：\n```javascript\narray.splice(index, howmany, items)\n```\n|參數|描述|\n|-|-|\n|index|必需。為正／負整數，指定在陣列中開始操作的位置。|\n|howmany|必需。指定要刪除的數量，若不刪除元素則設置為 0。|\n|items|可選。向陣列新增的元素。|\n\n### `push()`\n若只是需要將新元素插入到陣列的最後，直接使用 `push()`。\n\n### `slice()`\n從陣列中複製一段內容，並回傳一個新陣列。\n```javascript\narray.slice(start, end)\n```\n|參數|描述|\n|-|-|\n|start|為正／負整數，指定在陣列中開始操作的位置。|\n|end|可選。提取片段的結尾位置，若有設定則提取到該位置的前一個元素，若不設定就會提取到最後。|\n\n### `reverse()` `join()`\n這兩個方法有時候會搭配使用，當你想要把一個字串內的每個字元反轉過來的時候，先使用字串的操作方法 `split()` 將其變成陣列，再做 `reverse()` 反轉每個元素，最後用 `join()` 再讓他變成一個字串。\n\n---\n參考資料：\n* [Tutorial Republic - JavaScript Array Methods](https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php)\n* [MDN - 陣列的運用](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8)\n* [OXXO Studio - JavaScript Array 陣列操作方法大全 ( 含 ES6 )](https://www.oxxostudio.tw/articles/201908/js-array.html)\n","source":"_posts/JS-array-methods.md","raw":"---\ntitle: JavaScript 學習筆記 - 陣列操作方法\ndate: 2019-09-14 15:08:04\ntags: [JavaScript]\n---\n\n在寫 JavaScript 時，很常會需要去操作陣列，為了加深自己對陣列操作方法的印象而整理了這一篇筆記。\n<!--more-->\n\n---\n\n## 操作陣列的目的\n\n為了更好地分類內容，我們會把性質相近的元素放在同一個陣列，然而時常又需要對這個陣列做查找、提取、新增、刪除、或其他操作。JavaScript 內建有非常多操作陣列的方法（Methods），不過常用的也只有幾種而已。\n\n陣列具有兩個重要的屬性： `length` 與 `index`，透過這兩個屬性，我們得以直接接觸到目標內容，就不需要迭代整個陣列。\n\n\n## 操作陣列的方法\n\n|方法|描述|\n|-|-|\n|forEach()|對每一個元素執行傳入的 `callback`|\n|map()|return 一個新陣列，每一個元素為執行傳入的 `callback` 後的結果|\n|filter()|return 一個在 `callback` 中返回 true 的元素的新陣列|\n|every()|如果陣列每一項元素都在 `callback` 中返回 true，則返回 true|\n|some()|如果陣列至少有一項元素在 `callback` 中返回 true，則返回 true|\n|reduce()|透過 `callback` 對陣列中每個元素做運算，並 return 一個單一的值|\n|concat()|合併兩個陣列，並 return 新陣列|\n|copyWithin()|複製陣列中某些元素，並取代陣列中指定 `index` 的元素|\n|fill()|將陣列中的元素，替換為傳入的值|\n|keys()|return 一個新陣列，每一個元素是原陣列中每個元素的 `index` 值|\n|find()|將陣列中每一個元素帶入 `callback` 判斷，並回傳第一個符合條件的元素|\n|findIndex()|將陣列中每一個元素帶入 `callback` 判斷，並回傳第一個符合條件的元素的 `index`|\n|indexOf()|在陣列中由前往後查找目標元素的 `index`|\n|lastIndexOf()|在陣列中由後往前查找目標元素的 `index`|\n|join()|將陣列內容合併成一個字串|\n|toString()|return 一個字串，內容是以逗號分隔的陣列元素|\n|shift()|移除並返回陣列的第一個元素|\n|pop()|移除並返回陣列的最後一個元素|\n|unshift()|在陣列的開頭新增傳入的元素|\n|push()|在陣列的最後新增傳入的元素|\n|reverse()|反轉陣列元素的排列順序|\n|sort()|排序陣列的元素|\n|slice()|return 一個新陣列，內容為指定 `index` 及長度的元素|\n|splice()|可新增或移除指定 `index` 的元素|\n|isArray()|判斷一個物件是否為陣列，return true / false|\n|from()|將物件依照 `callback` 轉換為陣列|\n|includes()|判斷陣列中是否含有某個元素，return true / false|\n\n---\n\n## 常用的方法\n\n僅管操作陣列的方法有這麼多種，其實平常也不會全部都用到。以下整理了幾個我本身較常使用的方法。\n\n### `forEach()` `map()`\n當想要對一個陣列中每個元素做操作，這兩種方法就很好用。 若只是想對每個元素進行操作，就用`forEach()`（有點類似使用 `for` 迴圈，不過寫法更簡潔）；若操作完後要直接回傳一個陣列，就用 `map()`。\n\n### `filter()` `every()` `some()`\n在實現篩選功能的時候，這幾個方法就很適合。\n\n若需要較複雜的篩選條件，就用`filter()` 遍歷整個陣列，並直接返回一個新陣列；而 `every()` 與 `some()` 可以拿來做比較簡單的篩選，只需判斷 `true` / `false`。\n\n### `sort()`\n需要對陣列做排序的時候使用。若要做大小排序，只需代入下列匿名函式：\n```javascript\narray.sort(function(a, b) {\n  return a - b;\n});\n```\n當然還可以做更複雜的排序。\n\n### `reduce()`\n有點類似 `forEach()` 與 `map()` 的用法，但更適合在要對整個陣列運算出一個單一結果時使用。\n\n### `find()` `findIndex()`\n能夠用抽象的描述找到符合條件元素的 `index`。通常接著會搭配使用其他的方法，像是取出該元素或複製、刪除等等。\n\n### `indexOf()` `lastIndexOf()`\n如果已經知道目標元素的長相，這兩個方法能夠直接查詢 `index`，方便你做接下來的操作。\n\n### `splice()`\n能夠很方便地在陣列中指定位置刪除／新增元素，有三個參數可以代入：\n```javascript\narray.splice(index, howmany, items)\n```\n|參數|描述|\n|-|-|\n|index|必需。為正／負整數，指定在陣列中開始操作的位置。|\n|howmany|必需。指定要刪除的數量，若不刪除元素則設置為 0。|\n|items|可選。向陣列新增的元素。|\n\n### `push()`\n若只是需要將新元素插入到陣列的最後，直接使用 `push()`。\n\n### `slice()`\n從陣列中複製一段內容，並回傳一個新陣列。\n```javascript\narray.slice(start, end)\n```\n|參數|描述|\n|-|-|\n|start|為正／負整數，指定在陣列中開始操作的位置。|\n|end|可選。提取片段的結尾位置，若有設定則提取到該位置的前一個元素，若不設定就會提取到最後。|\n\n### `reverse()` `join()`\n這兩個方法有時候會搭配使用，當你想要把一個字串內的每個字元反轉過來的時候，先使用字串的操作方法 `split()` 將其變成陣列，再做 `reverse()` 反轉每個元素，最後用 `join()` 再讓他變成一個字串。\n\n---\n參考資料：\n* [Tutorial Republic - JavaScript Array Methods](https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php)\n* [MDN - 陣列的運用](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8)\n* [OXXO Studio - JavaScript Array 陣列操作方法大全 ( 含 ES6 )](https://www.oxxostudio.tw/articles/201908/js-array.html)\n","slug":"JS-array-methods","published":1,"updated":"2022-03-12T12:58:20.065Z","_id":"cl0nussxq000sz6us1qrd8qal","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在寫 JavaScript 時，很常會需要去操作陣列，為了加深自己對陣列操作方法的印象而整理了這一篇筆記。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"操作陣列的目的\"><a href=\"#操作陣列的目的\" class=\"headerlink\" title=\"操作陣列的目的\"></a>操作陣列的目的</h2><p>為了更好地分類內容，我們會把性質相近的元素放在同一個陣列，然而時常又需要對這個陣列做查找、提取、新增、刪除、或其他操作。JavaScript 內建有非常多操作陣列的方法（Methods），不過常用的也只有幾種而已。</p>\n<p>陣列具有兩個重要的屬性： <code>length</code> 與 <code>index</code>，透過這兩個屬性，我們得以直接接觸到目標內容，就不需要迭代整個陣列。</p>\n<h2 id=\"操作陣列的方法\"><a href=\"#操作陣列的方法\" class=\"headerlink\" title=\"操作陣列的方法\"></a>操作陣列的方法</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>forEach()</td>\n<td>對每一個元素執行傳入的 <code>callback</code></td>\n</tr>\n<tr>\n<td>map()</td>\n<td>return 一個新陣列，每一個元素為執行傳入的 <code>callback</code> 後的結果</td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>return 一個在 <code>callback</code> 中返回 true 的元素的新陣列</td>\n</tr>\n<tr>\n<td>every()</td>\n<td>如果陣列每一項元素都在 <code>callback</code> 中返回 true，則返回 true</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>如果陣列至少有一項元素在 <code>callback</code> 中返回 true，則返回 true</td>\n</tr>\n<tr>\n<td>reduce()</td>\n<td>透過 <code>callback</code> 對陣列中每個元素做運算，並 return 一個單一的值</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>合併兩個陣列，並 return 新陣列</td>\n</tr>\n<tr>\n<td>copyWithin()</td>\n<td>複製陣列中某些元素，並取代陣列中指定 <code>index</code> 的元素</td>\n</tr>\n<tr>\n<td>fill()</td>\n<td>將陣列中的元素，替換為傳入的值</td>\n</tr>\n<tr>\n<td>keys()</td>\n<td>return 一個新陣列，每一個元素是原陣列中每個元素的 <code>index</code> 值</td>\n</tr>\n<tr>\n<td>find()</td>\n<td>將陣列中每一個元素帶入 <code>callback</code> 判斷，並回傳第一個符合條件的元素</td>\n</tr>\n<tr>\n<td>findIndex()</td>\n<td>將陣列中每一個元素帶入 <code>callback</code> 判斷，並回傳第一個符合條件的元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>indexOf()</td>\n<td>在陣列中由前往後查找目標元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>在陣列中由後往前查找目標元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>join()</td>\n<td>將陣列內容合併成一個字串</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>return 一個字串，內容是以逗號分隔的陣列元素</td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>移除並返回陣列的第一個元素</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>移除並返回陣列的最後一個元素</td>\n</tr>\n<tr>\n<td>unshift()</td>\n<td>在陣列的開頭新增傳入的元素</td>\n</tr>\n<tr>\n<td>push()</td>\n<td>在陣列的最後新增傳入的元素</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>反轉陣列元素的排列順序</td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>排序陣列的元素</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>return 一個新陣列，內容為指定 <code>index</code> 及長度的元素</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>可新增或移除指定 <code>index</code> 的元素</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>判斷一個物件是否為陣列，return true &#x2F; false</td>\n</tr>\n<tr>\n<td>from()</td>\n<td>將物件依照 <code>callback</code> 轉換為陣列</td>\n</tr>\n<tr>\n<td>includes()</td>\n<td>判斷陣列中是否含有某個元素，return true &#x2F; false</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"常用的方法\"><a href=\"#常用的方法\" class=\"headerlink\" title=\"常用的方法\"></a>常用的方法</h2><p>僅管操作陣列的方法有這麼多種，其實平常也不會全部都用到。以下整理了幾個我本身較常使用的方法。</p>\n<h3 id=\"forEach-map\"><a href=\"#forEach-map\" class=\"headerlink\" title=\"forEach() map()\"></a><code>forEach()</code> <code>map()</code></h3><p>當想要對一個陣列中每個元素做操作，這兩種方法就很好用。 若只是想對每個元素進行操作，就用<code>forEach()</code>（有點類似使用 <code>for</code> 迴圈，不過寫法更簡潔）；若操作完後要直接回傳一個陣列，就用 <code>map()</code>。</p>\n<h3 id=\"filter-every-some\"><a href=\"#filter-every-some\" class=\"headerlink\" title=\"filter() every() some()\"></a><code>filter()</code> <code>every()</code> <code>some()</code></h3><p>在實現篩選功能的時候，這幾個方法就很適合。</p>\n<p>若需要較複雜的篩選條件，就用<code>filter()</code> 遍歷整個陣列，並直接返回一個新陣列；而 <code>every()</code> 與 <code>some()</code> 可以拿來做比較簡單的篩選，只需判斷 <code>true</code> &#x2F; <code>false</code>。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a><code>sort()</code></h3><p>需要對陣列做排序的時候使用。若要做大小排序，只需代入下列匿名函式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">sort</span>(<span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>當然還可以做更複雜的排序。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a><code>reduce()</code></h3><p>有點類似 <code>forEach()</code> 與 <code>map()</code> 的用法，但更適合在要對整個陣列運算出一個單一結果時使用。</p>\n<h3 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find() findIndex()\"></a><code>find()</code> <code>findIndex()</code></h3><p>能夠用抽象的描述找到符合條件元素的 <code>index</code>。通常接著會搭配使用其他的方法，像是取出該元素或複製、刪除等等。</p>\n<h3 id=\"indexOf-lastIndexOf\"><a href=\"#indexOf-lastIndexOf\" class=\"headerlink\" title=\"indexOf() lastIndexOf()\"></a><code>indexOf()</code> <code>lastIndexOf()</code></h3><p>如果已經知道目標元素的長相，這兩個方法能夠直接查詢 <code>index</code>，方便你做接下來的操作。</p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a><code>splice()</code></h3><p>能夠很方便地在陣列中指定位置刪除／新增元素，有三個參數可以代入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">splice</span>(index, howmany, items)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>參數</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>必需。為正／負整數，指定在陣列中開始操作的位置。</td>\n</tr>\n<tr>\n<td>howmany</td>\n<td>必需。指定要刪除的數量，若不刪除元素則設置為 0。</td>\n</tr>\n<tr>\n<td>items</td>\n<td>可選。向陣列新增的元素。</td>\n</tr>\n</tbody></table>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a><code>push()</code></h3><p>若只是需要將新元素插入到陣列的最後，直接使用 <code>push()</code>。</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a><code>slice()</code></h3><p>從陣列中複製一段內容，並回傳一個新陣列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">slice</span>(start, end)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>參數</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>start</td>\n<td>為正／負整數，指定在陣列中開始操作的位置。</td>\n</tr>\n<tr>\n<td>end</td>\n<td>可選。提取片段的結尾位置，若有設定則提取到該位置的前一個元素，若不設定就會提取到最後。</td>\n</tr>\n</tbody></table>\n<h3 id=\"reverse-join\"><a href=\"#reverse-join\" class=\"headerlink\" title=\"reverse() join()\"></a><code>reverse()</code> <code>join()</code></h3><p>這兩個方法有時候會搭配使用，當你想要把一個字串內的每個字元反轉過來的時候，先使用字串的操作方法 <code>split()</code> 將其變成陣列，再做 <code>reverse()</code> 反轉每個元素，最後用 <code>join()</code> 再讓他變成一個字串。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php\" >Tutorial Republic - JavaScript Array Methods<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8\" >MDN - 陣列的運用<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.oxxostudio.tw/articles/201908/js-array.html\" >OXXO Studio - JavaScript Array 陣列操作方法大全 ( 含 ES6 )<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在寫 JavaScript 時，很常會需要去操作陣列，為了加深自己對陣列操作方法的印象而整理了這一篇筆記。</p>","more":"<hr>\n<h2 id=\"操作陣列的目的\"><a href=\"#操作陣列的目的\" class=\"headerlink\" title=\"操作陣列的目的\"></a>操作陣列的目的</h2><p>為了更好地分類內容，我們會把性質相近的元素放在同一個陣列，然而時常又需要對這個陣列做查找、提取、新增、刪除、或其他操作。JavaScript 內建有非常多操作陣列的方法（Methods），不過常用的也只有幾種而已。</p>\n<p>陣列具有兩個重要的屬性： <code>length</code> 與 <code>index</code>，透過這兩個屬性，我們得以直接接觸到目標內容，就不需要迭代整個陣列。</p>\n<h2 id=\"操作陣列的方法\"><a href=\"#操作陣列的方法\" class=\"headerlink\" title=\"操作陣列的方法\"></a>操作陣列的方法</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>forEach()</td>\n<td>對每一個元素執行傳入的 <code>callback</code></td>\n</tr>\n<tr>\n<td>map()</td>\n<td>return 一個新陣列，每一個元素為執行傳入的 <code>callback</code> 後的結果</td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>return 一個在 <code>callback</code> 中返回 true 的元素的新陣列</td>\n</tr>\n<tr>\n<td>every()</td>\n<td>如果陣列每一項元素都在 <code>callback</code> 中返回 true，則返回 true</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>如果陣列至少有一項元素在 <code>callback</code> 中返回 true，則返回 true</td>\n</tr>\n<tr>\n<td>reduce()</td>\n<td>透過 <code>callback</code> 對陣列中每個元素做運算，並 return 一個單一的值</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>合併兩個陣列，並 return 新陣列</td>\n</tr>\n<tr>\n<td>copyWithin()</td>\n<td>複製陣列中某些元素，並取代陣列中指定 <code>index</code> 的元素</td>\n</tr>\n<tr>\n<td>fill()</td>\n<td>將陣列中的元素，替換為傳入的值</td>\n</tr>\n<tr>\n<td>keys()</td>\n<td>return 一個新陣列，每一個元素是原陣列中每個元素的 <code>index</code> 值</td>\n</tr>\n<tr>\n<td>find()</td>\n<td>將陣列中每一個元素帶入 <code>callback</code> 判斷，並回傳第一個符合條件的元素</td>\n</tr>\n<tr>\n<td>findIndex()</td>\n<td>將陣列中每一個元素帶入 <code>callback</code> 判斷，並回傳第一個符合條件的元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>indexOf()</td>\n<td>在陣列中由前往後查找目標元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>在陣列中由後往前查找目標元素的 <code>index</code></td>\n</tr>\n<tr>\n<td>join()</td>\n<td>將陣列內容合併成一個字串</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>return 一個字串，內容是以逗號分隔的陣列元素</td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>移除並返回陣列的第一個元素</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>移除並返回陣列的最後一個元素</td>\n</tr>\n<tr>\n<td>unshift()</td>\n<td>在陣列的開頭新增傳入的元素</td>\n</tr>\n<tr>\n<td>push()</td>\n<td>在陣列的最後新增傳入的元素</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>反轉陣列元素的排列順序</td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>排序陣列的元素</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>return 一個新陣列，內容為指定 <code>index</code> 及長度的元素</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>可新增或移除指定 <code>index</code> 的元素</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>判斷一個物件是否為陣列，return true &#x2F; false</td>\n</tr>\n<tr>\n<td>from()</td>\n<td>將物件依照 <code>callback</code> 轉換為陣列</td>\n</tr>\n<tr>\n<td>includes()</td>\n<td>判斷陣列中是否含有某個元素，return true &#x2F; false</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"常用的方法\"><a href=\"#常用的方法\" class=\"headerlink\" title=\"常用的方法\"></a>常用的方法</h2><p>僅管操作陣列的方法有這麼多種，其實平常也不會全部都用到。以下整理了幾個我本身較常使用的方法。</p>\n<h3 id=\"forEach-map\"><a href=\"#forEach-map\" class=\"headerlink\" title=\"forEach() map()\"></a><code>forEach()</code> <code>map()</code></h3><p>當想要對一個陣列中每個元素做操作，這兩種方法就很好用。 若只是想對每個元素進行操作，就用<code>forEach()</code>（有點類似使用 <code>for</code> 迴圈，不過寫法更簡潔）；若操作完後要直接回傳一個陣列，就用 <code>map()</code>。</p>\n<h3 id=\"filter-every-some\"><a href=\"#filter-every-some\" class=\"headerlink\" title=\"filter() every() some()\"></a><code>filter()</code> <code>every()</code> <code>some()</code></h3><p>在實現篩選功能的時候，這幾個方法就很適合。</p>\n<p>若需要較複雜的篩選條件，就用<code>filter()</code> 遍歷整個陣列，並直接返回一個新陣列；而 <code>every()</code> 與 <code>some()</code> 可以拿來做比較簡單的篩選，只需判斷 <code>true</code> &#x2F; <code>false</code>。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a><code>sort()</code></h3><p>需要對陣列做排序的時候使用。若要做大小排序，只需代入下列匿名函式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">sort</span>(<span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>當然還可以做更複雜的排序。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a><code>reduce()</code></h3><p>有點類似 <code>forEach()</code> 與 <code>map()</code> 的用法，但更適合在要對整個陣列運算出一個單一結果時使用。</p>\n<h3 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find() findIndex()\"></a><code>find()</code> <code>findIndex()</code></h3><p>能夠用抽象的描述找到符合條件元素的 <code>index</code>。通常接著會搭配使用其他的方法，像是取出該元素或複製、刪除等等。</p>\n<h3 id=\"indexOf-lastIndexOf\"><a href=\"#indexOf-lastIndexOf\" class=\"headerlink\" title=\"indexOf() lastIndexOf()\"></a><code>indexOf()</code> <code>lastIndexOf()</code></h3><p>如果已經知道目標元素的長相，這兩個方法能夠直接查詢 <code>index</code>，方便你做接下來的操作。</p>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a><code>splice()</code></h3><p>能夠很方便地在陣列中指定位置刪除／新增元素，有三個參數可以代入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">splice</span>(index, howmany, items)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>參數</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>必需。為正／負整數，指定在陣列中開始操作的位置。</td>\n</tr>\n<tr>\n<td>howmany</td>\n<td>必需。指定要刪除的數量，若不刪除元素則設置為 0。</td>\n</tr>\n<tr>\n<td>items</td>\n<td>可選。向陣列新增的元素。</td>\n</tr>\n</tbody></table>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a><code>push()</code></h3><p>若只是需要將新元素插入到陣列的最後，直接使用 <code>push()</code>。</p>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a><code>slice()</code></h3><p>從陣列中複製一段內容，並回傳一個新陣列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.<span class=\"title function_\">slice</span>(start, end)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>參數</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>start</td>\n<td>為正／負整數，指定在陣列中開始操作的位置。</td>\n</tr>\n<tr>\n<td>end</td>\n<td>可選。提取片段的結尾位置，若有設定則提取到該位置的前一個元素，若不設定就會提取到最後。</td>\n</tr>\n</tbody></table>\n<h3 id=\"reverse-join\"><a href=\"#reverse-join\" class=\"headerlink\" title=\"reverse() join()\"></a><code>reverse()</code> <code>join()</code></h3><p>這兩個方法有時候會搭配使用，當你想要把一個字串內的每個字元反轉過來的時候，先使用字串的操作方法 <code>split()</code> 將其變成陣列，再做 <code>reverse()</code> 反轉每個元素，最後用 <code>join()</code> 再讓他變成一個字串。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.tutorialrepublic.com/javascript-reference/javascript-array-object.php\" >Tutorial Republic - JavaScript Array Methods<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E9%99%A3%E5%88%97%E7%9A%84%E9%81%8B%E7%94%A8\" >MDN - 陣列的運用<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.oxxostudio.tw/articles/201908/js-array.html\" >OXXO Studio - JavaScript Array 陣列操作方法大全 ( 含 ES6 )<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - Closure","date":"2019-09-17T08:43:24.000Z","_content":"面試以來常常碰到的一題，就是 `closure`。我知道中文叫閉包，但光看字面根本猜不出意思。為了加深對 `closure` 的印象，而整理了這篇筆記。\n<!--more-->\n\n---\n\n## 什麼是 Closure？\n\n> 閉包是函式以及該函式被宣告時所在的作用域環境。\n\n在讀到 MDN 為解釋閉包而舉的範例時，我產生了一個疑惑：巢狀函式可以取用上一層的變數，那是不是代表：**巢狀函式最內部的函式，也可以取用全域變數呢？**\n\n接著繼續往下讀，看到這段對作用域的說明：\n> 「作用域」一詞，指的正是作用域環境在程式碼指定變數時，使用 location 來決定該變數用在哪裡的事情。巢狀函式的內部函式，能訪問在該函式作用域之外的變數。\n\n為了驗證我的疑惑，我寫了一段簡單的 code：\n```javascript\nvar a = 123;\nfunction outside(){\n    console.log(\"from outside\", a)\n    return (function inside(){\n        console.log(\"from inside\", a)\n    })()\n}\noutside(); \n```\n得到的結果如下：\n```javascript\nfrom outside 123\nfrom inside 123\n```\n我得到的結論就是，閉包是一個封閉的環境，外部宣告的變數可以傳入使用，內部宣告的變數無法被外部使用。\n\n那麼再來的要問的就是，我什麼時候才會需要用到閉包？\n\n---\n\n## 閉包的使用時機？\n\n簡單地說，當我需要在**當某事發生時觸發某個 function**，那閉包就相當實用。在此之前我最常用的方法是為一個 DOM 元素綁定 `eventListener`，再去觸發一個單獨宣告的 function。\n\n這樣寫當然沒問題，不過若這個事件要觸發的內容需要多做一些運算，那可能就要宣告好幾個 function，除了要一直命名之外，四散的 code 也會增加除錯的複雜度（還有看 code 的爽度）。\n\n了解閉包的特性之後，感覺對 JS 的理解又更深一層了。\n\n---\n參考資料：\n* [MDN - 閉包](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures)\n* [胡立 - 所有的函式都是閉包：談 JS 中的作用域與 Closure](https://blog.techbridge.cc/2018/12/08/javascript-closure/)\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html)","source":"_posts/JS-closure.md","raw":"---\ntitle: JavaScript 學習筆記 - Closure\ndate: 2019-09-17 16:43:24\ntags: [JavaScript, closure]\n---\n面試以來常常碰到的一題，就是 `closure`。我知道中文叫閉包，但光看字面根本猜不出意思。為了加深對 `closure` 的印象，而整理了這篇筆記。\n<!--more-->\n\n---\n\n## 什麼是 Closure？\n\n> 閉包是函式以及該函式被宣告時所在的作用域環境。\n\n在讀到 MDN 為解釋閉包而舉的範例時，我產生了一個疑惑：巢狀函式可以取用上一層的變數，那是不是代表：**巢狀函式最內部的函式，也可以取用全域變數呢？**\n\n接著繼續往下讀，看到這段對作用域的說明：\n> 「作用域」一詞，指的正是作用域環境在程式碼指定變數時，使用 location 來決定該變數用在哪裡的事情。巢狀函式的內部函式，能訪問在該函式作用域之外的變數。\n\n為了驗證我的疑惑，我寫了一段簡單的 code：\n```javascript\nvar a = 123;\nfunction outside(){\n    console.log(\"from outside\", a)\n    return (function inside(){\n        console.log(\"from inside\", a)\n    })()\n}\noutside(); \n```\n得到的結果如下：\n```javascript\nfrom outside 123\nfrom inside 123\n```\n我得到的結論就是，閉包是一個封閉的環境，外部宣告的變數可以傳入使用，內部宣告的變數無法被外部使用。\n\n那麼再來的要問的就是，我什麼時候才會需要用到閉包？\n\n---\n\n## 閉包的使用時機？\n\n簡單地說，當我需要在**當某事發生時觸發某個 function**，那閉包就相當實用。在此之前我最常用的方法是為一個 DOM 元素綁定 `eventListener`，再去觸發一個單獨宣告的 function。\n\n這樣寫當然沒問題，不過若這個事件要觸發的內容需要多做一些運算，那可能就要宣告好幾個 function，除了要一直命名之外，四散的 code 也會增加除錯的複雜度（還有看 code 的爽度）。\n\n了解閉包的特性之後，感覺對 JS 的理解又更深一層了。\n\n---\n參考資料：\n* [MDN - 閉包](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures)\n* [胡立 - 所有的函式都是閉包：談 JS 中的作用域與 Closure](https://blog.techbridge.cc/2018/12/08/javascript-closure/)\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html)","slug":"JS-closure","published":1,"updated":"2022-03-12T12:58:20.203Z","_id":"cl0nussya000uz6us38za21pc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>面試以來常常碰到的一題，就是 <code>closure</code>。我知道中文叫閉包，但光看字面根本猜不出意思。為了加深對 <code>closure</code> 的印象，而整理了這篇筆記。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"什麼是-Closure？\"><a href=\"#什麼是-Closure？\" class=\"headerlink\" title=\"什麼是 Closure？\"></a>什麼是 Closure？</h2><blockquote>\n<p>閉包是函式以及該函式被宣告時所在的作用域環境。</p>\n</blockquote>\n<p>在讀到 MDN 為解釋閉包而舉的範例時，我產生了一個疑惑：巢狀函式可以取用上一層的變數，那是不是代表：<strong>巢狀函式最內部的函式，也可以取用全域變數呢？</strong></p>\n<p>接著繼續往下讀，看到這段對作用域的說明：</p>\n<blockquote>\n<p>「作用域」一詞，指的正是作用域環境在程式碼指定變數時，使用 location 來決定該變數用在哪裡的事情。巢狀函式的內部函式，能訪問在該函式作用域之外的變數。</p>\n</blockquote>\n<p>為了驗證我的疑惑，我寫了一段簡單的 code：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outside</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;from outside&quot;</span>, a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">function</span> <span class=\"title function_\">inside</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;from inside&quot;</span>, a)</span><br><span class=\"line\">    &#125;)()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">outside</span>(); </span><br></pre></td></tr></table></figure>\n<p>得到的結果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> outside <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> inside <span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n<p>我得到的結論就是，閉包是一個封閉的環境，外部宣告的變數可以傳入使用，內部宣告的變數無法被外部使用。</p>\n<p>那麼再來的要問的就是，我什麼時候才會需要用到閉包？</p>\n<hr>\n<h2 id=\"閉包的使用時機？\"><a href=\"#閉包的使用時機？\" class=\"headerlink\" title=\"閉包的使用時機？\"></a>閉包的使用時機？</h2><p>簡單地說，當我需要在<strong>當某事發生時觸發某個 function</strong>，那閉包就相當實用。在此之前我最常用的方法是為一個 DOM 元素綁定 <code>eventListener</code>，再去觸發一個單獨宣告的 function。</p>\n<p>這樣寫當然沒問題，不過若這個事件要觸發的內容需要多做一些運算，那可能就要宣告好幾個 function，除了要一直命名之外，四散的 code 也會增加除錯的複雜度（還有看 code 的爽度）。</p>\n<p>了解閉包的特性之後，感覺對 JS 的理解又更深一層了。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures\" >MDN - 閉包<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/12/08/javascript-closure/\" >胡立 - 所有的函式都是閉包：談 JS 中的作用域與 Closure<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>面試以來常常碰到的一題，就是 <code>closure</code>。我知道中文叫閉包，但光看字面根本猜不出意思。為了加深對 <code>closure</code> 的印象，而整理了這篇筆記。</p>","more":"<hr>\n<h2 id=\"什麼是-Closure？\"><a href=\"#什麼是-Closure？\" class=\"headerlink\" title=\"什麼是 Closure？\"></a>什麼是 Closure？</h2><blockquote>\n<p>閉包是函式以及該函式被宣告時所在的作用域環境。</p>\n</blockquote>\n<p>在讀到 MDN 為解釋閉包而舉的範例時，我產生了一個疑惑：巢狀函式可以取用上一層的變數，那是不是代表：<strong>巢狀函式最內部的函式，也可以取用全域變數呢？</strong></p>\n<p>接著繼續往下讀，看到這段對作用域的說明：</p>\n<blockquote>\n<p>「作用域」一詞，指的正是作用域環境在程式碼指定變數時，使用 location 來決定該變數用在哪裡的事情。巢狀函式的內部函式，能訪問在該函式作用域之外的變數。</p>\n</blockquote>\n<p>為了驗證我的疑惑，我寫了一段簡單的 code：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outside</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;from outside&quot;</span>, a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">function</span> <span class=\"title function_\">inside</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;from inside&quot;</span>, a)</span><br><span class=\"line\">    &#125;)()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">outside</span>(); </span><br></pre></td></tr></table></figure>\n<p>得到的結果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> outside <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> inside <span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n<p>我得到的結論就是，閉包是一個封閉的環境，外部宣告的變數可以傳入使用，內部宣告的變數無法被外部使用。</p>\n<p>那麼再來的要問的就是，我什麼時候才會需要用到閉包？</p>\n<hr>\n<h2 id=\"閉包的使用時機？\"><a href=\"#閉包的使用時機？\" class=\"headerlink\" title=\"閉包的使用時機？\"></a>閉包的使用時機？</h2><p>簡單地說，當我需要在<strong>當某事發生時觸發某個 function</strong>，那閉包就相當實用。在此之前我最常用的方法是為一個 DOM 元素綁定 <code>eventListener</code>，再去觸發一個單獨宣告的 function。</p>\n<p>這樣寫當然沒問題，不過若這個事件要觸發的內容需要多做一些運算，那可能就要宣告好幾個 function，除了要一直命名之外，四散的 code 也會增加除錯的複雜度（還有看 code 的爽度）。</p>\n<p>了解閉包的特性之後，感覺對 JS 的理解又更深一層了。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures\" >MDN - 閉包<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/12/08/javascript-closure/\" >胡立 - 所有的函式都是閉包：談 JS 中的作用域與 Closure<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - Prototype 與 Class","date":"2019-09-18T08:18:31.000Z","_content":"\n我認為這兩個概念放一起討論會比較好融會貫通，因此整理成同一篇。關於為什麼 JS 需要有繼承與原型鏈，網路上有很多文章在說明緣由，我就不再贅述了。\n<!--more-->\n\n---\n\n## 物件？類別？實例？\n\n首先，我們對 JS 的理解就是「這是一個物件導向的語言」。\n\n由於我是非本科，對物件導向的概念其實並不了解，因此看了一些文章之後，總結出下列定義：\n\n**「物件（Object）就是類別（Class）的實例（Instance）」**\n\n那麼問題來了。什麼是類別？什麼又是實例？\n\n### 類別（Class）與物件（Object）\n\n類別，是定義一件事物的抽象特點。\n\n例如定義一個「人的類別」，可能會有年齡、姓名、生日、身分證字號、聯絡電話、住址...等等特徵。\n\n物件，就是產生出一個符合這個類別的實例。\n\n例如：\n```javascript\n{\n    姓名： 小明,\n    年齡： 18,\n    聯絡電話： 0912345678,\n}\n```\n\n小明就可說是一個「人」的類別的實例。\n\n---\n\n## JavaScript 其實沒有真正的 `Class`\n\n這是一個有點令人混淆的觀念。我們既說 JS 是物件導向的語言，但他又沒有真正的 Class，那 JS 的物件到底是怎麼建立的？不是基於 Class 嗎？\n\n### JavaScript 的類別（Class）\n\n`Class` 其實是一種宣告函式的語法。但並不像函式一樣會 hoisting，因此順序很重要。若要使用 `Class` 來建立 `Object`，你需要先宣告 `Class`，才能取用他。下面這個例子就會拋出錯誤：\n```javascript\nvar p = new Person(); // ReferenceError\nclass Person {};\n```\n\n一個 `Class` 中只能有一個建構子（constructor），否則會報錯。`constructor` 是用來建立和初始化一個類別的物件。\n\n在 `Class` 中除了 `constructor` 之外，還可以宣告這個類別的 `methods`。例如我可以說：\n```javascript\nclass Person {\n    constructor(name, age){\n        this.name = name;\n        this.age - age;\n    }\n    talk() {\n        console.log('Hello! I'm ' + this.name);\n    }\n}\nvar ming = new Person('小明', 25); // 宣告一個叫小明的實例\n```\n\n但是正如前文提到的，`Class` 並不是真正的在宣告類別。以下引用自[Summer。桑莫。夏天](https://cythilya.github.io/2018/10/28/es6-class/)，說明 `Class` 的真相：\n> Class 依舊是利用 [[Prototype]] 委派機制來實作的，它只是個語法糖而已，也就是說，Class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結，因此若不小心變更了父類別的方法或屬性，子類別與其實體都會受到影響。\n\n既然知道了 `Class` 就是個方便宣告類別的工具之後，接著就要來理解 `prototype` 的概念了。\n\n---\n\n## JavaScript 的 `prototype`\n\n我讀到一個比較好理解 `prototype` 的說法。先回到 `Class`，假設你一次宣告了 10 個 `Person`，此時雖然他們的 `name` 與 `age` 都不同，但每個 `Person` 都有一個重複的 `talk()` method。這樣是不是有點佔用資源了？\n\n這時可以把 `talk()` 指定到 `Person.prototype` 上面，讓所有 `Person` 的 instance 都可以使用這個方法。\n\n從另一個角度來看，可以從 `Person.prototype` 去找到底下的 `Person`，這就是原型鏈的概念。\n\n## 什麼是 `__proto__` ？\n\n用結論來說，`__proto__` 就是 instance 往 parent 尋找的方法。\n\n例如尋找 `ming.__proto__`，就會找到 `Person`。\n\n---\n參考資料：\n* [物件導向(Object Oriented Programming)概念](https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6)\n* [MDN - 繼承與原型鏈](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n* [TechBridge 技術共筆部落格 - 該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/)\n* [JS原型鏈與繼承别再被問倒了](https://juejin.im/post/58f94c9bb123db411953691b)\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/prototype.html)\n* [你懂 JavaScript 嗎？#21 ES6 Class](https://cythilya.github.io/2018/10/28/es6-class/)","source":"_posts/JS-class-prototype.md","raw":"---\ntitle: JavaScript 學習筆記 - Prototype 與 Class\ndate: 2019-09-18 16:18:31\ntags: [JavaScript, class, prototype]\n---\n\n我認為這兩個概念放一起討論會比較好融會貫通，因此整理成同一篇。關於為什麼 JS 需要有繼承與原型鏈，網路上有很多文章在說明緣由，我就不再贅述了。\n<!--more-->\n\n---\n\n## 物件？類別？實例？\n\n首先，我們對 JS 的理解就是「這是一個物件導向的語言」。\n\n由於我是非本科，對物件導向的概念其實並不了解，因此看了一些文章之後，總結出下列定義：\n\n**「物件（Object）就是類別（Class）的實例（Instance）」**\n\n那麼問題來了。什麼是類別？什麼又是實例？\n\n### 類別（Class）與物件（Object）\n\n類別，是定義一件事物的抽象特點。\n\n例如定義一個「人的類別」，可能會有年齡、姓名、生日、身分證字號、聯絡電話、住址...等等特徵。\n\n物件，就是產生出一個符合這個類別的實例。\n\n例如：\n```javascript\n{\n    姓名： 小明,\n    年齡： 18,\n    聯絡電話： 0912345678,\n}\n```\n\n小明就可說是一個「人」的類別的實例。\n\n---\n\n## JavaScript 其實沒有真正的 `Class`\n\n這是一個有點令人混淆的觀念。我們既說 JS 是物件導向的語言，但他又沒有真正的 Class，那 JS 的物件到底是怎麼建立的？不是基於 Class 嗎？\n\n### JavaScript 的類別（Class）\n\n`Class` 其實是一種宣告函式的語法。但並不像函式一樣會 hoisting，因此順序很重要。若要使用 `Class` 來建立 `Object`，你需要先宣告 `Class`，才能取用他。下面這個例子就會拋出錯誤：\n```javascript\nvar p = new Person(); // ReferenceError\nclass Person {};\n```\n\n一個 `Class` 中只能有一個建構子（constructor），否則會報錯。`constructor` 是用來建立和初始化一個類別的物件。\n\n在 `Class` 中除了 `constructor` 之外，還可以宣告這個類別的 `methods`。例如我可以說：\n```javascript\nclass Person {\n    constructor(name, age){\n        this.name = name;\n        this.age - age;\n    }\n    talk() {\n        console.log('Hello! I'm ' + this.name);\n    }\n}\nvar ming = new Person('小明', 25); // 宣告一個叫小明的實例\n```\n\n但是正如前文提到的，`Class` 並不是真正的在宣告類別。以下引用自[Summer。桑莫。夏天](https://cythilya.github.io/2018/10/28/es6-class/)，說明 `Class` 的真相：\n> Class 依舊是利用 [[Prototype]] 委派機制來實作的，它只是個語法糖而已，也就是說，Class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結，因此若不小心變更了父類別的方法或屬性，子類別與其實體都會受到影響。\n\n既然知道了 `Class` 就是個方便宣告類別的工具之後，接著就要來理解 `prototype` 的概念了。\n\n---\n\n## JavaScript 的 `prototype`\n\n我讀到一個比較好理解 `prototype` 的說法。先回到 `Class`，假設你一次宣告了 10 個 `Person`，此時雖然他們的 `name` 與 `age` 都不同，但每個 `Person` 都有一個重複的 `talk()` method。這樣是不是有點佔用資源了？\n\n這時可以把 `talk()` 指定到 `Person.prototype` 上面，讓所有 `Person` 的 instance 都可以使用這個方法。\n\n從另一個角度來看，可以從 `Person.prototype` 去找到底下的 `Person`，這就是原型鏈的概念。\n\n## 什麼是 `__proto__` ？\n\n用結論來說，`__proto__` 就是 instance 往 parent 尋找的方法。\n\n例如尋找 `ming.__proto__`，就會找到 `Person`。\n\n---\n參考資料：\n* [物件導向(Object Oriented Programming)概念](https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6)\n* [MDN - 繼承與原型鏈](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n* [TechBridge 技術共筆部落格 - 該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/)\n* [JS原型鏈與繼承别再被問倒了](https://juejin.im/post/58f94c9bb123db411953691b)\n* [從ES6開始的JavaScript學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/prototype.html)\n* [你懂 JavaScript 嗎？#21 ES6 Class](https://cythilya.github.io/2018/10/28/es6-class/)","slug":"JS-class-prototype","published":1,"updated":"2022-03-12T12:58:20.126Z","_id":"cl0nussyb000vz6us4mo97wc5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我認為這兩個概念放一起討論會比較好融會貫通，因此整理成同一篇。關於為什麼 JS 需要有繼承與原型鏈，網路上有很多文章在說明緣由，我就不再贅述了。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"物件？類別？實例？\"><a href=\"#物件？類別？實例？\" class=\"headerlink\" title=\"物件？類別？實例？\"></a>物件？類別？實例？</h2><p>首先，我們對 JS 的理解就是「這是一個物件導向的語言」。</p>\n<p>由於我是非本科，對物件導向的概念其實並不了解，因此看了一些文章之後，總結出下列定義：</p>\n<p><strong>「物件（Object）就是類別（Class）的實例（Instance）」</strong></p>\n<p>那麼問題來了。什麼是類別？什麼又是實例？</p>\n<h3 id=\"類別（Class）與物件（Object）\"><a href=\"#類別（Class）與物件（Object）\" class=\"headerlink\" title=\"類別（Class）與物件（Object）\"></a>類別（Class）與物件（Object）</h3><p>類別，是定義一件事物的抽象特點。</p>\n<p>例如定義一個「人的類別」，可能會有年齡、姓名、生日、身分證字號、聯絡電話、住址…等等特徵。</p>\n<p>物件，就是產生出一個符合這個類別的實例。</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    姓名： 小明,</span><br><span class=\"line\">    年齡： <span class=\"number\">18</span>,</span><br><span class=\"line\">    聯絡電話： <span class=\"number\">0912345678</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小明就可說是一個「人」的類別的實例。</p>\n<hr>\n<h2 id=\"JavaScript-其實沒有真正的-Class\"><a href=\"#JavaScript-其實沒有真正的-Class\" class=\"headerlink\" title=\"JavaScript 其實沒有真正的 Class\"></a>JavaScript 其實沒有真正的 <code>Class</code></h2><p>這是一個有點令人混淆的觀念。我們既說 JS 是物件導向的語言，但他又沒有真正的 Class，那 JS 的物件到底是怎麼建立的？不是基於 Class 嗎？</p>\n<h3 id=\"JavaScript-的類別（Class）\"><a href=\"#JavaScript-的類別（Class）\" class=\"headerlink\" title=\"JavaScript 的類別（Class）\"></a>JavaScript 的類別（Class）</h3><p><code>Class</code> 其實是一種宣告函式的語法。但並不像函式一樣會 hoisting，因此順序很重要。若要使用 <code>Class</code> 來建立 <code>Object</code>，你需要先宣告 <code>Class</code>，才能取用他。下面這個例子就會拋出錯誤：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一個 <code>Class</code> 中只能有一個建構子（constructor），否則會報錯。<code>constructor</code> 是用來建立和初始化一個類別的物件。</p>\n<p>在 <code>Class</code> 中除了 <code>constructor</code> 之外，還可以宣告這個類別的 <code>methods</code>。例如我可以說：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> - age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">talk</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello! I&#x27;</span>m <span class=\"string\">&#x27; + this.name);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">var ming = new Person(&#x27;</span>小明<span class=\"string\">&#x27;, 25); // 宣告一個叫小明的實例</span></span><br></pre></td></tr></table></figure>\n\n<p>但是正如前文提到的，<code>Class</code> 並不是真正的在宣告類別。以下引用自<a class=\"link\"   href=\"https://cythilya.github.io/2018/10/28/es6-class/\" >Summer。桑莫。夏天<i class=\"fas fa-external-link-alt\"></i></a>，說明 <code>Class</code> 的真相：</p>\n<blockquote>\n<p>Class 依舊是利用 [[Prototype]] 委派機制來實作的，它只是個語法糖而已，也就是說，Class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結，因此若不小心變更了父類別的方法或屬性，子類別與其實體都會受到影響。</p>\n</blockquote>\n<p>既然知道了 <code>Class</code> 就是個方便宣告類別的工具之後，接著就要來理解 <code>prototype</code> 的概念了。</p>\n<hr>\n<h2 id=\"JavaScript-的-prototype\"><a href=\"#JavaScript-的-prototype\" class=\"headerlink\" title=\"JavaScript 的 prototype\"></a>JavaScript 的 <code>prototype</code></h2><p>我讀到一個比較好理解 <code>prototype</code> 的說法。先回到 <code>Class</code>，假設你一次宣告了 10 個 <code>Person</code>，此時雖然他們的 <code>name</code> 與 <code>age</code> 都不同，但每個 <code>Person</code> 都有一個重複的 <code>talk()</code> method。這樣是不是有點佔用資源了？</p>\n<p>這時可以把 <code>talk()</code> 指定到 <code>Person.prototype</code> 上面，讓所有 <code>Person</code> 的 instance 都可以使用這個方法。</p>\n<p>從另一個角度來看，可以從 <code>Person.prototype</code> 去找到底下的 <code>Person</code>，這就是原型鏈的概念。</p>\n<h2 id=\"什麼是-proto-？\"><a href=\"#什麼是-proto-？\" class=\"headerlink\" title=\"什麼是 __proto__ ？\"></a>什麼是 <code>__proto__</code> ？</h2><p>用結論來說，<code>__proto__</code> 就是 instance 往 parent 尋找的方法。</p>\n<p>例如尋找 <code>ming.__proto__</code>，就會找到 <code>Person</code>。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6\" >物件導向(Object Oriented Programming)概念<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" >MDN - 繼承與原型鏈<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/04/22/javascript-prototype/\" >TechBridge 技術共筆部落格 - 該來理解 JavaScript 的原型鍊了<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.im/post/58f94c9bb123db411953691b\" >JS原型鏈與繼承别再被問倒了<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/prototype.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://cythilya.github.io/2018/10/28/es6-class/\" >你懂 JavaScript 嗎？#21 ES6 Class<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>我認為這兩個概念放一起討論會比較好融會貫通，因此整理成同一篇。關於為什麼 JS 需要有繼承與原型鏈，網路上有很多文章在說明緣由，我就不再贅述了。</p>","more":"<hr>\n<h2 id=\"物件？類別？實例？\"><a href=\"#物件？類別？實例？\" class=\"headerlink\" title=\"物件？類別？實例？\"></a>物件？類別？實例？</h2><p>首先，我們對 JS 的理解就是「這是一個物件導向的語言」。</p>\n<p>由於我是非本科，對物件導向的概念其實並不了解，因此看了一些文章之後，總結出下列定義：</p>\n<p><strong>「物件（Object）就是類別（Class）的實例（Instance）」</strong></p>\n<p>那麼問題來了。什麼是類別？什麼又是實例？</p>\n<h3 id=\"類別（Class）與物件（Object）\"><a href=\"#類別（Class）與物件（Object）\" class=\"headerlink\" title=\"類別（Class）與物件（Object）\"></a>類別（Class）與物件（Object）</h3><p>類別，是定義一件事物的抽象特點。</p>\n<p>例如定義一個「人的類別」，可能會有年齡、姓名、生日、身分證字號、聯絡電話、住址…等等特徵。</p>\n<p>物件，就是產生出一個符合這個類別的實例。</p>\n<p>例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    姓名： 小明,</span><br><span class=\"line\">    年齡： <span class=\"number\">18</span>,</span><br><span class=\"line\">    聯絡電話： <span class=\"number\">0912345678</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小明就可說是一個「人」的類別的實例。</p>\n<hr>\n<h2 id=\"JavaScript-其實沒有真正的-Class\"><a href=\"#JavaScript-其實沒有真正的-Class\" class=\"headerlink\" title=\"JavaScript 其實沒有真正的 Class\"></a>JavaScript 其實沒有真正的 <code>Class</code></h2><p>這是一個有點令人混淆的觀念。我們既說 JS 是物件導向的語言，但他又沒有真正的 Class，那 JS 的物件到底是怎麼建立的？不是基於 Class 嗎？</p>\n<h3 id=\"JavaScript-的類別（Class）\"><a href=\"#JavaScript-的類別（Class）\" class=\"headerlink\" title=\"JavaScript 的類別（Class）\"></a>JavaScript 的類別（Class）</h3><p><code>Class</code> 其實是一種宣告函式的語法。但並不像函式一樣會 hoisting，因此順序很重要。若要使用 <code>Class</code> 來建立 <code>Object</code>，你需要先宣告 <code>Class</code>，才能取用他。下面這個例子就會拋出錯誤：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一個 <code>Class</code> 中只能有一個建構子（constructor），否則會報錯。<code>constructor</code> 是用來建立和初始化一個類別的物件。</p>\n<p>在 <code>Class</code> 中除了 <code>constructor</code> 之外，還可以宣告這個類別的 <code>methods</code>。例如我可以說：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> - age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">talk</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Hello! I&#x27;</span>m <span class=\"string\">&#x27; + this.name);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">var ming = new Person(&#x27;</span>小明<span class=\"string\">&#x27;, 25); // 宣告一個叫小明的實例</span></span><br></pre></td></tr></table></figure>\n\n<p>但是正如前文提到的，<code>Class</code> 並不是真正的在宣告類別。以下引用自<a class=\"link\"   href=\"https://cythilya.github.io/2018/10/28/es6-class/\" >Summer。桑莫。夏天<i class=\"fas fa-external-link-alt\"></i></a>，說明 <code>Class</code> 的真相：</p>\n<blockquote>\n<p>Class 依舊是利用 [[Prototype]] 委派機制來實作的，它只是個語法糖而已，也就是說，Class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結，因此若不小心變更了父類別的方法或屬性，子類別與其實體都會受到影響。</p>\n</blockquote>\n<p>既然知道了 <code>Class</code> 就是個方便宣告類別的工具之後，接著就要來理解 <code>prototype</code> 的概念了。</p>\n<hr>\n<h2 id=\"JavaScript-的-prototype\"><a href=\"#JavaScript-的-prototype\" class=\"headerlink\" title=\"JavaScript 的 prototype\"></a>JavaScript 的 <code>prototype</code></h2><p>我讀到一個比較好理解 <code>prototype</code> 的說法。先回到 <code>Class</code>，假設你一次宣告了 10 個 <code>Person</code>，此時雖然他們的 <code>name</code> 與 <code>age</code> 都不同，但每個 <code>Person</code> 都有一個重複的 <code>talk()</code> method。這樣是不是有點佔用資源了？</p>\n<p>這時可以把 <code>talk()</code> 指定到 <code>Person.prototype</code> 上面，讓所有 <code>Person</code> 的 instance 都可以使用這個方法。</p>\n<p>從另一個角度來看，可以從 <code>Person.prototype</code> 去找到底下的 <code>Person</code>，這就是原型鏈的概念。</p>\n<h2 id=\"什麼是-proto-？\"><a href=\"#什麼是-proto-？\" class=\"headerlink\" title=\"什麼是 __proto__ ？\"></a>什麼是 <code>__proto__</code> ？</h2><p>用結論來說，<code>__proto__</code> 就是 instance 往 parent 尋找的方法。</p>\n<p>例如尋找 <code>ming.__proto__</code>，就會找到 <code>Person</code>。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://medium.com/@totoroLiu/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-object-oriented-programming-%E6%A6%82%E5%BF%B5-5f205d437fd6\" >物件導向(Object Oriented Programming)概念<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" >MDN - 繼承與原型鏈<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/04/22/javascript-prototype/\" >TechBridge 技術共筆部落格 - 該來理解 JavaScript 的原型鍊了<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://juejin.im/post/58f94c9bb123db411953691b\" >JS原型鏈與繼承别再被問倒了<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/prototype.html\" >從ES6開始的JavaScript學習生活<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://cythilya.github.io/2018/10/28/es6-class/\" >你懂 JavaScript 嗎？#21 ES6 Class<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - ES5 vs ES6","date":"2019-09-12T07:36:26.000Z","_content":"學習 JavaScript 一段時間了，也逐漸熟悉各種語法的運用，覺得差不多可以更深一層地認識這個語言了。因此趁此機會，就來整理一篇筆記，探討 `ES5` 與 `ES6` 之間的差異。\n<!--more-->\n---\n\n*定義*\n---\n\n網路上對於 `ES5` `ES6` `ECMA2015` `ECMAScript` `JavaScript` 的定義眾說紛紜，剛接觸 JS 的時候我也看得一頭霧水。直到後來看到這篇文章，讓我在一團亂中理清了一絲思緒。\n> [一文讀懂 JavaScript 與 ECMAScript 的區別](https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript)\n\n根據上文，我可以清楚地定義，我想了解的是 `ES5(ECMA2009)` 與 `ES6(ECMA2015)` 之間的差異，也就是新版本究竟做了哪些改動。\n\n---\n*ES5 與 ES6*\n---\n首先是 JavaScript 的特性，也就是初學者(*也就是我)開始學習 JavaScript 時，最先學習到的基礎部分。這裡就不特別區分 ES5 才新增的語法了。\n\n* 變數宣告：`var`\n* 流程控制：`if...else` `for` `while` `switch`\n* 嚴格模式：`'Use Strict'` \n* 陣列操作：`every / some / forEach / filter / indexOf / map / reduce` ...等方法\n* 資料操作：`JSON.parse()` `JSON.stringify()`\n* `Object` 方法\n* 操作 `DOM` `BOM`\n\n再來是 ES6 新增的部分。\n\n* 變數宣告：`let` `const`\n* 字串模板：以 `` 包覆的 html 內容，動態內容則直接寫在 `${}` 內部\n* 解構賦植\n* 箭頭函示：`() => {}`\n* `Class`\n* `Modules`\n* `Promise`\n\n\n---\n*總結*\n---\n\nES6 新增的語法，目前使用得比較熟練、也明白特性的大概就變數宣告、箭頭函式、字串模板。其他的新語法，還有待練習。之後再來寫筆記整理對這些語法的認識吧。\n\n---\n#### 參考資料\n* [一文讀懂 JavaScript 與 ECMAScript 的區別](https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript)\n* [「譯」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎麼回事？](https://huangxuan.me/2015/09/22/js-version/)\n* [JavaScript、ES5和ES6的介绍和區别](http://caibaojian.com/toutiao/6864)","source":"_posts/JS-ES5-ES6.md","raw":"---\ntitle: JavaScript 學習筆記 - ES5 vs ES6\ndate: 2019-09-12 15:36:26\ntags: JavaScript\n---\n學習 JavaScript 一段時間了，也逐漸熟悉各種語法的運用，覺得差不多可以更深一層地認識這個語言了。因此趁此機會，就來整理一篇筆記，探討 `ES5` 與 `ES6` 之間的差異。\n<!--more-->\n---\n\n*定義*\n---\n\n網路上對於 `ES5` `ES6` `ECMA2015` `ECMAScript` `JavaScript` 的定義眾說紛紜，剛接觸 JS 的時候我也看得一頭霧水。直到後來看到這篇文章，讓我在一團亂中理清了一絲思緒。\n> [一文讀懂 JavaScript 與 ECMAScript 的區別](https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript)\n\n根據上文，我可以清楚地定義，我想了解的是 `ES5(ECMA2009)` 與 `ES6(ECMA2015)` 之間的差異，也就是新版本究竟做了哪些改動。\n\n---\n*ES5 與 ES6*\n---\n首先是 JavaScript 的特性，也就是初學者(*也就是我)開始學習 JavaScript 時，最先學習到的基礎部分。這裡就不特別區分 ES5 才新增的語法了。\n\n* 變數宣告：`var`\n* 流程控制：`if...else` `for` `while` `switch`\n* 嚴格模式：`'Use Strict'` \n* 陣列操作：`every / some / forEach / filter / indexOf / map / reduce` ...等方法\n* 資料操作：`JSON.parse()` `JSON.stringify()`\n* `Object` 方法\n* 操作 `DOM` `BOM`\n\n再來是 ES6 新增的部分。\n\n* 變數宣告：`let` `const`\n* 字串模板：以 `` 包覆的 html 內容，動態內容則直接寫在 `${}` 內部\n* 解構賦植\n* 箭頭函示：`() => {}`\n* `Class`\n* `Modules`\n* `Promise`\n\n\n---\n*總結*\n---\n\nES6 新增的語法，目前使用得比較熟練、也明白特性的大概就變數宣告、箭頭函式、字串模板。其他的新語法，還有待練習。之後再來寫筆記整理對這些語法的認識吧。\n\n---\n#### 參考資料\n* [一文讀懂 JavaScript 與 ECMAScript 的區別](https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript)\n* [「譯」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎麼回事？](https://huangxuan.me/2015/09/22/js-version/)\n* [JavaScript、ES5和ES6的介绍和區别](http://caibaojian.com/toutiao/6864)","slug":"JS-ES5-ES6","published":1,"updated":"2022-03-12T12:58:20.272Z","_id":"cl0nust130014z6us93q5e39b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>學習 JavaScript 一段時間了，也逐漸熟悉各種語法的運用，覺得差不多可以更深一層地認識這個語言了。因此趁此機會，就來整理一篇筆記，探討 <code>ES5</code> 與 <code>ES6</code> 之間的差異。</p>\n<span id=\"more\"></span>\n<hr>\n<h2 id=\"定義\"><a href=\"#定義\" class=\"headerlink\" title=\"定義\"></a><em>定義</em></h2><p>網路上對於 <code>ES5</code> <code>ES6</code> <code>ECMA2015</code> <code>ECMAScript</code> <code>JavaScript</code> 的定義眾說紛紜，剛接觸 JS 的時候我也看得一頭霧水。直到後來看到這篇文章，讓我在一團亂中理清了一絲思緒。</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript\" >一文讀懂 JavaScript 與 ECMAScript 的區別<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>根據上文，我可以清楚地定義，我想了解的是 <code>ES5(ECMA2009)</code> 與 <code>ES6(ECMA2015)</code> 之間的差異，也就是新版本究竟做了哪些改動。</p>\n<hr>\n<h2 id=\"ES5-與-ES6\"><a href=\"#ES5-與-ES6\" class=\"headerlink\" title=\"ES5 與 ES6\"></a><em>ES5 與 ES6</em></h2><p>首先是 JavaScript 的特性，也就是初學者(*也就是我)開始學習 JavaScript 時，最先學習到的基礎部分。這裡就不特別區分 ES5 才新增的語法了。</p>\n<ul>\n<li>變數宣告：<code>var</code></li>\n<li>流程控制：<code>if...else</code> <code>for</code> <code>while</code> <code>switch</code></li>\n<li>嚴格模式：<code>&#39;Use Strict&#39;</code> </li>\n<li>陣列操作：<code>every / some / forEach / filter / indexOf / map / reduce</code> …等方法</li>\n<li>資料操作：<code>JSON.parse()</code> <code>JSON.stringify()</code></li>\n<li><code>Object</code> 方法</li>\n<li>操作 <code>DOM</code> <code>BOM</code></li>\n</ul>\n<p>再來是 ES6 新增的部分。</p>\n<ul>\n<li>變數宣告：<code>let</code> <code>const</code></li>\n<li>字串模板：以 &#96;&#96; 包覆的 html 內容，動態內容則直接寫在 <code>$&#123;&#125;</code> 內部</li>\n<li>解構賦植</li>\n<li>箭頭函示：<code>() =&gt; &#123;&#125;</code></li>\n<li><code>Class</code></li>\n<li><code>Modules</code></li>\n<li><code>Promise</code></li>\n</ul>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a><em>總結</em></h2><p>ES6 新增的語法，目前使用得比較熟練、也明白特性的大概就變數宣告、箭頭函式、字串模板。其他的新語法，還有待練習。之後再來寫筆記整理對這些語法的認識吧。</p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript\" >一文讀懂 JavaScript 與 ECMAScript 的區別<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://huangxuan.me/2015/09/22/js-version/\" >「譯」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎麼回事？<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"http://caibaojian.com/toutiao/6864\" >JavaScript、ES5和ES6的介绍和區别<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>學習 JavaScript 一段時間了，也逐漸熟悉各種語法的運用，覺得差不多可以更深一層地認識這個語言了。因此趁此機會，就來整理一篇筆記，探討 <code>ES5</code> 與 <code>ES6</code> 之間的差異。</p>","more":"<hr>\n<h2 id=\"定義\"><a href=\"#定義\" class=\"headerlink\" title=\"定義\"></a><em>定義</em></h2><p>網路上對於 <code>ES5</code> <code>ES6</code> <code>ECMA2015</code> <code>ECMAScript</code> <code>JavaScript</code> 的定義眾說紛紜，剛接觸 JS 的時候我也看得一頭霧水。直到後來看到這篇文章，讓我在一團亂中理清了一絲思緒。</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript\" >一文讀懂 JavaScript 與 ECMAScript 的區別<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>根據上文，我可以清楚地定義，我想了解的是 <code>ES5(ECMA2009)</code> 與 <code>ES6(ECMA2015)</code> 之間的差異，也就是新版本究竟做了哪些改動。</p>\n<hr>\n<h2 id=\"ES5-與-ES6\"><a href=\"#ES5-與-ES6\" class=\"headerlink\" title=\"ES5 與 ES6\"></a><em>ES5 與 ES6</em></h2><p>首先是 JavaScript 的特性，也就是初學者(*也就是我)開始學習 JavaScript 時，最先學習到的基礎部分。這裡就不特別區分 ES5 才新增的語法了。</p>\n<ul>\n<li>變數宣告：<code>var</code></li>\n<li>流程控制：<code>if...else</code> <code>for</code> <code>while</code> <code>switch</code></li>\n<li>嚴格模式：<code>&#39;Use Strict&#39;</code> </li>\n<li>陣列操作：<code>every / some / forEach / filter / indexOf / map / reduce</code> …等方法</li>\n<li>資料操作：<code>JSON.parse()</code> <code>JSON.stringify()</code></li>\n<li><code>Object</code> 方法</li>\n<li>操作 <code>DOM</code> <code>BOM</code></li>\n</ul>\n<p>再來是 ES6 新增的部分。</p>\n<ul>\n<li>變數宣告：<code>let</code> <code>const</code></li>\n<li>字串模板：以 &#96;&#96; 包覆的 html 內容，動態內容則直接寫在 <code>$&#123;&#125;</code> 內部</li>\n<li>解構賦植</li>\n<li>箭頭函示：<code>() =&gt; &#123;&#125;</code></li>\n<li><code>Class</code></li>\n<li><code>Modules</code></li>\n<li><code>Promise</code></li>\n</ul>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a><em>總結</em></h2><p>ES6 新增的語法，目前使用得比較熟練、也明白特性的大概就變數宣告、箭頭函式、字串模板。其他的新語法，還有待練習。之後再來寫筆記整理對這些語法的認識吧。</p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://www.oschina.net/translate/whats-the-difference-between-javascript-and-ecmascript\" >一文讀懂 JavaScript 與 ECMAScript 的區別<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://huangxuan.me/2015/09/22/js-version/\" >「譯」ES5, ES6, ES2016, ES.Next: JavaScript 的版本是怎麼回事？<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"http://caibaojian.com/toutiao/6864\" >JavaScript、ES5和ES6的介绍和區别<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - XMLHttpRequest","date":"2019-09-12T07:32:11.000Z","_content":"學習程式以來碰到一個較難突破的關檻，就是「如何向 server 發送要求」。到目前為止常見的方法有三種：\n* 用 jQuery 實現\n* 用 fetch 實現\n* 用 axios 實現\n<!--more-->\n但我的想法是想先了解背後的運作原理，以及用原生 JS 如何實現，之後再去使用方便快速的方法。\n\n很多免費資源都可以在 YouTube 上搜尋到，例如這一個頻道： [Traversy Media](https://www.youtube.com/user/TechGuyWeb)，他在這支影片裡就帶著你用原生 JS 操作 XMLHttpRequest：[影片](https://www.youtube.com/watch?v=82hnvUYY6QA)\n\n\n---\n\n*XMLHttpRequest*\n---\n在了解如何操作之前，我想知道的是：\n**「什麼是 XMLHttpRequest？它是為了什麼目的而存在的？」**\n\n找了一些資料來看之後，這是定義：\n> **XMLHttp 是一組能被 web 瀏覽器內嵌的 script 語言呼叫的 API，通過 Http 在瀏覽器和 web 伺服器之間收發 XML 或其它資料。其最大的好處在於可以動態地更新網頁內容。**\n\n向伺服器發送一個 request，回傳資料後動態地更新網頁內容，對使用者而言，不用一直重複載入整個頁面，當然比較符合使用者體驗。\n\n同時，XMLHttpRequest 也是實現 AJAX 重要的一環，在使用 asyncronous（非同步）技術來要求資料後動態更新網頁內容，讓使用者不須等待資料全部載完，就能夠先瀏覽網頁的其他內容，UX 因此更上一層。\n\n但對現今的前端而言，AJAX 已經是必備技術，這也是我覺得必須盡快熟悉的原因。\n\n---\n\n*XMLHttpRequest 的屬性*\n---\n\n* `XMLHttpRequest.onreadystatechange`\n在 `readyState` 屬性之狀態改變時被呼叫，可用於監聽 request 請求狀態的改變。\n\n* `XMLHttpRequest.readyState`\n回傳一個 0~4 之間的整數值，每個值代表的意義如下：\n\n    |值|狀態|意義|\n    |-|-|-|\n    |0|`UNSENT`|客戶端已建立|\n    |1|`OPENED`|`open()` 方法已被呼叫|\n    |2|`HEADERS_RECEIVED`|`send()` 方法已被呼叫，且可取得 header 與狀態|\n    |3|`LOADING`|回應資料下載中，此時 responseText 會擁有部分資料|\n    |4|`DONE`|完成下載|\n    > 本表格節自 [MDN：XMLHttpRequest.readyState](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState)\n\n\n* `XMLHttpRequest.status`\n依據狀態不同，回傳介於 100~500 間的 HTTP status code，分別代表不同意義，例如代表成功回應的 `200 OK` 或廣為人知的錯誤 `404 Not Found`。\n    > 更多狀態代碼請參照 [MDN：HTTP status code](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status)\n\n* `XMLHttpRequest.responseText`\n回傳一個 DOMString，其內容為請求之回應的文字內容。如請求失敗或尚未發送，則為 null。若確定 responseText 為 JSON 格式，通常會接著做 `JSON.parse()` 並接著處理資料。\n\n---\n\n*如何發送 XMLHttpRequest*\n---\n假設要發送一個簡單的 XMLHttpRequest 向伺服器要求資料，需要做到以下幾點來確保能夠成功返回資料。\n* 建立一個 XMLHttpRequest\n* 定義請求的方法（`GET` `POST` `PUT` `DELETE`...）\n* 定義監聽流程\n* 送出請求\n\n用範例表示的話就是：\n```javascript\nlet myFunction = function() {\n\n    //創建 XMLHttpRequest\n    let xhr = new XMLHttpRequest();\n    \n    //定義送出要求的網址\n    let url = '<你想送出要求的網址>';\n    \n    //定義請求的方法\n    xhr.open('GET', url, true);\n    \n    //定義監聽流程（當 status 改變時呼叫）\n    xhr.onreadyStatusChange = function() {\n    \n        //顯示當前進度\n        console.log('readyState', xhr.readyState, 'status', xhr.status)\n        \n        //確定請求成功時執行以下動作\n        if ( xhr.status === 4 && xhr.readyState === 200 ) {\n            //你想對回傳資料做些什麼？\n            console.log(responseText);\n        }\n    }\n    //送出請求\n    xhr.send();\n}\n```\n\n以上就是我目前了解到的發送 XMLHttpRequest 流程，以及每一步的意義。當然請求方法不只一種，XMLHttpRequest 也不會這麼單純，還有更多的細節需要處理。不過這部分就留待之後遇到再來研究如何解決吧。\n\n---\n\n#### 參考資料\n* [維基百科：XMLHttpRequest](https://zh.wikipedia.org/wiki/XMLHttpRequest)\n* [MDN：XMLHttpRequest](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest)\n* [MDN：XMLHttpRequest.readyState](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState)\n* [MDN：HTTP status code](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status)","source":"_posts/JS-XMLHttpRequest.md","raw":"---\ntitle: JavaScript 學習筆記 - XMLHttpRequest\ndate: 2019-09-12 15:32:11\ntags: [JavaScript,XMLHttpRequest]\n---\n學習程式以來碰到一個較難突破的關檻，就是「如何向 server 發送要求」。到目前為止常見的方法有三種：\n* 用 jQuery 實現\n* 用 fetch 實現\n* 用 axios 實現\n<!--more-->\n但我的想法是想先了解背後的運作原理，以及用原生 JS 如何實現，之後再去使用方便快速的方法。\n\n很多免費資源都可以在 YouTube 上搜尋到，例如這一個頻道： [Traversy Media](https://www.youtube.com/user/TechGuyWeb)，他在這支影片裡就帶著你用原生 JS 操作 XMLHttpRequest：[影片](https://www.youtube.com/watch?v=82hnvUYY6QA)\n\n\n---\n\n*XMLHttpRequest*\n---\n在了解如何操作之前，我想知道的是：\n**「什麼是 XMLHttpRequest？它是為了什麼目的而存在的？」**\n\n找了一些資料來看之後，這是定義：\n> **XMLHttp 是一組能被 web 瀏覽器內嵌的 script 語言呼叫的 API，通過 Http 在瀏覽器和 web 伺服器之間收發 XML 或其它資料。其最大的好處在於可以動態地更新網頁內容。**\n\n向伺服器發送一個 request，回傳資料後動態地更新網頁內容，對使用者而言，不用一直重複載入整個頁面，當然比較符合使用者體驗。\n\n同時，XMLHttpRequest 也是實現 AJAX 重要的一環，在使用 asyncronous（非同步）技術來要求資料後動態更新網頁內容，讓使用者不須等待資料全部載完，就能夠先瀏覽網頁的其他內容，UX 因此更上一層。\n\n但對現今的前端而言，AJAX 已經是必備技術，這也是我覺得必須盡快熟悉的原因。\n\n---\n\n*XMLHttpRequest 的屬性*\n---\n\n* `XMLHttpRequest.onreadystatechange`\n在 `readyState` 屬性之狀態改變時被呼叫，可用於監聽 request 請求狀態的改變。\n\n* `XMLHttpRequest.readyState`\n回傳一個 0~4 之間的整數值，每個值代表的意義如下：\n\n    |值|狀態|意義|\n    |-|-|-|\n    |0|`UNSENT`|客戶端已建立|\n    |1|`OPENED`|`open()` 方法已被呼叫|\n    |2|`HEADERS_RECEIVED`|`send()` 方法已被呼叫，且可取得 header 與狀態|\n    |3|`LOADING`|回應資料下載中，此時 responseText 會擁有部分資料|\n    |4|`DONE`|完成下載|\n    > 本表格節自 [MDN：XMLHttpRequest.readyState](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState)\n\n\n* `XMLHttpRequest.status`\n依據狀態不同，回傳介於 100~500 間的 HTTP status code，分別代表不同意義，例如代表成功回應的 `200 OK` 或廣為人知的錯誤 `404 Not Found`。\n    > 更多狀態代碼請參照 [MDN：HTTP status code](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status)\n\n* `XMLHttpRequest.responseText`\n回傳一個 DOMString，其內容為請求之回應的文字內容。如請求失敗或尚未發送，則為 null。若確定 responseText 為 JSON 格式，通常會接著做 `JSON.parse()` 並接著處理資料。\n\n---\n\n*如何發送 XMLHttpRequest*\n---\n假設要發送一個簡單的 XMLHttpRequest 向伺服器要求資料，需要做到以下幾點來確保能夠成功返回資料。\n* 建立一個 XMLHttpRequest\n* 定義請求的方法（`GET` `POST` `PUT` `DELETE`...）\n* 定義監聽流程\n* 送出請求\n\n用範例表示的話就是：\n```javascript\nlet myFunction = function() {\n\n    //創建 XMLHttpRequest\n    let xhr = new XMLHttpRequest();\n    \n    //定義送出要求的網址\n    let url = '<你想送出要求的網址>';\n    \n    //定義請求的方法\n    xhr.open('GET', url, true);\n    \n    //定義監聽流程（當 status 改變時呼叫）\n    xhr.onreadyStatusChange = function() {\n    \n        //顯示當前進度\n        console.log('readyState', xhr.readyState, 'status', xhr.status)\n        \n        //確定請求成功時執行以下動作\n        if ( xhr.status === 4 && xhr.readyState === 200 ) {\n            //你想對回傳資料做些什麼？\n            console.log(responseText);\n        }\n    }\n    //送出請求\n    xhr.send();\n}\n```\n\n以上就是我目前了解到的發送 XMLHttpRequest 流程，以及每一步的意義。當然請求方法不只一種，XMLHttpRequest 也不會這麼單純，還有更多的細節需要處理。不過這部分就留待之後遇到再來研究如何解決吧。\n\n---\n\n#### 參考資料\n* [維基百科：XMLHttpRequest](https://zh.wikipedia.org/wiki/XMLHttpRequest)\n* [MDN：XMLHttpRequest](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest)\n* [MDN：XMLHttpRequest.readyState](https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState)\n* [MDN：HTTP status code](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status)","slug":"JS-XMLHttpRequest","published":1,"updated":"2022-03-12T12:58:20.397Z","_id":"cl0nust7b0016z6us7g9h6eox","comments":1,"layout":"post","photos":[],"link":"","content":"<p>學習程式以來碰到一個較難突破的關檻，就是「如何向 server 發送要求」。到目前為止常見的方法有三種：</p>\n<ul>\n<li>用 jQuery 實現</li>\n<li>用 fetch 實現</li>\n<li>用 axios 實現<span id=\"more\"></span>\n但我的想法是想先了解背後的運作原理，以及用原生 JS 如何實現，之後再去使用方便快速的方法。</li>\n</ul>\n<p>很多免費資源都可以在 YouTube 上搜尋到，例如這一個頻道： <a class=\"link\"   href=\"https://www.youtube.com/user/TechGuyWeb\" >Traversy Media<i class=\"fas fa-external-link-alt\"></i></a>，他在這支影片裡就帶著你用原生 JS 操作 XMLHttpRequest：<a class=\"link\"   href=\"https://www.youtube.com/watch?v=82hnvUYY6QA\" >影片<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><em>XMLHttpRequest</em></h2><p>在了解如何操作之前，我想知道的是：<br><strong>「什麼是 XMLHttpRequest？它是為了什麼目的而存在的？」</strong></p>\n<p>找了一些資料來看之後，這是定義：</p>\n<blockquote>\n<p><strong>XMLHttp 是一組能被 web 瀏覽器內嵌的 script 語言呼叫的 API，通過 Http 在瀏覽器和 web 伺服器之間收發 XML 或其它資料。其最大的好處在於可以動態地更新網頁內容。</strong></p>\n</blockquote>\n<p>向伺服器發送一個 request，回傳資料後動態地更新網頁內容，對使用者而言，不用一直重複載入整個頁面，當然比較符合使用者體驗。</p>\n<p>同時，XMLHttpRequest 也是實現 AJAX 重要的一環，在使用 asyncronous（非同步）技術來要求資料後動態更新網頁內容，讓使用者不須等待資料全部載完，就能夠先瀏覽網頁的其他內容，UX 因此更上一層。</p>\n<p>但對現今的前端而言，AJAX 已經是必備技術，這也是我覺得必須盡快熟悉的原因。</p>\n<hr>\n<h2 id=\"XMLHttpRequest-的屬性\"><a href=\"#XMLHttpRequest-的屬性\" class=\"headerlink\" title=\"XMLHttpRequest 的屬性\"></a><em>XMLHttpRequest 的屬性</em></h2><ul>\n<li><p><code>XMLHttpRequest.onreadystatechange</code><br>在 <code>readyState</code> 屬性之狀態改變時被呼叫，可用於監聽 request 請求狀態的改變。</p>\n</li>\n<li><p><code>XMLHttpRequest.readyState</code><br>回傳一個 0~4 之間的整數值，每個值代表的意義如下：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>狀態</th>\n<th>意義</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td><code>UNSENT</code></td>\n<td>客戶端已建立</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>OPENED</code></td>\n<td><code>open()</code> 方法已被呼叫</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>HEADERS_RECEIVED</code></td>\n<td><code>send()</code> 方法已被呼叫，且可取得 header 與狀態</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>LOADING</code></td>\n<td>回應資料下載中，此時 responseText 會擁有部分資料</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>DONE</code></td>\n<td>完成下載</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>本表格節自 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState\" >MDN：XMLHttpRequest.readyState<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n</li>\n<li><p><code>XMLHttpRequest.status</code><br>依據狀態不同，回傳介於 100~500 間的 HTTP status code，分別代表不同意義，例如代表成功回應的 <code>200 OK</code> 或廣為人知的錯誤 <code>404 Not Found</code>。</p>\n<blockquote>\n<p>更多狀態代碼請參照 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status\" >MDN：HTTP status code<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n</li>\n<li><p><code>XMLHttpRequest.responseText</code><br>回傳一個 DOMString，其內容為請求之回應的文字內容。如請求失敗或尚未發送，則為 null。若確定 responseText 為 JSON 格式，通常會接著做 <code>JSON.parse()</code> 並接著處理資料。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何發送-XMLHttpRequest\"><a href=\"#如何發送-XMLHttpRequest\" class=\"headerlink\" title=\"如何發送 XMLHttpRequest\"></a><em>如何發送 XMLHttpRequest</em></h2><p>假設要發送一個簡單的 XMLHttpRequest 向伺服器要求資料，需要做到以下幾點來確保能夠成功返回資料。</p>\n<ul>\n<li>建立一個 XMLHttpRequest</li>\n<li>定義請求的方法（<code>GET</code> <code>POST</code> <code>PUT</code> <code>DELETE</code>…）</li>\n<li>定義監聽流程</li>\n<li>送出請求</li>\n</ul>\n<p>用範例表示的話就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myFunction = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//創建 XMLHttpRequest</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義送出要求的網址</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;&lt;你想送出要求的網址&gt;&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義請求的方法</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;GET&#x27;</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義監聽流程（當 status 改變時呼叫）</span></span><br><span class=\"line\">    xhr.<span class=\"property\">onreadyStatusChange</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//顯示當前進度</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;readyState&#x27;</span>, xhr.<span class=\"property\">readyState</span>, <span class=\"string\">&#x27;status&#x27;</span>, xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//確定請求成功時執行以下動作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( xhr.<span class=\"property\">status</span> === <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">readyState</span> === <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//你想對回傳資料做些什麼？</span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responseText);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//送出請求</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我目前了解到的發送 XMLHttpRequest 流程，以及每一步的意義。當然請求方法不只一種，XMLHttpRequest 也不會這麼單純，還有更多的細節需要處理。不過這部分就留待之後遇到再來研究如何解決吧。</p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/XMLHttpRequest\" >維基百科：XMLHttpRequest<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest\" >MDN：XMLHttpRequest<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState\" >MDN：XMLHttpRequest.readyState<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status\" >MDN：HTTP status code<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>學習程式以來碰到一個較難突破的關檻，就是「如何向 server 發送要求」。到目前為止常見的方法有三種：</p>\n<ul>\n<li>用 jQuery 實現</li>\n<li>用 fetch 實現</li>\n<li>用 axios 實現","more":"但我的想法是想先了解背後的運作原理，以及用原生 JS 如何實現，之後再去使用方便快速的方法。</li>\n</ul>\n<p>很多免費資源都可以在 YouTube 上搜尋到，例如這一個頻道： <a class=\"link\"   href=\"https://www.youtube.com/user/TechGuyWeb\" >Traversy Media<i class=\"fas fa-external-link-alt\"></i></a>，他在這支影片裡就帶著你用原生 JS 操作 XMLHttpRequest：<a class=\"link\"   href=\"https://www.youtube.com/watch?v=82hnvUYY6QA\" >影片<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a><em>XMLHttpRequest</em></h2><p>在了解如何操作之前，我想知道的是：<br><strong>「什麼是 XMLHttpRequest？它是為了什麼目的而存在的？」</strong></p>\n<p>找了一些資料來看之後，這是定義：</p>\n<blockquote>\n<p><strong>XMLHttp 是一組能被 web 瀏覽器內嵌的 script 語言呼叫的 API，通過 Http 在瀏覽器和 web 伺服器之間收發 XML 或其它資料。其最大的好處在於可以動態地更新網頁內容。</strong></p>\n</blockquote>\n<p>向伺服器發送一個 request，回傳資料後動態地更新網頁內容，對使用者而言，不用一直重複載入整個頁面，當然比較符合使用者體驗。</p>\n<p>同時，XMLHttpRequest 也是實現 AJAX 重要的一環，在使用 asyncronous（非同步）技術來要求資料後動態更新網頁內容，讓使用者不須等待資料全部載完，就能夠先瀏覽網頁的其他內容，UX 因此更上一層。</p>\n<p>但對現今的前端而言，AJAX 已經是必備技術，這也是我覺得必須盡快熟悉的原因。</p>\n<hr>\n<h2 id=\"XMLHttpRequest-的屬性\"><a href=\"#XMLHttpRequest-的屬性\" class=\"headerlink\" title=\"XMLHttpRequest 的屬性\"></a><em>XMLHttpRequest 的屬性</em></h2><ul>\n<li><p><code>XMLHttpRequest.onreadystatechange</code><br>在 <code>readyState</code> 屬性之狀態改變時被呼叫，可用於監聽 request 請求狀態的改變。</p>\n</li>\n<li><p><code>XMLHttpRequest.readyState</code><br>回傳一個 0~4 之間的整數值，每個值代表的意義如下：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>狀態</th>\n<th>意義</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td><code>UNSENT</code></td>\n<td>客戶端已建立</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>OPENED</code></td>\n<td><code>open()</code> 方法已被呼叫</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>HEADERS_RECEIVED</code></td>\n<td><code>send()</code> 方法已被呼叫，且可取得 header 與狀態</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>LOADING</code></td>\n<td>回應資料下載中，此時 responseText 會擁有部分資料</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>DONE</code></td>\n<td>完成下載</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>本表格節自 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState\" >MDN：XMLHttpRequest.readyState<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n</li>\n<li><p><code>XMLHttpRequest.status</code><br>依據狀態不同，回傳介於 100~500 間的 HTTP status code，分別代表不同意義，例如代表成功回應的 <code>200 OK</code> 或廣為人知的錯誤 <code>404 Not Found</code>。</p>\n<blockquote>\n<p>更多狀態代碼請參照 <a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status\" >MDN：HTTP status code<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n</li>\n<li><p><code>XMLHttpRequest.responseText</code><br>回傳一個 DOMString，其內容為請求之回應的文字內容。如請求失敗或尚未發送，則為 null。若確定 responseText 為 JSON 格式，通常會接著做 <code>JSON.parse()</code> 並接著處理資料。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何發送-XMLHttpRequest\"><a href=\"#如何發送-XMLHttpRequest\" class=\"headerlink\" title=\"如何發送 XMLHttpRequest\"></a><em>如何發送 XMLHttpRequest</em></h2><p>假設要發送一個簡單的 XMLHttpRequest 向伺服器要求資料，需要做到以下幾點來確保能夠成功返回資料。</p>\n<ul>\n<li>建立一個 XMLHttpRequest</li>\n<li>定義請求的方法（<code>GET</code> <code>POST</code> <code>PUT</code> <code>DELETE</code>…）</li>\n<li>定義監聽流程</li>\n<li>送出請求</li>\n</ul>\n<p>用範例表示的話就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myFunction = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//創建 XMLHttpRequest</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義送出要求的網址</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = <span class=\"string\">&#x27;&lt;你想送出要求的網址&gt;&#x27;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義請求的方法</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&#x27;GET&#x27;</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//定義監聽流程（當 status 改變時呼叫）</span></span><br><span class=\"line\">    xhr.<span class=\"property\">onreadyStatusChange</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//顯示當前進度</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;readyState&#x27;</span>, xhr.<span class=\"property\">readyState</span>, <span class=\"string\">&#x27;status&#x27;</span>, xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//確定請求成功時執行以下動作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( xhr.<span class=\"property\">status</span> === <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">readyState</span> === <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//你想對回傳資料做些什麼？</span></span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responseText);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//送出請求</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我目前了解到的發送 XMLHttpRequest 流程，以及每一步的意義。當然請求方法不只一種，XMLHttpRequest 也不會這麼單純，還有更多的細節需要處理。不過這部分就留待之後遇到再來研究如何解決吧。</p>\n<hr>\n<h4 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h4><ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/XMLHttpRequest\" >維基百科：XMLHttpRequest<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest\" >MDN：XMLHttpRequest<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/XMLHttpRequest/readyState\" >MDN：XMLHttpRequest.readyState<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status\" >MDN：HTTP status code<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"JavaScript 學習筆記 - hoisting","date":"2019-09-15T13:57:53.000Z","_content":"\nJavaScript 這語言在某些時候並不是很嚴謹，所以特別去了解那些奇怪的部分，能夠大幅減少莫名其妙卡住的除錯時間。\n<!--more-->\n\n---\n\n## 什麼是 hoisting？\n\n我們都知道，JS 是一個單線程語言，這也就是說，瀏覽器在讀 code 時，是一行一行讀下來的。那麼：\n1. 宣告變數\n2. 使用變數\n\n按照邏輯，一定要按照這個順序，才能正常 working，對吧？舉個例子：\n```javascript\nvar a = 100;\nconsole.log(a); //100\n```\n\n那麼，這樣寫會印出什麼呢？\n```javascript\nconsole.log(a); //print?\nvar a = 100;\n```\n\n很簡單嘛！你說。根據你學過的 JS，這個變數還沒有被宣告，所以無法使用，所以會印出 `ReferenceError: a is not defined`。\n\n結果一打開 console，嚇死人了！居然跑出 `undefined`。這代表的是， `a` 這個變數已經被宣告了，但還沒有被賦值。沒有值這一點很容易理解，畢竟你在賦值以前就使用它嘛，這很正常。但變數宣告 `var a;` 的部分居然被提到前面來了！？\n\n這就是 `hoisting`，提升的概念。\n\n那麼，再進一步。不只變數會 `hoisting`，function 也會，而且 function 會優先於變數。用例子來看的話就是像這樣：\n```javascript\nconsole.log(a);\nvar a;\nfunction a(){}; \n```\n\nconsole 會印出什麼？\n答案是 `Function: a`。\n\n---\n\n## ES6 的 hoisting\n\n如果你跟我一樣，對 JavaScript 已經有一定熟悉度但還沒熟透，你可能會知道 ES6 新增的變數宣告方法 `let` 與 `const`，可能也會有個模糊的概念：這兩個宣告方法沒有 `hoisting`。\n\n我原本也是這樣想的，直到讀到這一篇文章：[TechBridge - 我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)\n\n> 這篇文章完整提到 (1)什麼是hoisting？ (2)為什麼我們需要 hoisting？ 以及 (3)hoisting是怎麼運作的？建議各位好好閱讀一下，真的可以理清很多事情。\n\n結果 `let` 跟 `const` 還是有 `hoisting` 的，只是行為跟 `var` 不同。\n\n---\n參考資料：\n* [TechBridge - 我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)\n* [MDN - Hoisting](https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting)\n* [JavaScript: 变量提升和函数提升](https://www.cnblogs.com/liuhe688/p/5891273.html)\n* [Hoisting in JavaScript](https://john-dugan.com/hoisting-in-javascript/)","source":"_posts/JS-hoisting.md","raw":"---\ntitle: JavaScript 學習筆記 - hoisting\ndate: 2019-09-15 21:57:53\ntags: [JavaScript, hoisting]\n---\n\nJavaScript 這語言在某些時候並不是很嚴謹，所以特別去了解那些奇怪的部分，能夠大幅減少莫名其妙卡住的除錯時間。\n<!--more-->\n\n---\n\n## 什麼是 hoisting？\n\n我們都知道，JS 是一個單線程語言，這也就是說，瀏覽器在讀 code 時，是一行一行讀下來的。那麼：\n1. 宣告變數\n2. 使用變數\n\n按照邏輯，一定要按照這個順序，才能正常 working，對吧？舉個例子：\n```javascript\nvar a = 100;\nconsole.log(a); //100\n```\n\n那麼，這樣寫會印出什麼呢？\n```javascript\nconsole.log(a); //print?\nvar a = 100;\n```\n\n很簡單嘛！你說。根據你學過的 JS，這個變數還沒有被宣告，所以無法使用，所以會印出 `ReferenceError: a is not defined`。\n\n結果一打開 console，嚇死人了！居然跑出 `undefined`。這代表的是， `a` 這個變數已經被宣告了，但還沒有被賦值。沒有值這一點很容易理解，畢竟你在賦值以前就使用它嘛，這很正常。但變數宣告 `var a;` 的部分居然被提到前面來了！？\n\n這就是 `hoisting`，提升的概念。\n\n那麼，再進一步。不只變數會 `hoisting`，function 也會，而且 function 會優先於變數。用例子來看的話就是像這樣：\n```javascript\nconsole.log(a);\nvar a;\nfunction a(){}; \n```\n\nconsole 會印出什麼？\n答案是 `Function: a`。\n\n---\n\n## ES6 的 hoisting\n\n如果你跟我一樣，對 JavaScript 已經有一定熟悉度但還沒熟透，你可能會知道 ES6 新增的變數宣告方法 `let` 與 `const`，可能也會有個模糊的概念：這兩個宣告方法沒有 `hoisting`。\n\n我原本也是這樣想的，直到讀到這一篇文章：[TechBridge - 我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)\n\n> 這篇文章完整提到 (1)什麼是hoisting？ (2)為什麼我們需要 hoisting？ 以及 (3)hoisting是怎麼運作的？建議各位好好閱讀一下，真的可以理清很多事情。\n\n結果 `let` 跟 `const` 還是有 `hoisting` 的，只是行為跟 `var` 不同。\n\n---\n參考資料：\n* [TechBridge - 我知道你懂 hoisting，可是你了解到多深？](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)\n* [MDN - Hoisting](https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting)\n* [JavaScript: 变量提升和函数提升](https://www.cnblogs.com/liuhe688/p/5891273.html)\n* [Hoisting in JavaScript](https://john-dugan.com/hoisting-in-javascript/)","slug":"JS-hoisting","published":1,"updated":"2022-03-12T12:58:20.326Z","_id":"cl0nust7b0017z6usb3an7wvz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JavaScript 這語言在某些時候並不是很嚴謹，所以特別去了解那些奇怪的部分，能夠大幅減少莫名其妙卡住的除錯時間。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"什麼是-hoisting？\"><a href=\"#什麼是-hoisting？\" class=\"headerlink\" title=\"什麼是 hoisting？\"></a>什麼是 hoisting？</h2><p>我們都知道，JS 是一個單線程語言，這也就是說，瀏覽器在讀 code 時，是一行一行讀下來的。那麼：</p>\n<ol>\n<li>宣告變數</li>\n<li>使用變數</li>\n</ol>\n<p>按照邏輯，一定要按照這個順序，才能正常 working，對吧？舉個例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure>\n\n<p>那麼，這樣寫會印出什麼呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">//print?</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很簡單嘛！你說。根據你學過的 JS，這個變數還沒有被宣告，所以無法使用，所以會印出 <code>ReferenceError: a is not defined</code>。</p>\n<p>結果一打開 console，嚇死人了！居然跑出 <code>undefined</code>。這代表的是， <code>a</code> 這個變數已經被宣告了，但還沒有被賦值。沒有值這一點很容易理解，畢竟你在賦值以前就使用它嘛，這很正常。但變數宣告 <code>var a;</code> 的部分居然被提到前面來了！？</p>\n<p>這就是 <code>hoisting</code>，提升的概念。</p>\n<p>那麼，再進一步。不只變數會 <code>hoisting</code>，function 也會，而且 function 會優先於變數。用例子來看的話就是像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123;&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>console 會印出什麼？<br>答案是 <code>Function: a</code>。</p>\n<hr>\n<h2 id=\"ES6-的-hoisting\"><a href=\"#ES6-的-hoisting\" class=\"headerlink\" title=\"ES6 的 hoisting\"></a>ES6 的 hoisting</h2><p>如果你跟我一樣，對 JavaScript 已經有一定熟悉度但還沒熟透，你可能會知道 ES6 新增的變數宣告方法 <code>let</code> 與 <code>const</code>，可能也會有個模糊的概念：這兩個宣告方法沒有 <code>hoisting</code>。</p>\n<p>我原本也是這樣想的，直到讀到這一篇文章：<a class=\"link\"   href=\"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/\" >TechBridge - 我知道你懂 hoisting，可是你了解到多深？<i class=\"fas fa-external-link-alt\"></i></a></p>\n<blockquote>\n<p>這篇文章完整提到 (1)什麼是hoisting？ (2)為什麼我們需要 hoisting？ 以及 (3)hoisting是怎麼運作的？建議各位好好閱讀一下，真的可以理清很多事情。</p>\n</blockquote>\n<p>結果 <code>let</code> 跟 <code>const</code> 還是有 <code>hoisting</code> 的，只是行為跟 <code>var</code> 不同。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/\" >TechBridge - 我知道你懂 hoisting，可是你了解到多深？<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting\" >MDN - Hoisting<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/liuhe688/p/5891273.html\" >JavaScript: 变量提升和函数提升<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://john-dugan.com/hoisting-in-javascript/\" >Hoisting in JavaScript<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>JavaScript 這語言在某些時候並不是很嚴謹，所以特別去了解那些奇怪的部分，能夠大幅減少莫名其妙卡住的除錯時間。</p>","more":"<hr>\n<h2 id=\"什麼是-hoisting？\"><a href=\"#什麼是-hoisting？\" class=\"headerlink\" title=\"什麼是 hoisting？\"></a>什麼是 hoisting？</h2><p>我們都知道，JS 是一個單線程語言，這也就是說，瀏覽器在讀 code 時，是一行一行讀下來的。那麼：</p>\n<ol>\n<li>宣告變數</li>\n<li>使用變數</li>\n</ol>\n<p>按照邏輯，一定要按照這個順序，才能正常 working，對吧？舉個例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure>\n\n<p>那麼，這樣寫會印出什麼呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">//print?</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很簡單嘛！你說。根據你學過的 JS，這個變數還沒有被宣告，所以無法使用，所以會印出 <code>ReferenceError: a is not defined</code>。</p>\n<p>結果一打開 console，嚇死人了！居然跑出 <code>undefined</code>。這代表的是， <code>a</code> 這個變數已經被宣告了，但還沒有被賦值。沒有值這一點很容易理解，畢竟你在賦值以前就使用它嘛，這很正常。但變數宣告 <code>var a;</code> 的部分居然被提到前面來了！？</p>\n<p>這就是 <code>hoisting</code>，提升的概念。</p>\n<p>那麼，再進一步。不只變數會 <code>hoisting</code>，function 也會，而且 function 會優先於變數。用例子來看的話就是像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123;&#125;; </span><br></pre></td></tr></table></figure>\n\n<p>console 會印出什麼？<br>答案是 <code>Function: a</code>。</p>\n<hr>\n<h2 id=\"ES6-的-hoisting\"><a href=\"#ES6-的-hoisting\" class=\"headerlink\" title=\"ES6 的 hoisting\"></a>ES6 的 hoisting</h2><p>如果你跟我一樣，對 JavaScript 已經有一定熟悉度但還沒熟透，你可能會知道 ES6 新增的變數宣告方法 <code>let</code> 與 <code>const</code>，可能也會有個模糊的概念：這兩個宣告方法沒有 <code>hoisting</code>。</p>\n<p>我原本也是這樣想的，直到讀到這一篇文章：<a class=\"link\"   href=\"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/\" >TechBridge - 我知道你懂 hoisting，可是你了解到多深？<i class=\"fas fa-external-link-alt\"></i></a></p>\n<blockquote>\n<p>這篇文章完整提到 (1)什麼是hoisting？ (2)為什麼我們需要 hoisting？ 以及 (3)hoisting是怎麼運作的？建議各位好好閱讀一下，真的可以理清很多事情。</p>\n</blockquote>\n<p>結果 <code>let</code> 跟 <code>const</code> 還是有 <code>hoisting</code> 的，只是行為跟 <code>var</code> 不同。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/\" >TechBridge - 我知道你懂 hoisting，可是你了解到多深？<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting\" >MDN - Hoisting<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.cnblogs.com/liuhe688/p/5891273.html\" >JavaScript: 变量提升和函数提升<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://john-dugan.com/hoisting-in-javascript/\" >Hoisting in JavaScript<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Linux 學習筆記 - Journalctl","_content":"`systemd` 裡，除了用來操作服務的 `systemctl` 指令，另外還有一個 `journalctl` 指令，能夠用各種方式查看服務執行的日誌。也就是說，這對於除錯也是很有幫助的。\n<!--more-->\n\n---\n## `journalctl` 指令\n\nJournalctl 指令的結構如下：\n```\n$ journalctl <條件篩選>\n```\n\n### 所有日誌\n```javascript\n// 顯示所有日誌（從最早的紀錄開始）\n$ journalctl\n\n// 反轉日誌的輸出順序（從最新的紀錄開始）\n$ journalctl -r\n// 或\n$ journalctl --reverse\n\n// 根據時間顯示日誌\n$ journalctl -S -U\n// 或\n$ journalctl --since= --until=\n```\n\n### 追蹤日誌\n```javascript\n// 顯示最新的日誌，並不斷顯示新產生的日誌\n$ journalctl -f\n// 或\n$ journalctl --follow\n```\n\n### 控制日誌格式\n\n* `short`：預設值，每條日誌佔一行\n* `verbose`：以結構化的格式顯示日誌\n* `json`：將日誌 json 化，每條日誌佔一行\n* `json-pretty`：將日誌 json 化，以人方便閱讀的方式排列\n* `cat`：顯示日誌內容，不包含任何數據\n\n```javascript\n// 控制日誌顯示的格式\n$ journalctl -o <格式選項>\n// 或\n$ journalctl --output=<格式選項>\n```\n\n### 以重要性顯示日誌\n\n* `0`：emerg\n* `1`：alert\n* `2`：crit\n* `3`：err\n* `4`：warning\n* `5`：notice\n* `6`：info\n* `7`：debug\n\n```javascript\n// 根據重要性等級顯示日誌\n$ journalctl -p\n// 或\n$ journalctl --priority=<等級範圍>\n```\n\n### 分頁功能\n```javascript\n// 在分頁中跳到日誌的底部\n$ journalctl -e\n// 或\n$ journalctl --pager-end\n\n// 不要分頁顯示日誌\n$ journalctl --no-pager\n```\n\n\n---\n參考資料：\n* [Ubuntu Manpage: journalctl](http://manpages.ubuntu.com/manpages/bionic/zh_TW/man1/journalctl.1.html)","source":"_posts/linux-journalctl.md","raw":"---\ntitle: Linux 學習筆記 - Journalctl\ntags: [Journalctl, Systemd, Linux]\n---\n`systemd` 裡，除了用來操作服務的 `systemctl` 指令，另外還有一個 `journalctl` 指令，能夠用各種方式查看服務執行的日誌。也就是說，這對於除錯也是很有幫助的。\n<!--more-->\n\n---\n## `journalctl` 指令\n\nJournalctl 指令的結構如下：\n```\n$ journalctl <條件篩選>\n```\n\n### 所有日誌\n```javascript\n// 顯示所有日誌（從最早的紀錄開始）\n$ journalctl\n\n// 反轉日誌的輸出順序（從最新的紀錄開始）\n$ journalctl -r\n// 或\n$ journalctl --reverse\n\n// 根據時間顯示日誌\n$ journalctl -S -U\n// 或\n$ journalctl --since= --until=\n```\n\n### 追蹤日誌\n```javascript\n// 顯示最新的日誌，並不斷顯示新產生的日誌\n$ journalctl -f\n// 或\n$ journalctl --follow\n```\n\n### 控制日誌格式\n\n* `short`：預設值，每條日誌佔一行\n* `verbose`：以結構化的格式顯示日誌\n* `json`：將日誌 json 化，每條日誌佔一行\n* `json-pretty`：將日誌 json 化，以人方便閱讀的方式排列\n* `cat`：顯示日誌內容，不包含任何數據\n\n```javascript\n// 控制日誌顯示的格式\n$ journalctl -o <格式選項>\n// 或\n$ journalctl --output=<格式選項>\n```\n\n### 以重要性顯示日誌\n\n* `0`：emerg\n* `1`：alert\n* `2`：crit\n* `3`：err\n* `4`：warning\n* `5`：notice\n* `6`：info\n* `7`：debug\n\n```javascript\n// 根據重要性等級顯示日誌\n$ journalctl -p\n// 或\n$ journalctl --priority=<等級範圍>\n```\n\n### 分頁功能\n```javascript\n// 在分頁中跳到日誌的底部\n$ journalctl -e\n// 或\n$ journalctl --pager-end\n\n// 不要分頁顯示日誌\n$ journalctl --no-pager\n```\n\n\n---\n參考資料：\n* [Ubuntu Manpage: journalctl](http://manpages.ubuntu.com/manpages/bionic/zh_TW/man1/journalctl.1.html)","slug":"linux-journalctl","published":1,"date":"2022-03-12T12:27:53.921Z","updated":"2022-03-12T12:58:20.445Z","_id":"cl0nust7f001ez6us549r0xr0","comments":1,"layout":"post","photos":[],"link":"","content":"<p><code>systemd</code> 裡，除了用來操作服務的 <code>systemctl</code> 指令，另外還有一個 <code>journalctl</code> 指令，能夠用各種方式查看服務執行的日誌。也就是說，這對於除錯也是很有幫助的。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"journalctl-指令\"><a href=\"#journalctl-指令\" class=\"headerlink\" title=\"journalctl 指令\"></a><code>journalctl</code> 指令</h2><p>Journalctl 指令的結構如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ journalctl &lt;條件篩選&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"所有日誌\"><a href=\"#所有日誌\" class=\"headerlink\" title=\"所有日誌\"></a>所有日誌</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顯示所有日誌（從最早的紀錄開始）</span></span><br><span class=\"line\">$ journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反轉日誌的輸出順序（從最新的紀錄開始）</span></span><br><span class=\"line\">$ journalctl -r</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --reverse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根據時間顯示日誌</span></span><br><span class=\"line\">$ journalctl -S -U</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --since= --until=</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"追蹤日誌\"><a href=\"#追蹤日誌\" class=\"headerlink\" title=\"追蹤日誌\"></a>追蹤日誌</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顯示最新的日誌，並不斷顯示新產生的日誌</span></span><br><span class=\"line\">$ journalctl -f</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --follow</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"控制日誌格式\"><a href=\"#控制日誌格式\" class=\"headerlink\" title=\"控制日誌格式\"></a>控制日誌格式</h3><ul>\n<li><code>short</code>：預設值，每條日誌佔一行</li>\n<li><code>verbose</code>：以結構化的格式顯示日誌</li>\n<li><code>json</code>：將日誌 json 化，每條日誌佔一行</li>\n<li><code>json-pretty</code>：將日誌 json 化，以人方便閱讀的方式排列</li>\n<li><code>cat</code>：顯示日誌內容，不包含任何數據</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 控制日誌顯示的格式</span></span><br><span class=\"line\">$ journalctl -o &lt;格式選項&gt;</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --output=&lt;格式選項&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"以重要性顯示日誌\"><a href=\"#以重要性顯示日誌\" class=\"headerlink\" title=\"以重要性顯示日誌\"></a>以重要性顯示日誌</h3><ul>\n<li><code>0</code>：emerg</li>\n<li><code>1</code>：alert</li>\n<li><code>2</code>：crit</li>\n<li><code>3</code>：err</li>\n<li><code>4</code>：warning</li>\n<li><code>5</code>：notice</li>\n<li><code>6</code>：info</li>\n<li><code>7</code>：debug</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根據重要性等級顯示日誌</span></span><br><span class=\"line\">$ journalctl -p</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --priority=&lt;等級範圍&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分頁功能\"><a href=\"#分頁功能\" class=\"headerlink\" title=\"分頁功能\"></a>分頁功能</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在分頁中跳到日誌的底部</span></span><br><span class=\"line\">$ journalctl -e</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --pager-end</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要分頁顯示日誌</span></span><br><span class=\"line\">$ journalctl --no-pager</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"http://manpages.ubuntu.com/manpages/bionic/zh_TW/man1/journalctl.1.html\" >Ubuntu Manpage: journalctl<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><code>systemd</code> 裡，除了用來操作服務的 <code>systemctl</code> 指令，另外還有一個 <code>journalctl</code> 指令，能夠用各種方式查看服務執行的日誌。也就是說，這對於除錯也是很有幫助的。</p>","more":"<hr>\n<h2 id=\"journalctl-指令\"><a href=\"#journalctl-指令\" class=\"headerlink\" title=\"journalctl 指令\"></a><code>journalctl</code> 指令</h2><p>Journalctl 指令的結構如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ journalctl &lt;條件篩選&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"所有日誌\"><a href=\"#所有日誌\" class=\"headerlink\" title=\"所有日誌\"></a>所有日誌</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顯示所有日誌（從最早的紀錄開始）</span></span><br><span class=\"line\">$ journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 反轉日誌的輸出順序（從最新的紀錄開始）</span></span><br><span class=\"line\">$ journalctl -r</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --reverse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根據時間顯示日誌</span></span><br><span class=\"line\">$ journalctl -S -U</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --since= --until=</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"追蹤日誌\"><a href=\"#追蹤日誌\" class=\"headerlink\" title=\"追蹤日誌\"></a>追蹤日誌</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顯示最新的日誌，並不斷顯示新產生的日誌</span></span><br><span class=\"line\">$ journalctl -f</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --follow</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"控制日誌格式\"><a href=\"#控制日誌格式\" class=\"headerlink\" title=\"控制日誌格式\"></a>控制日誌格式</h3><ul>\n<li><code>short</code>：預設值，每條日誌佔一行</li>\n<li><code>verbose</code>：以結構化的格式顯示日誌</li>\n<li><code>json</code>：將日誌 json 化，每條日誌佔一行</li>\n<li><code>json-pretty</code>：將日誌 json 化，以人方便閱讀的方式排列</li>\n<li><code>cat</code>：顯示日誌內容，不包含任何數據</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 控制日誌顯示的格式</span></span><br><span class=\"line\">$ journalctl -o &lt;格式選項&gt;</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --output=&lt;格式選項&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"以重要性顯示日誌\"><a href=\"#以重要性顯示日誌\" class=\"headerlink\" title=\"以重要性顯示日誌\"></a>以重要性顯示日誌</h3><ul>\n<li><code>0</code>：emerg</li>\n<li><code>1</code>：alert</li>\n<li><code>2</code>：crit</li>\n<li><code>3</code>：err</li>\n<li><code>4</code>：warning</li>\n<li><code>5</code>：notice</li>\n<li><code>6</code>：info</li>\n<li><code>7</code>：debug</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根據重要性等級顯示日誌</span></span><br><span class=\"line\">$ journalctl -p</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --priority=&lt;等級範圍&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分頁功能\"><a href=\"#分頁功能\" class=\"headerlink\" title=\"分頁功能\"></a>分頁功能</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在分頁中跳到日誌的底部</span></span><br><span class=\"line\">$ journalctl -e</span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\">$ journalctl --pager-end</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不要分頁顯示日誌</span></span><br><span class=\"line\">$ journalctl --no-pager</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"http://manpages.ubuntu.com/manpages/bionic/zh_TW/man1/journalctl.1.html\" >Ubuntu Manpage: journalctl<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Linux 學習筆記 - Systemd","_content":"\n有時難免會碰到網站掛掉，找到問題後發現是後端服務出錯的情況。身為純前端，這時通常會手足無措，因為必須等後端修復之後，才能回報 user。此時如果前端工程師能自行進入後端環境，做一些基本的偵錯處理，是否就能提升效率呢？\n\n<!--more-->\n\n---\n\n## 初步理解 Systemd\n\nSystemd 是一個 Linux 的系統與服務管理器。當你們家的網站是架設在 Linux 環境，最好還是熟悉一下 systemd 比較好。\n\n關於 Systemd 的一些粗淺整理：\n* 每一個系統服務稱為一個單元（unit）\n* Unit 有很多種類型：系統服務（`.service`）、掛載點（`.mount`）、sockets（`.sockets`） 、系統設備（`.device`）、交換分割區（`.swap`）、檔案路徑（`.path`）、啟動目標（`.target`）、由 systemd 管理的計時器（`.timer`）\n* 大部分的伺服器都屬於 `.service` 類型\n* 可使用 `systemctl` 指令管理各項單元\n* 所有可用單元的路徑如下：\n```\n// 軟體包安裝的單元\n/usr/lib/systemd/system/\n\n// 系統管理員安裝的單元（優先級更高）\n/etc/systemd/system/\n```\n\n---\n\n## `systemctl` 指令\n\nSystemctl 指令的結構如下：\n```\n$ systemctl 操作指令 <單元>\n```\n\n### 0. 分析系統狀態\n* <b>顯示系統狀態</b>\n```\n// 顯示系統狀態\n$ systemctl status\n\n// 顯示所有啟動中的單元\n$ systemctl\n// 或\n$ systemctl list-units\n\n// 顯示執行失敗的單元\n$ systemctl --failed\n```\n\n### 1. 啟動／停止單元\n\n* <b>啟動／停止單元</b>\n```\n// 啟動運行單元\n$ systemctl start <單元>\n\n// 停止運行單元\n$ systemctl stop <單元>\n\n// 重新啟動單元\n$ systemctl restart <單元>\n```\n\n\n### 2. 查找單元\n\n\n* <b>檢測系統單元狀態</b>\n```\n// 檢查單元狀態\n$ systemctl status <單元>\n\n// 檢查單元是否正在運行\n$ systemctl is-active <單元>\n\n// 檢查單元是否有設定開機自動啟動\n$ systemctl is-enabled <單元>\n\n// 檢查單元是否啟動失敗\n$ systemctl is-failed <單元>\n```\n\n* <b>列出單元</b>\n```\n// 列出所有單元（包含已啟動／未啟動）\n$ systemctl list-units --all\n\n// 列出所有已啟動的單元\n$ systemctl list-units\n\n// 列出所有未啟動的單元\n$ systemctl list-units --all --state=inactive\n\n// 只列出系統上所有 service type 的單元\n$ systemctl list-units --type=service\n```\n\n* <b>查看單元內部設定檔</b>\n```\n$ systemctl cat <單元>\n```\n\n### 3. 進一步設定單元\n\n* <b>啟用、停用開機自動啟動單元</b>\n```\n// 啟用開機自動啟動單元\n$ systemctl enable <單元>\n\n// 停用開機自動啟動單元\n$ systemctl disable <單元>\n```\n\n* <b>禁用特定單元</b>\n```\n// 禁用特定單元（禁用後就無法直接或間接啟動）\n$ systemctl mask <單元>\n\n// 取消禁用單元\n$ systemctl unmask <單元>\n```\n\n\n\n\n---\n參考資料：\n* [ArchLinux - systemd](https://wiki.archlinux.org/index.php/Systemd_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87))\n* [Linux命令大全 - systemctl命令](https://man.linuxde.net/systemctl)","source":"_posts/linux-systemctl.md","raw":"---\ntitle: Linux 學習筆記 - Systemd\ntags: [Systemctl, Systemd, Linux]\n---\n\n有時難免會碰到網站掛掉，找到問題後發現是後端服務出錯的情況。身為純前端，這時通常會手足無措，因為必須等後端修復之後，才能回報 user。此時如果前端工程師能自行進入後端環境，做一些基本的偵錯處理，是否就能提升效率呢？\n\n<!--more-->\n\n---\n\n## 初步理解 Systemd\n\nSystemd 是一個 Linux 的系統與服務管理器。當你們家的網站是架設在 Linux 環境，最好還是熟悉一下 systemd 比較好。\n\n關於 Systemd 的一些粗淺整理：\n* 每一個系統服務稱為一個單元（unit）\n* Unit 有很多種類型：系統服務（`.service`）、掛載點（`.mount`）、sockets（`.sockets`） 、系統設備（`.device`）、交換分割區（`.swap`）、檔案路徑（`.path`）、啟動目標（`.target`）、由 systemd 管理的計時器（`.timer`）\n* 大部分的伺服器都屬於 `.service` 類型\n* 可使用 `systemctl` 指令管理各項單元\n* 所有可用單元的路徑如下：\n```\n// 軟體包安裝的單元\n/usr/lib/systemd/system/\n\n// 系統管理員安裝的單元（優先級更高）\n/etc/systemd/system/\n```\n\n---\n\n## `systemctl` 指令\n\nSystemctl 指令的結構如下：\n```\n$ systemctl 操作指令 <單元>\n```\n\n### 0. 分析系統狀態\n* <b>顯示系統狀態</b>\n```\n// 顯示系統狀態\n$ systemctl status\n\n// 顯示所有啟動中的單元\n$ systemctl\n// 或\n$ systemctl list-units\n\n// 顯示執行失敗的單元\n$ systemctl --failed\n```\n\n### 1. 啟動／停止單元\n\n* <b>啟動／停止單元</b>\n```\n// 啟動運行單元\n$ systemctl start <單元>\n\n// 停止運行單元\n$ systemctl stop <單元>\n\n// 重新啟動單元\n$ systemctl restart <單元>\n```\n\n\n### 2. 查找單元\n\n\n* <b>檢測系統單元狀態</b>\n```\n// 檢查單元狀態\n$ systemctl status <單元>\n\n// 檢查單元是否正在運行\n$ systemctl is-active <單元>\n\n// 檢查單元是否有設定開機自動啟動\n$ systemctl is-enabled <單元>\n\n// 檢查單元是否啟動失敗\n$ systemctl is-failed <單元>\n```\n\n* <b>列出單元</b>\n```\n// 列出所有單元（包含已啟動／未啟動）\n$ systemctl list-units --all\n\n// 列出所有已啟動的單元\n$ systemctl list-units\n\n// 列出所有未啟動的單元\n$ systemctl list-units --all --state=inactive\n\n// 只列出系統上所有 service type 的單元\n$ systemctl list-units --type=service\n```\n\n* <b>查看單元內部設定檔</b>\n```\n$ systemctl cat <單元>\n```\n\n### 3. 進一步設定單元\n\n* <b>啟用、停用開機自動啟動單元</b>\n```\n// 啟用開機自動啟動單元\n$ systemctl enable <單元>\n\n// 停用開機自動啟動單元\n$ systemctl disable <單元>\n```\n\n* <b>禁用特定單元</b>\n```\n// 禁用特定單元（禁用後就無法直接或間接啟動）\n$ systemctl mask <單元>\n\n// 取消禁用單元\n$ systemctl unmask <單元>\n```\n\n\n\n\n---\n參考資料：\n* [ArchLinux - systemd](https://wiki.archlinux.org/index.php/Systemd_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87))\n* [Linux命令大全 - systemctl命令](https://man.linuxde.net/systemctl)","slug":"linux-systemctl","published":1,"date":"2022-03-12T12:27:53.922Z","updated":"2022-03-12T12:58:20.566Z","_id":"cl0nusta4001lz6us036z73bf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>有時難免會碰到網站掛掉，找到問題後發現是後端服務出錯的情況。身為純前端，這時通常會手足無措，因為必須等後端修復之後，才能回報 user。此時如果前端工程師能自行進入後端環境，做一些基本的偵錯處理，是否就能提升效率呢？</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"初步理解-Systemd\"><a href=\"#初步理解-Systemd\" class=\"headerlink\" title=\"初步理解 Systemd\"></a>初步理解 Systemd</h2><p>Systemd 是一個 Linux 的系統與服務管理器。當你們家的網站是架設在 Linux 環境，最好還是熟悉一下 systemd 比較好。</p>\n<p>關於 Systemd 的一些粗淺整理：</p>\n<ul>\n<li>每一個系統服務稱為一個單元（unit）</li>\n<li>Unit 有很多種類型：系統服務（<code>.service</code>）、掛載點（<code>.mount</code>）、sockets（<code>.sockets</code>） 、系統設備（<code>.device</code>）、交換分割區（<code>.swap</code>）、檔案路徑（<code>.path</code>）、啟動目標（<code>.target</code>）、由 systemd 管理的計時器（<code>.timer</code>）</li>\n<li>大部分的伺服器都屬於 <code>.service</code> 類型</li>\n<li>可使用 <code>systemctl</code> 指令管理各項單元</li>\n<li>所有可用單元的路徑如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 軟體包安裝的單元</span><br><span class=\"line\">/usr/lib/systemd/system/</span><br><span class=\"line\"></span><br><span class=\"line\">// 系統管理員安裝的單元（優先級更高）</span><br><span class=\"line\">/etc/systemd/system/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"systemctl-指令\"><a href=\"#systemctl-指令\" class=\"headerlink\" title=\"systemctl 指令\"></a><code>systemctl</code> 指令</h2><p>Systemctl 指令的結構如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl 操作指令 &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"0-分析系統狀態\"><a href=\"#0-分析系統狀態\" class=\"headerlink\" title=\"0. 分析系統狀態\"></a>0. 分析系統狀態</h3><ul>\n<li><b>顯示系統狀態</b><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 顯示系統狀態</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\">// 顯示所有啟動中的單元</span><br><span class=\"line\">$ systemctl</span><br><span class=\"line\">// 或</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\">// 顯示執行失敗的單元</span><br><span class=\"line\">$ systemctl --failed</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-啟動／停止單元\"><a href=\"#1-啟動／停止單元\" class=\"headerlink\" title=\"1. 啟動／停止單元\"></a>1. 啟動／停止單元</h3><ul>\n<li><b>啟動／停止單元</b><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 啟動運行單元</span><br><span class=\"line\">$ systemctl start &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 停止運行單元</span><br><span class=\"line\">$ systemctl stop &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 重新啟動單元</span><br><span class=\"line\">$ systemctl restart &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-查找單元\"><a href=\"#2-查找單元\" class=\"headerlink\" title=\"2. 查找單元\"></a>2. 查找單元</h3><ul>\n<li><p><b>檢測系統單元狀態</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 檢查單元狀態</span><br><span class=\"line\">$ systemctl status &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否正在運行</span><br><span class=\"line\">$ systemctl is-active &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否有設定開機自動啟動</span><br><span class=\"line\">$ systemctl is-enabled &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否啟動失敗</span><br><span class=\"line\">$ systemctl is-failed &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>列出單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 列出所有單元（包含已啟動／未啟動）</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\">// 列出所有已啟動的單元</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\">// 列出所有未啟動的單元</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\">// 只列出系統上所有 service type 的單元</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>查看單元內部設定檔</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl cat &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-進一步設定單元\"><a href=\"#3-進一步設定單元\" class=\"headerlink\" title=\"3. 進一步設定單元\"></a>3. 進一步設定單元</h3><ul>\n<li><p><b>啟用、停用開機自動啟動單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 啟用開機自動啟動單元</span><br><span class=\"line\">$ systemctl enable &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 停用開機自動啟動單元</span><br><span class=\"line\">$ systemctl disable &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>禁用特定單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 禁用特定單元（禁用後就無法直接或間接啟動）</span><br><span class=\"line\">$ systemctl mask &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 取消禁用單元</span><br><span class=\"line\">$ systemctl unmask &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://wiki.archlinux.org/index.php/Systemd_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)\" >ArchLinux - systemd<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://man.linuxde.net/systemctl\" >Linux命令大全 - systemctl命令<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>有時難免會碰到網站掛掉，找到問題後發現是後端服務出錯的情況。身為純前端，這時通常會手足無措，因為必須等後端修復之後，才能回報 user。此時如果前端工程師能自行進入後端環境，做一些基本的偵錯處理，是否就能提升效率呢？</p>","more":"<hr>\n<h2 id=\"初步理解-Systemd\"><a href=\"#初步理解-Systemd\" class=\"headerlink\" title=\"初步理解 Systemd\"></a>初步理解 Systemd</h2><p>Systemd 是一個 Linux 的系統與服務管理器。當你們家的網站是架設在 Linux 環境，最好還是熟悉一下 systemd 比較好。</p>\n<p>關於 Systemd 的一些粗淺整理：</p>\n<ul>\n<li>每一個系統服務稱為一個單元（unit）</li>\n<li>Unit 有很多種類型：系統服務（<code>.service</code>）、掛載點（<code>.mount</code>）、sockets（<code>.sockets</code>） 、系統設備（<code>.device</code>）、交換分割區（<code>.swap</code>）、檔案路徑（<code>.path</code>）、啟動目標（<code>.target</code>）、由 systemd 管理的計時器（<code>.timer</code>）</li>\n<li>大部分的伺服器都屬於 <code>.service</code> 類型</li>\n<li>可使用 <code>systemctl</code> 指令管理各項單元</li>\n<li>所有可用單元的路徑如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 軟體包安裝的單元</span><br><span class=\"line\">/usr/lib/systemd/system/</span><br><span class=\"line\"></span><br><span class=\"line\">// 系統管理員安裝的單元（優先級更高）</span><br><span class=\"line\">/etc/systemd/system/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"systemctl-指令\"><a href=\"#systemctl-指令\" class=\"headerlink\" title=\"systemctl 指令\"></a><code>systemctl</code> 指令</h2><p>Systemctl 指令的結構如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl 操作指令 &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"0-分析系統狀態\"><a href=\"#0-分析系統狀態\" class=\"headerlink\" title=\"0. 分析系統狀態\"></a>0. 分析系統狀態</h3><ul>\n<li><b>顯示系統狀態</b><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 顯示系統狀態</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\">// 顯示所有啟動中的單元</span><br><span class=\"line\">$ systemctl</span><br><span class=\"line\">// 或</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\">// 顯示執行失敗的單元</span><br><span class=\"line\">$ systemctl --failed</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-啟動／停止單元\"><a href=\"#1-啟動／停止單元\" class=\"headerlink\" title=\"1. 啟動／停止單元\"></a>1. 啟動／停止單元</h3><ul>\n<li><b>啟動／停止單元</b><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 啟動運行單元</span><br><span class=\"line\">$ systemctl start &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 停止運行單元</span><br><span class=\"line\">$ systemctl stop &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 重新啟動單元</span><br><span class=\"line\">$ systemctl restart &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-查找單元\"><a href=\"#2-查找單元\" class=\"headerlink\" title=\"2. 查找單元\"></a>2. 查找單元</h3><ul>\n<li><p><b>檢測系統單元狀態</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 檢查單元狀態</span><br><span class=\"line\">$ systemctl status &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否正在運行</span><br><span class=\"line\">$ systemctl is-active &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否有設定開機自動啟動</span><br><span class=\"line\">$ systemctl is-enabled &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 檢查單元是否啟動失敗</span><br><span class=\"line\">$ systemctl is-failed &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>列出單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 列出所有單元（包含已啟動／未啟動）</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\">// 列出所有已啟動的單元</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\">// 列出所有未啟動的單元</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\">// 只列出系統上所有 service type 的單元</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>查看單元內部設定檔</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl cat &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-進一步設定單元\"><a href=\"#3-進一步設定單元\" class=\"headerlink\" title=\"3. 進一步設定單元\"></a>3. 進一步設定單元</h3><ul>\n<li><p><b>啟用、停用開機自動啟動單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 啟用開機自動啟動單元</span><br><span class=\"line\">$ systemctl enable &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 停用開機自動啟動單元</span><br><span class=\"line\">$ systemctl disable &lt;單元&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><b>禁用特定單元</b></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 禁用特定單元（禁用後就無法直接或間接啟動）</span><br><span class=\"line\">$ systemctl mask &lt;單元&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 取消禁用單元</span><br><span class=\"line\">$ systemctl unmask &lt;單元&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://wiki.archlinux.org/index.php/Systemd_(%E6%AD%A3%E9%AB%94%E4%B8%AD%E6%96%87)\" >ArchLinux - systemd<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://man.linuxde.net/systemctl\" >Linux命令大全 - systemctl命令<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"使用 Hexo + Github 來架設個人部落格","date":"2019-06-25T12:28:29.000Z","_content":"最近強烈感受到寫技術筆記的需要，因此花費幾天的時間研究 Hexo，並且把這個站給架起來。雖然我本身也有其他的部落格，但程式還是歸程式，感覺比較能專心寫。\n<!--more-->\n*安裝 Hexo*\n---\n先確定有安裝 **node.js & git**，再依官網步驟安裝 **Hexo**。\n```javascript\n$ npm install -g hexo-cli\n ```\n在做上面這步驟時，我遇到權限不足的問題卡了很久，後來照以下步驟就解決了。雖然很多人推用 sudo 解決，但更多人建議不要使用 sudo，好像很容易造成不可挽回的錯誤，於是我就沒用了。\n\n[解法如下，來源請點此](https://github.com/hexojs/hexo/issues/2695)\n```javascript\n$ npm config set user 0\n$ npm config set unsafe-perm true\n$ npm install -g hexo-cli\n```\n就成功安裝 **Hexo** 了，真是可喜可賀！\n\n---\n\n*選擇主題 themes*\n---\n部落格最重要的門面，當然不能隨便決定啊！雖然要換很快啦，但我還是選了一陣子。最後決定使用滿多人使用的 **NexT**。\n\n[NexT 的官方 Github](https://github.com/theme-next/hexo-theme-next)\n\n輸入下面這行來把 **NexT** 資料搬下來：\n```javascript\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n就會自動下載主題並在 **themes** 資料夾底下創建 **next** 資料夾了，主題所需的東西都在裡面，接下來只要在 **_config.yml** 中將 **theme** 改為該主題名稱，像這樣：\n```javascript\ntheme: next\n```\n就可以成功套用主題了！嗚拉拉\n\n---\n\n*發佈一篇文章 Post*\n---\n### 一、確認 Hexo 已正確啟動\n```javascript\n$ hexo -v\n```\n如果有正確啟動 **Hexo**，會跑出版本說明，這時可以放心繼續下去。\n\n### 二、新增一個 post\n\n（一）新增發文\n```javascript\n$ hexo new \"new post name\"\n```\nnew post name 也可以是中文喔。\n\n會在 **source/_posts** 目錄底下新增一個 **日期_new_post_name.md** 文件，此時就可以進去編輯你的新文章了。\n\n（二）新增草稿\n```javascript\n$ hexo new draft \"new draft name\"\n```\n會在 **source/_drafts** 目錄底下新增一個 **日期_new_draft_name.md** 文件，寫完可以用這個命令來發佈：\n```javascript\n$ hexo publish [layout] <filemame>\n```\n（三）更新 **Hexo**\n\n上述兩步都只是在 **source** 資料夾中更新文章而已，你還需要這個步驟才能更新 **Hexo**：\n```javascript\n$ hexo generate  //或 hexo g\n```\n### 三、推上 github\n\n（一）更改 **_config.yml** 內容\n\n為了將 **Hexo** 與 **Github** 連結起來，你需要在 **_config.yml** 中填入相關資料。\n\n```javascript\nurl: https://<你的 github name>.github.io/<你的 repository name>/\nroot: /<你的 repository name>/\n```\n```javascript\ndeploy:\n  type: git\n  repo: <你的 repository url>\n```\n（二）安裝 **Hexo-git-deployer**\n\n```javascript\n$ npm install hexo-deployer-git --save\n```\n\n（三）執行部署\n\n以下三種命令都會將 **Hexo** 部署上去，其中的 **generate** 就是直接幫你把更新 **Hexo** 也一併做了。\n\n```javascript\n$ hexo deploy --generate\n```\n```javascript\n$ heso generate --deploy\n```\n```javascript\n$ hexo g -d\n```\n\n---\n\n關於個人部落格的架設就寫到這邊，算是流程的紀錄，也希望之後能幫到遇到一樣的問題的人，感覺 **Hexo** 還有很多坑等著讓人踩啊。","source":"_posts/myblog-with-hexo.md","raw":"---\ntitle: 使用 Hexo + Github 來架設個人部落格\ndate: 2019-06-25 20:28:29\ntags: hexo\n---\n最近強烈感受到寫技術筆記的需要，因此花費幾天的時間研究 Hexo，並且把這個站給架起來。雖然我本身也有其他的部落格，但程式還是歸程式，感覺比較能專心寫。\n<!--more-->\n*安裝 Hexo*\n---\n先確定有安裝 **node.js & git**，再依官網步驟安裝 **Hexo**。\n```javascript\n$ npm install -g hexo-cli\n ```\n在做上面這步驟時，我遇到權限不足的問題卡了很久，後來照以下步驟就解決了。雖然很多人推用 sudo 解決，但更多人建議不要使用 sudo，好像很容易造成不可挽回的錯誤，於是我就沒用了。\n\n[解法如下，來源請點此](https://github.com/hexojs/hexo/issues/2695)\n```javascript\n$ npm config set user 0\n$ npm config set unsafe-perm true\n$ npm install -g hexo-cli\n```\n就成功安裝 **Hexo** 了，真是可喜可賀！\n\n---\n\n*選擇主題 themes*\n---\n部落格最重要的門面，當然不能隨便決定啊！雖然要換很快啦，但我還是選了一陣子。最後決定使用滿多人使用的 **NexT**。\n\n[NexT 的官方 Github](https://github.com/theme-next/hexo-theme-next)\n\n輸入下面這行來把 **NexT** 資料搬下來：\n```javascript\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n就會自動下載主題並在 **themes** 資料夾底下創建 **next** 資料夾了，主題所需的東西都在裡面，接下來只要在 **_config.yml** 中將 **theme** 改為該主題名稱，像這樣：\n```javascript\ntheme: next\n```\n就可以成功套用主題了！嗚拉拉\n\n---\n\n*發佈一篇文章 Post*\n---\n### 一、確認 Hexo 已正確啟動\n```javascript\n$ hexo -v\n```\n如果有正確啟動 **Hexo**，會跑出版本說明，這時可以放心繼續下去。\n\n### 二、新增一個 post\n\n（一）新增發文\n```javascript\n$ hexo new \"new post name\"\n```\nnew post name 也可以是中文喔。\n\n會在 **source/_posts** 目錄底下新增一個 **日期_new_post_name.md** 文件，此時就可以進去編輯你的新文章了。\n\n（二）新增草稿\n```javascript\n$ hexo new draft \"new draft name\"\n```\n會在 **source/_drafts** 目錄底下新增一個 **日期_new_draft_name.md** 文件，寫完可以用這個命令來發佈：\n```javascript\n$ hexo publish [layout] <filemame>\n```\n（三）更新 **Hexo**\n\n上述兩步都只是在 **source** 資料夾中更新文章而已，你還需要這個步驟才能更新 **Hexo**：\n```javascript\n$ hexo generate  //或 hexo g\n```\n### 三、推上 github\n\n（一）更改 **_config.yml** 內容\n\n為了將 **Hexo** 與 **Github** 連結起來，你需要在 **_config.yml** 中填入相關資料。\n\n```javascript\nurl: https://<你的 github name>.github.io/<你的 repository name>/\nroot: /<你的 repository name>/\n```\n```javascript\ndeploy:\n  type: git\n  repo: <你的 repository url>\n```\n（二）安裝 **Hexo-git-deployer**\n\n```javascript\n$ npm install hexo-deployer-git --save\n```\n\n（三）執行部署\n\n以下三種命令都會將 **Hexo** 部署上去，其中的 **generate** 就是直接幫你把更新 **Hexo** 也一併做了。\n\n```javascript\n$ hexo deploy --generate\n```\n```javascript\n$ heso generate --deploy\n```\n```javascript\n$ hexo g -d\n```\n\n---\n\n關於個人部落格的架設就寫到這邊，算是流程的紀錄，也希望之後能幫到遇到一樣的問題的人，感覺 **Hexo** 還有很多坑等著讓人踩啊。","slug":"myblog-with-hexo","published":1,"updated":"2022-03-12T12:58:20.724Z","_id":"cl0nustcy001qz6us1p012ul6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近強烈感受到寫技術筆記的需要，因此花費幾天的時間研究 Hexo，並且把這個站給架起來。雖然我本身也有其他的部落格，但程式還是歸程式，感覺比較能專心寫。</p>\n<span id=\"more\"></span>\n<h2 id=\"安裝-Hexo\"><a href=\"#安裝-Hexo\" class=\"headerlink\" title=\"安裝 Hexo\"></a><em>安裝 Hexo</em></h2><p>先確定有安裝 <strong>node.js &amp; git</strong>，再依官網步驟安裝 <strong>Hexo</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>在做上面這步驟時，我遇到權限不足的問題卡了很久，後來照以下步驟就解決了。雖然很多人推用 sudo 解決，但更多人建議不要使用 sudo，好像很容易造成不可挽回的錯誤，於是我就沒用了。</p>\n<p><a class=\"link\"   href=\"https://github.com/hexojs/hexo/issues/2695\" >解法如下，來源請點此<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set user <span class=\"number\">0</span></span><br><span class=\"line\">$ npm config set unsafe-perm <span class=\"literal\">true</span></span><br><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>就成功安裝 <strong>Hexo</strong> 了，真是可喜可賀！</p>\n<hr>\n<h2 id=\"選擇主題-themes\"><a href=\"#選擇主題-themes\" class=\"headerlink\" title=\"選擇主題 themes\"></a><em>選擇主題 themes</em></h2><p>部落格最重要的門面，當然不能隨便決定啊！雖然要換很快啦，但我還是選了一陣子。最後決定使用滿多人使用的 <strong>NexT</strong>。</p>\n<p><a class=\"link\"   href=\"https://github.com/theme-next/hexo-theme-next\" >NexT 的官方 Github<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p>輸入下面這行來把 <strong>NexT</strong> 資料搬下來：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone <span class=\"attr\">https</span>:<span class=\"comment\">//github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>\n<p>就會自動下載主題並在 <strong>themes</strong> 資料夾底下創建 <strong>next</strong> 資料夾了，主題所需的東西都在裡面，接下來只要在 <strong>_config.yml</strong> 中將 <strong>theme</strong> 改為該主題名稱，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme</span>: next</span><br></pre></td></tr></table></figure>\n<p>就可以成功套用主題了！嗚拉拉</p>\n<hr>\n<h2 id=\"發佈一篇文章-Post\"><a href=\"#發佈一篇文章-Post\" class=\"headerlink\" title=\"發佈一篇文章 Post\"></a><em>發佈一篇文章 Post</em></h2><h3 id=\"一、確認-Hexo-已正確啟動\"><a href=\"#一、確認-Hexo-已正確啟動\" class=\"headerlink\" title=\"一、確認 Hexo 已正確啟動\"></a>一、確認 Hexo 已正確啟動</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<p>如果有正確啟動 <strong>Hexo</strong>，會跑出版本說明，這時可以放心繼續下去。</p>\n<h3 id=\"二、新增一個-post\"><a href=\"#二、新增一個-post\" class=\"headerlink\" title=\"二、新增一個 post\"></a>二、新增一個 post</h3><p>（一）新增發文</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> <span class=\"string\">&quot;new post name&quot;</span></span><br></pre></td></tr></table></figure>\n<p>new post name 也可以是中文喔。</p>\n<p>會在 <strong>source&#x2F;_posts</strong> 目錄底下新增一個 <strong>日期_new_post_name.md</strong> 文件，此時就可以進去編輯你的新文章了。</p>\n<p>（二）新增草稿</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> draft <span class=\"string\">&quot;new draft name&quot;</span></span><br></pre></td></tr></table></figure>\n<p>會在 <strong>source&#x2F;_drafts</strong> 目錄底下新增一個 <strong>日期_new_draft_name.md</strong> 文件，寫完可以用這個命令來發佈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filemame&gt;</span><br></pre></td></tr></table></figure>\n<p>（三）更新 <strong>Hexo</strong></p>\n<p>上述兩步都只是在 <strong>source</strong> 資料夾中更新文章而已，你還需要這個步驟才能更新 <strong>Hexo</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate  <span class=\"comment\">//或 hexo g</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三、推上-github\"><a href=\"#三、推上-github\" class=\"headerlink\" title=\"三、推上 github\"></a>三、推上 github</h3><p>（一）更改 <strong>_config.yml</strong> 內容</p>\n<p>為了將 <strong>Hexo</strong> 與 <strong>Github</strong> 連結起來，你需要在 <strong>_config.yml</strong> 中填入相關資料。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">url</span>: <span class=\"attr\">https</span>:<span class=\"comment\">//&lt;你的 github name&gt;.github.io/&lt;你的 repository name&gt;/</span></span><br><span class=\"line\"><span class=\"attr\">root</span>: <span class=\"regexp\">/&lt;你的 repository name&gt;/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attr\">type</span>: git</span><br><span class=\"line\">  <span class=\"attr\">repo</span>: &lt;你的 repository url&gt;</span><br></pre></td></tr></table></figure>\n<p>（二）安裝 <strong>Hexo-git-deployer</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>（三）執行部署</p>\n<p>以下三種命令都會將 <strong>Hexo</strong> 部署上去，其中的 <strong>generate</strong> 就是直接幫你把更新 <strong>Hexo</strong> 也一併做了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy --generate</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ heso generate --deploy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>關於個人部落格的架設就寫到這邊，算是流程的紀錄，也希望之後能幫到遇到一樣的問題的人，感覺 <strong>Hexo</strong> 還有很多坑等著讓人踩啊。</p>\n","site":{"data":{}},"excerpt":"<p>最近強烈感受到寫技術筆記的需要，因此花費幾天的時間研究 Hexo，並且把這個站給架起來。雖然我本身也有其他的部落格，但程式還是歸程式，感覺比較能專心寫。</p>","more":"<h2 id=\"安裝-Hexo\"><a href=\"#安裝-Hexo\" class=\"headerlink\" title=\"安裝 Hexo\"></a><em>安裝 Hexo</em></h2><p>先確定有安裝 <strong>node.js &amp; git</strong>，再依官網步驟安裝 <strong>Hexo</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>在做上面這步驟時，我遇到權限不足的問題卡了很久，後來照以下步驟就解決了。雖然很多人推用 sudo 解決，但更多人建議不要使用 sudo，好像很容易造成不可挽回的錯誤，於是我就沒用了。</p>\n<p><a class=\"link\"   href=\"https://github.com/hexojs/hexo/issues/2695\" >解法如下，來源請點此<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm config set user <span class=\"number\">0</span></span><br><span class=\"line\">$ npm config set unsafe-perm <span class=\"literal\">true</span></span><br><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>就成功安裝 <strong>Hexo</strong> 了，真是可喜可賀！</p>\n<hr>\n<h2 id=\"選擇主題-themes\"><a href=\"#選擇主題-themes\" class=\"headerlink\" title=\"選擇主題 themes\"></a><em>選擇主題 themes</em></h2><p>部落格最重要的門面，當然不能隨便決定啊！雖然要換很快啦，但我還是選了一陣子。最後決定使用滿多人使用的 <strong>NexT</strong>。</p>\n<p><a class=\"link\"   href=\"https://github.com/theme-next/hexo-theme-next\" >NexT 的官方 Github<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p>輸入下面這行來把 <strong>NexT</strong> 資料搬下來：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone <span class=\"attr\">https</span>:<span class=\"comment\">//github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>\n<p>就會自動下載主題並在 <strong>themes</strong> 資料夾底下創建 <strong>next</strong> 資料夾了，主題所需的東西都在裡面，接下來只要在 <strong>_config.yml</strong> 中將 <strong>theme</strong> 改為該主題名稱，像這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme</span>: next</span><br></pre></td></tr></table></figure>\n<p>就可以成功套用主題了！嗚拉拉</p>\n<hr>\n<h2 id=\"發佈一篇文章-Post\"><a href=\"#發佈一篇文章-Post\" class=\"headerlink\" title=\"發佈一篇文章 Post\"></a><em>發佈一篇文章 Post</em></h2><h3 id=\"一、確認-Hexo-已正確啟動\"><a href=\"#一、確認-Hexo-已正確啟動\" class=\"headerlink\" title=\"一、確認 Hexo 已正確啟動\"></a>一、確認 Hexo 已正確啟動</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo -v</span><br></pre></td></tr></table></figure>\n<p>如果有正確啟動 <strong>Hexo</strong>，會跑出版本說明，這時可以放心繼續下去。</p>\n<h3 id=\"二、新增一個-post\"><a href=\"#二、新增一個-post\" class=\"headerlink\" title=\"二、新增一個 post\"></a>二、新增一個 post</h3><p>（一）新增發文</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> <span class=\"string\">&quot;new post name&quot;</span></span><br></pre></td></tr></table></figure>\n<p>new post name 也可以是中文喔。</p>\n<p>會在 <strong>source&#x2F;_posts</strong> 目錄底下新增一個 <strong>日期_new_post_name.md</strong> 文件，此時就可以進去編輯你的新文章了。</p>\n<p>（二）新增草稿</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> draft <span class=\"string\">&quot;new draft name&quot;</span></span><br></pre></td></tr></table></figure>\n<p>會在 <strong>source&#x2F;_drafts</strong> 目錄底下新增一個 <strong>日期_new_draft_name.md</strong> 文件，寫完可以用這個命令來發佈：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filemame&gt;</span><br></pre></td></tr></table></figure>\n<p>（三）更新 <strong>Hexo</strong></p>\n<p>上述兩步都只是在 <strong>source</strong> 資料夾中更新文章而已，你還需要這個步驟才能更新 <strong>Hexo</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate  <span class=\"comment\">//或 hexo g</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"三、推上-github\"><a href=\"#三、推上-github\" class=\"headerlink\" title=\"三、推上 github\"></a>三、推上 github</h3><p>（一）更改 <strong>_config.yml</strong> 內容</p>\n<p>為了將 <strong>Hexo</strong> 與 <strong>Github</strong> 連結起來，你需要在 <strong>_config.yml</strong> 中填入相關資料。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">url</span>: <span class=\"attr\">https</span>:<span class=\"comment\">//&lt;你的 github name&gt;.github.io/&lt;你的 repository name&gt;/</span></span><br><span class=\"line\"><span class=\"attr\">root</span>: <span class=\"regexp\">/&lt;你的 repository name&gt;/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attr\">type</span>: git</span><br><span class=\"line\">  <span class=\"attr\">repo</span>: &lt;你的 repository url&gt;</span><br></pre></td></tr></table></figure>\n<p>（二）安裝 <strong>Hexo-git-deployer</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>（三）執行部署</p>\n<p>以下三種命令都會將 <strong>Hexo</strong> 部署上去，其中的 <strong>generate</strong> 就是直接幫你把更新 <strong>Hexo</strong> 也一併做了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy --generate</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ heso generate --deploy</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g -d</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>關於個人部落格的架設就寫到這邊，算是流程的紀錄，也希望之後能幫到遇到一樣的問題的人，感覺 <strong>Hexo</strong> 還有很多坑等著讓人踩啊。</p>"},{"title":"Nginx 學習筆記 - 使用 Nginx","date":"2019-10-24T14:15:35.000Z","_content":"最近被主管要求使用 `Nginx` 來放專案的測試版本，方便跟 PM 溝通（就不用一直叫 PM 過來看我表演 `ng serve`，直接 build 好丟網址給他就可以測試了）。原本以為 `Nginx` 安裝一下改個 `config` 很方便，結果還是在意想不到的地方卡了一下，因此整理成筆記分享，以免有人遇到相同的問題。\n\n<!--more-->\n\n---\n\n## 安裝 `Nginx`\n\n> 安裝起來先：[Nginx 官網](http://nginx.org/en/docs/install.html)\n\n因為我是用 Mac，所以直接開啟 Terminal 輸入：\n```bash\n$ brew install nginx\n```\n\n---\n\n## 指令\n\n```bash\n# 啟動\n$ sudo nginx\n\n# 更新\n$ nginx -s reload\n\n# 停止\n$ sudo nginx -s stop\n```\n\n打開 http://localhost:8080，就會看到 `Nginx` 在跟你招手了！\n\n---\n\n## 配置\n\n我們當然不可能滿足於用 localhost:8080，所以現在要來改配置。\n\n先找到 `nginx.conf` 檔，Mac 的檔案位置如下：\n\n```\n/usr/local/etc/nginx/nginx.conf\n```\n\n開啟 `nginx.conf` 檔之後，找到下面這個區塊：\n\n```nginx\nserver {\n    listen 8080 default_server;\n}\n```\n改為下面這樣子：\n\n```nginx\nserver {\n    listen 80 default_server;\n}\n```\n\n這樣，`Nginx` 就會在你的 `localhost`（或你電腦的 ip 位址）執行了。\n\n---\n\n## 根目錄\n\nlocalhost 預設會打開的檔案如下：\n\n```nginx\nserver {\n    listen 80 default_server;\n    # listen [::]:80 default_server ipv6only=on;\n    server_name localhost;\n    root /usr/local/Cellar/nginx/1.17.3_1/html; # 預設根目錄\n    index index.html; # 預設開啟的檔案\n}\n```\n\n那麼，接下來就可以來設定各個路由會通往哪裡了：\n\n```nginx\nserver {\n    location / {\n        # 因為是空的，會去找 server 的預設路徑\n    }\n    \n    # 設定 localhost/my-website/\n    location /my-website/ {\n        alias /Users/user/desktop/myProject/; # 設定檔案目錄的路徑\n        index index.html; # 要開啟的檔案\n    }\n}\n```\n\n如果訪問 `localhost/my-website/`，就會去開啟 `myProject` 專案底下的 `index.html` 檔了。耶！\n\n---\n\n## 權限問題\n\n不曉得是什麼原因，我在訪問網址的時候，`localhost/` 可以正常顯示，但 `localhost/my-website/` 卻一直出現 `403 forbidden`。找了各種可能的原因後，最後判斷應該是因為訪問者的權限不足，因此不能訪問檔案。\n\n因此在 `nginx.conf` 的第一行，調整訪問者的權限：\n\n```nginx\n# 原本是這樣，也是註解的狀態\n# user nobody\n\n# 把註解打開，並改成這樣\nuser root owner;\n```\n\n就可以訪問各個路徑了。\n\n只是不曉得對方拿到 root 權限，可以對你的網站做什麼事，一顆心撲通撲通地亂跳。但反正用 `Nginx` 來架站，我目前僅用於公司內部測試用，就暫時不擔心這個問題啦。\n\n好了，以上就是感覺充滿坑的 `Nginx` 架站筆記。\n\n\n---\n參考資料：\n* [Nginx 官網](http://nginx.org/en/docs/install.html)\n* [Installing Nginx in Mac OS X Maverick With Homebrew](https://medium.com/@ThomasTan/installing-nginx-in-mac-os-x-maverick-with-homebrew-d8867b7e8a5a)","source":"_posts/nginx.md","raw":"---\ntitle: Nginx 學習筆記 - 使用 Nginx \ndate: 2019-10-24 22:15:35\ntags: nginx\n---\n最近被主管要求使用 `Nginx` 來放專案的測試版本，方便跟 PM 溝通（就不用一直叫 PM 過來看我表演 `ng serve`，直接 build 好丟網址給他就可以測試了）。原本以為 `Nginx` 安裝一下改個 `config` 很方便，結果還是在意想不到的地方卡了一下，因此整理成筆記分享，以免有人遇到相同的問題。\n\n<!--more-->\n\n---\n\n## 安裝 `Nginx`\n\n> 安裝起來先：[Nginx 官網](http://nginx.org/en/docs/install.html)\n\n因為我是用 Mac，所以直接開啟 Terminal 輸入：\n```bash\n$ brew install nginx\n```\n\n---\n\n## 指令\n\n```bash\n# 啟動\n$ sudo nginx\n\n# 更新\n$ nginx -s reload\n\n# 停止\n$ sudo nginx -s stop\n```\n\n打開 http://localhost:8080，就會看到 `Nginx` 在跟你招手了！\n\n---\n\n## 配置\n\n我們當然不可能滿足於用 localhost:8080，所以現在要來改配置。\n\n先找到 `nginx.conf` 檔，Mac 的檔案位置如下：\n\n```\n/usr/local/etc/nginx/nginx.conf\n```\n\n開啟 `nginx.conf` 檔之後，找到下面這個區塊：\n\n```nginx\nserver {\n    listen 8080 default_server;\n}\n```\n改為下面這樣子：\n\n```nginx\nserver {\n    listen 80 default_server;\n}\n```\n\n這樣，`Nginx` 就會在你的 `localhost`（或你電腦的 ip 位址）執行了。\n\n---\n\n## 根目錄\n\nlocalhost 預設會打開的檔案如下：\n\n```nginx\nserver {\n    listen 80 default_server;\n    # listen [::]:80 default_server ipv6only=on;\n    server_name localhost;\n    root /usr/local/Cellar/nginx/1.17.3_1/html; # 預設根目錄\n    index index.html; # 預設開啟的檔案\n}\n```\n\n那麼，接下來就可以來設定各個路由會通往哪裡了：\n\n```nginx\nserver {\n    location / {\n        # 因為是空的，會去找 server 的預設路徑\n    }\n    \n    # 設定 localhost/my-website/\n    location /my-website/ {\n        alias /Users/user/desktop/myProject/; # 設定檔案目錄的路徑\n        index index.html; # 要開啟的檔案\n    }\n}\n```\n\n如果訪問 `localhost/my-website/`，就會去開啟 `myProject` 專案底下的 `index.html` 檔了。耶！\n\n---\n\n## 權限問題\n\n不曉得是什麼原因，我在訪問網址的時候，`localhost/` 可以正常顯示，但 `localhost/my-website/` 卻一直出現 `403 forbidden`。找了各種可能的原因後，最後判斷應該是因為訪問者的權限不足，因此不能訪問檔案。\n\n因此在 `nginx.conf` 的第一行，調整訪問者的權限：\n\n```nginx\n# 原本是這樣，也是註解的狀態\n# user nobody\n\n# 把註解打開，並改成這樣\nuser root owner;\n```\n\n就可以訪問各個路徑了。\n\n只是不曉得對方拿到 root 權限，可以對你的網站做什麼事，一顆心撲通撲通地亂跳。但反正用 `Nginx` 來架站，我目前僅用於公司內部測試用，就暫時不擔心這個問題啦。\n\n好了，以上就是感覺充滿坑的 `Nginx` 架站筆記。\n\n\n---\n參考資料：\n* [Nginx 官網](http://nginx.org/en/docs/install.html)\n* [Installing Nginx in Mac OS X Maverick With Homebrew](https://medium.com/@ThomasTan/installing-nginx-in-mac-os-x-maverick-with-homebrew-d8867b7e8a5a)","slug":"nginx","published":1,"updated":"2022-03-12T12:58:20.896Z","_id":"cl0nustir001tz6us01vee6ay","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近被主管要求使用 <code>Nginx</code> 來放專案的測試版本，方便跟 PM 溝通（就不用一直叫 PM 過來看我表演 <code>ng serve</code>，直接 build 好丟網址給他就可以測試了）。原本以為 <code>Nginx</code> 安裝一下改個 <code>config</code> 很方便，結果還是在意想不到的地方卡了一下，因此整理成筆記分享，以免有人遇到相同的問題。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"安裝-Nginx\"><a href=\"#安裝-Nginx\" class=\"headerlink\" title=\"安裝 Nginx\"></a>安裝 <code>Nginx</code></h2><blockquote>\n<p>安裝起來先：<a class=\"link\"   href=\"http://nginx.org/en/docs/install.html\" >Nginx 官網<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>因為我是用 Mac，所以直接開啟 Terminal 輸入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install nginx</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 啟動</span></span><br><span class=\"line\">$ sudo nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新</span></span><br><span class=\"line\">$ nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">$ sudo nginx -s stop</span><br></pre></td></tr></table></figure>\n\n<p>打開 <a href=\"http://localhost:8080，就會看到\">http://localhost:8080，就會看到</a> <code>Nginx</code> 在跟你招手了！</p>\n<hr>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>我們當然不可能滿足於用 localhost:8080，所以現在要來改配置。</p>\n<p>先找到 <code>nginx.conf</code> 檔，Mac 的檔案位置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<p>開啟 <code>nginx.conf</code> 檔之後，找到下面這個區塊：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">8080</span> default_server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改為下面這樣子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣，<code>Nginx</code> 就會在你的 <code>localhost</code>（或你電腦的 ip 位址）執行了。</p>\n<hr>\n<h2 id=\"根目錄\"><a href=\"#根目錄\" class=\"headerlink\" title=\"根目錄\"></a>根目錄</h2><p>localhost 預設會打開的檔案如下：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">    <span class=\"comment\"># listen [::]:80 default_server ipv6only=on;</span></span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> /usr/local/Cellar/nginx/<span class=\"number\">1</span>.<span class=\"number\">17</span>.3_1/html; <span class=\"comment\"># 預設根目錄</span></span><br><span class=\"line\">    <span class=\"attribute\">index</span> index.html; <span class=\"comment\"># 預設開啟的檔案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼，接下來就可以來設定各個路由會通往哪裡了：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"comment\"># 因為是空的，會去找 server 的預設路徑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 設定 localhost/my-website/</span></span><br><span class=\"line\">    <span class=\"section\">location</span> /my-website/ &#123;</span><br><span class=\"line\">        <span class=\"attribute\">alias</span> /Users/user/desktop/myProject/; <span class=\"comment\"># 設定檔案目錄的路徑</span></span><br><span class=\"line\">        <span class=\"attribute\">index</span> index.html; <span class=\"comment\"># 要開啟的檔案</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果訪問 <code>localhost/my-website/</code>，就會去開啟 <code>myProject</code> 專案底下的 <code>index.html</code> 檔了。耶！</p>\n<hr>\n<h2 id=\"權限問題\"><a href=\"#權限問題\" class=\"headerlink\" title=\"權限問題\"></a>權限問題</h2><p>不曉得是什麼原因，我在訪問網址的時候，<code>localhost/</code> 可以正常顯示，但 <code>localhost/my-website/</code> 卻一直出現 <code>403 forbidden</code>。找了各種可能的原因後，最後判斷應該是因為訪問者的權限不足，因此不能訪問檔案。</p>\n<p>因此在 <code>nginx.conf</code> 的第一行，調整訪問者的權限：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 原本是這樣，也是註解的狀態</span></span><br><span class=\"line\"><span class=\"comment\"># user nobody</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把註解打開，並改成這樣</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> root owner;</span><br></pre></td></tr></table></figure>\n\n<p>就可以訪問各個路徑了。</p>\n<p>只是不曉得對方拿到 root 權限，可以對你的網站做什麼事，一顆心撲通撲通地亂跳。但反正用 <code>Nginx</code> 來架站，我目前僅用於公司內部測試用，就暫時不擔心這個問題啦。</p>\n<p>好了，以上就是感覺充滿坑的 <code>Nginx</code> 架站筆記。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"http://nginx.org/en/docs/install.html\" >Nginx 官網<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/@ThomasTan/installing-nginx-in-mac-os-x-maverick-with-homebrew-d8867b7e8a5a\" >Installing Nginx in Mac OS X Maverick With Homebrew<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近被主管要求使用 <code>Nginx</code> 來放專案的測試版本，方便跟 PM 溝通（就不用一直叫 PM 過來看我表演 <code>ng serve</code>，直接 build 好丟網址給他就可以測試了）。原本以為 <code>Nginx</code> 安裝一下改個 <code>config</code> 很方便，結果還是在意想不到的地方卡了一下，因此整理成筆記分享，以免有人遇到相同的問題。</p>","more":"<hr>\n<h2 id=\"安裝-Nginx\"><a href=\"#安裝-Nginx\" class=\"headerlink\" title=\"安裝 Nginx\"></a>安裝 <code>Nginx</code></h2><blockquote>\n<p>安裝起來先：<a class=\"link\"   href=\"http://nginx.org/en/docs/install.html\" >Nginx 官網<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>因為我是用 Mac，所以直接開啟 Terminal 輸入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew install nginx</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 啟動</span></span><br><span class=\"line\">$ sudo nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新</span></span><br><span class=\"line\">$ nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止</span></span><br><span class=\"line\">$ sudo nginx -s stop</span><br></pre></td></tr></table></figure>\n\n<p>打開 <a href=\"http://localhost:8080，就會看到\">http://localhost:8080，就會看到</a> <code>Nginx</code> 在跟你招手了！</p>\n<hr>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>我們當然不可能滿足於用 localhost:8080，所以現在要來改配置。</p>\n<p>先找到 <code>nginx.conf</code> 檔，Mac 的檔案位置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<p>開啟 <code>nginx.conf</code> 檔之後，找到下面這個區塊：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">8080</span> default_server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改為下面這樣子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣，<code>Nginx</code> 就會在你的 <code>localhost</code>（或你電腦的 ip 位址）執行了。</p>\n<hr>\n<h2 id=\"根目錄\"><a href=\"#根目錄\" class=\"headerlink\" title=\"根目錄\"></a>根目錄</h2><p>localhost 預設會打開的檔案如下：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">listen</span> <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">    <span class=\"comment\"># listen [::]:80 default_server ipv6only=on;</span></span><br><span class=\"line\">    <span class=\"attribute\">server_name</span> localhost;</span><br><span class=\"line\">    <span class=\"attribute\">root</span> /usr/local/Cellar/nginx/<span class=\"number\">1</span>.<span class=\"number\">17</span>.3_1/html; <span class=\"comment\"># 預設根目錄</span></span><br><span class=\"line\">    <span class=\"attribute\">index</span> index.html; <span class=\"comment\"># 預設開啟的檔案</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那麼，接下來就可以來設定各個路由會通往哪裡了：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">    <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">        <span class=\"comment\"># 因為是空的，會去找 server 的預設路徑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 設定 localhost/my-website/</span></span><br><span class=\"line\">    <span class=\"section\">location</span> /my-website/ &#123;</span><br><span class=\"line\">        <span class=\"attribute\">alias</span> /Users/user/desktop/myProject/; <span class=\"comment\"># 設定檔案目錄的路徑</span></span><br><span class=\"line\">        <span class=\"attribute\">index</span> index.html; <span class=\"comment\"># 要開啟的檔案</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果訪問 <code>localhost/my-website/</code>，就會去開啟 <code>myProject</code> 專案底下的 <code>index.html</code> 檔了。耶！</p>\n<hr>\n<h2 id=\"權限問題\"><a href=\"#權限問題\" class=\"headerlink\" title=\"權限問題\"></a>權限問題</h2><p>不曉得是什麼原因，我在訪問網址的時候，<code>localhost/</code> 可以正常顯示，但 <code>localhost/my-website/</code> 卻一直出現 <code>403 forbidden</code>。找了各種可能的原因後，最後判斷應該是因為訪問者的權限不足，因此不能訪問檔案。</p>\n<p>因此在 <code>nginx.conf</code> 的第一行，調整訪問者的權限：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 原本是這樣，也是註解的狀態</span></span><br><span class=\"line\"><span class=\"comment\"># user nobody</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把註解打開，並改成這樣</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> root owner;</span><br></pre></td></tr></table></figure>\n\n<p>就可以訪問各個路徑了。</p>\n<p>只是不曉得對方拿到 root 權限，可以對你的網站做什麼事，一顆心撲通撲通地亂跳。但反正用 <code>Nginx</code> 來架站，我目前僅用於公司內部測試用，就暫時不擔心這個問題啦。</p>\n<p>好了，以上就是感覺充滿坑的 <code>Nginx</code> 架站筆記。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"http://nginx.org/en/docs/install.html\" >Nginx 官網<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/@ThomasTan/installing-nginx-in-mac-os-x-maverick-with-homebrew-d8867b7e8a5a\" >Installing Nginx in Mac OS X Maverick With Homebrew<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Node.js 學習筆記 - 初次接觸 Node.js","date":"2019-12-22T06:28:48.000Z","_content":"\n由於公司有使用 Node.js 撰寫的專案，之後有維護需求，因此對 Node.js 一竅不通的我，只好趕快惡補。\n\n<!--more-->\n\n---\n## 1. Overview\n\n### 1.1 為什麼要學 Node.js\n\nNode.js 有許多優勢，但對我而言最直接的原因就是，因為我在前端使用的是 JavaScript，Node.js 是使用 JavaScript 的後端語言，因此對於理解上，就少了一層障礙。\n\n* 使用 JavaScript 的後端語言\n* 能夠自己寫 web server\n* 非同步 IO，事件驅動的特性，降低等待時間與耗能\n* 許多第三方套件（如 express、socket...等等）\n* 入門簡單（~~我不相信~~）\n\n### 1.2 基本認識 Node.js\n\n> [Node.js - 維基百科](https://zh.wikipedia.org/wiki/Node.js)\n> [Node.js之深入理解特性](https://segmentfault.com/a/1190000008961775)\n\n如上所述，Node.js 的特性有以下幾個：\n\n* 事件驅動才調用 I/O 資源，減少耗能\n* 使用 JavaScript 語言編寫\n\n\n### 1.3 如何學習 Node.js\n\n那麼要學習 Node.js，具體來說應該要理解哪些事呢？我列出幾個學習重點，也方便日後檢視是否真的學會了這些東西：\n\n* JavaScript 基礎\n* Unix / Linux 指令\n* 理解伺服器端腳本\n* 模組和套件管理\n* 異步 I/O 與 Async 流程控制庫（Input / Output，網路、文件、資料庫、使用者輸入等等的進出）\n* 事件處理機制\n* Node.js 與 AJAX\n* 跨平台與跨瀏覽器的相容\n* TCP/UDP 網路程式設計\n* HTTP/HTTPS 應用程式設計\n* Node.js 與資料庫互動\n\n### 1.4 Node.js 可以做些什麼？\n\n* 撰寫 REST APIs\n* 即時服務（線上聊天室、連線遊戲）\n* 串接資料庫、blog、社群平台\n\n我認為伺服器最主要功能就是做資源的處理，而前端是接口與呈現。所以在初步學習了 Node.js 之後，應該就會朝撰寫 API、串 WebSocket、串資料庫等方向去進一步探索吧。畢竟學程式就是要做出想做的作品嘛。\n\n---\n## 2. Node.js 基本概念\n\n### 2.1 線程處理與事件循環\n\n#### 2.1.1 線程處理\n1. 收到 request\n2. thread 應對\n3. request 處理完成，thread 釋放\n\n所謂線程處理，當收到請求時就依照以上步驟處理，因此當同時湧入大量請求時，伺服器負荷就會提高。例如 Apache 6,7,8,9 等版本。\n\n#### 2.1.2 事件循環\n\nNode.js 的事件循環特性就能比較好地 handle 這問題，他的運作方式如下：\n\n1. 開一個事件等待循環（event loop）\n2. 收到 request\n3. 將 request 塞入處理隊列中，然後繼續監聽其他 request\n4. request 處理完成後，調用 I/O，結束 request\n\n也就是說，Node.js 以一個監聽器來處理 request 的「請求」與「完成」，並不會從頭到尾監聽，而只在這兩種事件出現時才調用 I/O 資源。\n\n### 2.2 阻塞處理／非阻塞處理\n\n#### 2.2.1 阻塞處理\n\n會發生阻塞處理的語言有：Java、Ruby、PHP、Asp.Net 等，因為他們會照以下方式處理程序：\n\n1. 先執行的函式尚未處理完，不會執行下一個函式\n2. 所有的函式都要等待前一個函式處理完\n3. 塞車\n\n#### 2.2.2 非阻塞處理\n\n而 Node.js 就能有效解決這個問題，但相對地也會有弱勢。\n\n1. 呼叫函式時，需傳入一個 callback，處理完畢後調用 callback\n2. 一旦函式開始處理，不用等待結果，就繼續運行下一個函式\n3. 整份檔案順暢跑完（但各函式不會同時處理完畢）！\n\n### 2.3 Node_modules\n\nNode.js 本身的 node_modules 就提供了相當多的套件可以使用，隨便舉幾個例子：\n\n* `http`：Web http request 處理\n* `fs`：文件處理\n* `path`：路徑處理\n* `url`：網址處理\n* `eventEmitter`：request 事件監聽處理\n* `uuid`：產生不重複 ID 的小工具\n\n而在部署時，並不需要將這些套件一起打包，只要在 config.json 的 dependencies 註明清楚，就可以透過 `npm install` 來安裝所有需要的套件包了。\n\n---\n\n## 3. 開始 Node.s！\n\n### 3.1 \"Hello World\"\n\n是的，學習一個新語言，當然都是從最基本的跟世界打個招呼來開始。首先知道如何運行它，然後才能一步步深入。\n\n* 檢查 Node.js 版本\n\n```javascript\n$ node -v // v10.16.0 // 看得到版本代表有成功安裝 Node.js\n$ npm -v // 6.9.0 // 同時檢查 Node Package Manager 版本\n$ node // 並跳轉至大於符號代表成功進入 Node 環境\n>\n```\n\n* 在 Node.js 環境下，呼叫 `console` 輸出 Hello World\n\n```javascript\n> console.log(\"Hello World\"); // Node 環境下可以撰寫 JavaScript\nHello World // 這是 Node 吐出來的，成功使用 Node 了！\nundefined // 看到這個不要緊張，這是返回 console.log 這函數的值\n```\n\n* 其他操作\n\n```javascript\n$ .help // 查看 Node 幫助\n$ .exit // 離開 Node\n```\n\n### 3.2 進一步的 Hello World\n\n當然，我們不希望每次都在 Node.js 裡面打一堆程式碼，最好是能呼叫執行檔案。那麼具體的操作方法是怎麼樣呢？\n\n1. 建立一個 helloworld.js 檔\n2. 檔案內容為：\n    ```javascript\n    var str = 'Hello Node.js!';\n    console.log(str);\n    ```\n3. 然後，在控制台使用 Node 運行這個檔案\n    ```javascript\n    $ node helloworld.js // 或 node helloworld\n    Hello Node.js!\n    ```\n4. 成功使用 Node.js 呼叫檔案了！\n\n### \n\n---\n\n## 4. 結語\n\n關於 Node.js 的入門學習，就到這邊告一段落了。接下來我會繼續學習如何使用 express 框架來開發 Node.js app，接著就要逐漸嘗試實作出即時聊天室或小遊戲啦！\n\n\n---\n參考資料：\n* [Node.js - 維基百科](https://zh.wikipedia.org/wiki/Node.js)\n* [Node.js Crash Course - Traversy Media](https://www.youtube.com/watch?v=fBNz5xF-Kx4)\n* [Node.js之深入理解特性](https://segmentfault.com/a/1190000008961775)","source":"_posts/Node-intro.md","raw":"---\ntitle: Node.js 學習筆記 - 初次接觸 Node.js\ndate: 2019-12-22 14:28:48\ntags: [Node.js]\n---\n\n由於公司有使用 Node.js 撰寫的專案，之後有維護需求，因此對 Node.js 一竅不通的我，只好趕快惡補。\n\n<!--more-->\n\n---\n## 1. Overview\n\n### 1.1 為什麼要學 Node.js\n\nNode.js 有許多優勢，但對我而言最直接的原因就是，因為我在前端使用的是 JavaScript，Node.js 是使用 JavaScript 的後端語言，因此對於理解上，就少了一層障礙。\n\n* 使用 JavaScript 的後端語言\n* 能夠自己寫 web server\n* 非同步 IO，事件驅動的特性，降低等待時間與耗能\n* 許多第三方套件（如 express、socket...等等）\n* 入門簡單（~~我不相信~~）\n\n### 1.2 基本認識 Node.js\n\n> [Node.js - 維基百科](https://zh.wikipedia.org/wiki/Node.js)\n> [Node.js之深入理解特性](https://segmentfault.com/a/1190000008961775)\n\n如上所述，Node.js 的特性有以下幾個：\n\n* 事件驅動才調用 I/O 資源，減少耗能\n* 使用 JavaScript 語言編寫\n\n\n### 1.3 如何學習 Node.js\n\n那麼要學習 Node.js，具體來說應該要理解哪些事呢？我列出幾個學習重點，也方便日後檢視是否真的學會了這些東西：\n\n* JavaScript 基礎\n* Unix / Linux 指令\n* 理解伺服器端腳本\n* 模組和套件管理\n* 異步 I/O 與 Async 流程控制庫（Input / Output，網路、文件、資料庫、使用者輸入等等的進出）\n* 事件處理機制\n* Node.js 與 AJAX\n* 跨平台與跨瀏覽器的相容\n* TCP/UDP 網路程式設計\n* HTTP/HTTPS 應用程式設計\n* Node.js 與資料庫互動\n\n### 1.4 Node.js 可以做些什麼？\n\n* 撰寫 REST APIs\n* 即時服務（線上聊天室、連線遊戲）\n* 串接資料庫、blog、社群平台\n\n我認為伺服器最主要功能就是做資源的處理，而前端是接口與呈現。所以在初步學習了 Node.js 之後，應該就會朝撰寫 API、串 WebSocket、串資料庫等方向去進一步探索吧。畢竟學程式就是要做出想做的作品嘛。\n\n---\n## 2. Node.js 基本概念\n\n### 2.1 線程處理與事件循環\n\n#### 2.1.1 線程處理\n1. 收到 request\n2. thread 應對\n3. request 處理完成，thread 釋放\n\n所謂線程處理，當收到請求時就依照以上步驟處理，因此當同時湧入大量請求時，伺服器負荷就會提高。例如 Apache 6,7,8,9 等版本。\n\n#### 2.1.2 事件循環\n\nNode.js 的事件循環特性就能比較好地 handle 這問題，他的運作方式如下：\n\n1. 開一個事件等待循環（event loop）\n2. 收到 request\n3. 將 request 塞入處理隊列中，然後繼續監聽其他 request\n4. request 處理完成後，調用 I/O，結束 request\n\n也就是說，Node.js 以一個監聽器來處理 request 的「請求」與「完成」，並不會從頭到尾監聽，而只在這兩種事件出現時才調用 I/O 資源。\n\n### 2.2 阻塞處理／非阻塞處理\n\n#### 2.2.1 阻塞處理\n\n會發生阻塞處理的語言有：Java、Ruby、PHP、Asp.Net 等，因為他們會照以下方式處理程序：\n\n1. 先執行的函式尚未處理完，不會執行下一個函式\n2. 所有的函式都要等待前一個函式處理完\n3. 塞車\n\n#### 2.2.2 非阻塞處理\n\n而 Node.js 就能有效解決這個問題，但相對地也會有弱勢。\n\n1. 呼叫函式時，需傳入一個 callback，處理完畢後調用 callback\n2. 一旦函式開始處理，不用等待結果，就繼續運行下一個函式\n3. 整份檔案順暢跑完（但各函式不會同時處理完畢）！\n\n### 2.3 Node_modules\n\nNode.js 本身的 node_modules 就提供了相當多的套件可以使用，隨便舉幾個例子：\n\n* `http`：Web http request 處理\n* `fs`：文件處理\n* `path`：路徑處理\n* `url`：網址處理\n* `eventEmitter`：request 事件監聽處理\n* `uuid`：產生不重複 ID 的小工具\n\n而在部署時，並不需要將這些套件一起打包，只要在 config.json 的 dependencies 註明清楚，就可以透過 `npm install` 來安裝所有需要的套件包了。\n\n---\n\n## 3. 開始 Node.s！\n\n### 3.1 \"Hello World\"\n\n是的，學習一個新語言，當然都是從最基本的跟世界打個招呼來開始。首先知道如何運行它，然後才能一步步深入。\n\n* 檢查 Node.js 版本\n\n```javascript\n$ node -v // v10.16.0 // 看得到版本代表有成功安裝 Node.js\n$ npm -v // 6.9.0 // 同時檢查 Node Package Manager 版本\n$ node // 並跳轉至大於符號代表成功進入 Node 環境\n>\n```\n\n* 在 Node.js 環境下，呼叫 `console` 輸出 Hello World\n\n```javascript\n> console.log(\"Hello World\"); // Node 環境下可以撰寫 JavaScript\nHello World // 這是 Node 吐出來的，成功使用 Node 了！\nundefined // 看到這個不要緊張，這是返回 console.log 這函數的值\n```\n\n* 其他操作\n\n```javascript\n$ .help // 查看 Node 幫助\n$ .exit // 離開 Node\n```\n\n### 3.2 進一步的 Hello World\n\n當然，我們不希望每次都在 Node.js 裡面打一堆程式碼，最好是能呼叫執行檔案。那麼具體的操作方法是怎麼樣呢？\n\n1. 建立一個 helloworld.js 檔\n2. 檔案內容為：\n    ```javascript\n    var str = 'Hello Node.js!';\n    console.log(str);\n    ```\n3. 然後，在控制台使用 Node 運行這個檔案\n    ```javascript\n    $ node helloworld.js // 或 node helloworld\n    Hello Node.js!\n    ```\n4. 成功使用 Node.js 呼叫檔案了！\n\n### \n\n---\n\n## 4. 結語\n\n關於 Node.js 的入門學習，就到這邊告一段落了。接下來我會繼續學習如何使用 express 框架來開發 Node.js app，接著就要逐漸嘗試實作出即時聊天室或小遊戲啦！\n\n\n---\n參考資料：\n* [Node.js - 維基百科](https://zh.wikipedia.org/wiki/Node.js)\n* [Node.js Crash Course - Traversy Media](https://www.youtube.com/watch?v=fBNz5xF-Kx4)\n* [Node.js之深入理解特性](https://segmentfault.com/a/1190000008961775)","slug":"Node-intro","published":1,"updated":"2022-03-12T12:58:21.191Z","_id":"cl0nustss001wz6us1c8oeia0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由於公司有使用 Node.js 撰寫的專案，之後有維護需求，因此對 Node.js 一竅不通的我，只好趕快惡補。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"1-Overview\"><a href=\"#1-Overview\" class=\"headerlink\" title=\"1. Overview\"></a>1. Overview</h2><h3 id=\"1-1-為什麼要學-Node-js\"><a href=\"#1-1-為什麼要學-Node-js\" class=\"headerlink\" title=\"1.1 為什麼要學 Node.js\"></a>1.1 為什麼要學 Node.js</h3><p>Node.js 有許多優勢，但對我而言最直接的原因就是，因為我在前端使用的是 JavaScript，Node.js 是使用 JavaScript 的後端語言，因此對於理解上，就少了一層障礙。</p>\n<ul>\n<li>使用 JavaScript 的後端語言</li>\n<li>能夠自己寫 web server</li>\n<li>非同步 IO，事件驅動的特性，降低等待時間與耗能</li>\n<li>許多第三方套件（如 express、socket…等等）</li>\n<li>入門簡單（<del>我不相信</del>）</li>\n</ul>\n<h3 id=\"1-2-基本認識-Node-js\"><a href=\"#1-2-基本認識-Node-js\" class=\"headerlink\" title=\"1.2 基本認識 Node.js\"></a>1.2 基本認識 Node.js</h3><blockquote>\n<p><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/Node.js\" >Node.js - 維基百科<i class=\"fas fa-external-link-alt\"></i></a><br><a class=\"link\"   href=\"https://segmentfault.com/a/1190000008961775\" >Node.js之深入理解特性<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>如上所述，Node.js 的特性有以下幾個：</p>\n<ul>\n<li>事件驅動才調用 I&#x2F;O 資源，減少耗能</li>\n<li>使用 JavaScript 語言編寫</li>\n</ul>\n<h3 id=\"1-3-如何學習-Node-js\"><a href=\"#1-3-如何學習-Node-js\" class=\"headerlink\" title=\"1.3 如何學習 Node.js\"></a>1.3 如何學習 Node.js</h3><p>那麼要學習 Node.js，具體來說應該要理解哪些事呢？我列出幾個學習重點，也方便日後檢視是否真的學會了這些東西：</p>\n<ul>\n<li>JavaScript 基礎</li>\n<li>Unix &#x2F; Linux 指令</li>\n<li>理解伺服器端腳本</li>\n<li>模組和套件管理</li>\n<li>異步 I&#x2F;O 與 Async 流程控制庫（Input &#x2F; Output，網路、文件、資料庫、使用者輸入等等的進出）</li>\n<li>事件處理機制</li>\n<li>Node.js 與 AJAX</li>\n<li>跨平台與跨瀏覽器的相容</li>\n<li>TCP&#x2F;UDP 網路程式設計</li>\n<li>HTTP&#x2F;HTTPS 應用程式設計</li>\n<li>Node.js 與資料庫互動</li>\n</ul>\n<h3 id=\"1-4-Node-js-可以做些什麼？\"><a href=\"#1-4-Node-js-可以做些什麼？\" class=\"headerlink\" title=\"1.4 Node.js 可以做些什麼？\"></a>1.4 Node.js 可以做些什麼？</h3><ul>\n<li>撰寫 REST APIs</li>\n<li>即時服務（線上聊天室、連線遊戲）</li>\n<li>串接資料庫、blog、社群平台</li>\n</ul>\n<p>我認為伺服器最主要功能就是做資源的處理，而前端是接口與呈現。所以在初步學習了 Node.js 之後，應該就會朝撰寫 API、串 WebSocket、串資料庫等方向去進一步探索吧。畢竟學程式就是要做出想做的作品嘛。</p>\n<hr>\n<h2 id=\"2-Node-js-基本概念\"><a href=\"#2-Node-js-基本概念\" class=\"headerlink\" title=\"2. Node.js 基本概念\"></a>2. Node.js 基本概念</h2><h3 id=\"2-1-線程處理與事件循環\"><a href=\"#2-1-線程處理與事件循環\" class=\"headerlink\" title=\"2.1 線程處理與事件循環\"></a>2.1 線程處理與事件循環</h3><h4 id=\"2-1-1-線程處理\"><a href=\"#2-1-1-線程處理\" class=\"headerlink\" title=\"2.1.1 線程處理\"></a>2.1.1 線程處理</h4><ol>\n<li>收到 request</li>\n<li>thread 應對</li>\n<li>request 處理完成，thread 釋放</li>\n</ol>\n<p>所謂線程處理，當收到請求時就依照以上步驟處理，因此當同時湧入大量請求時，伺服器負荷就會提高。例如 Apache 6,7,8,9 等版本。</p>\n<h4 id=\"2-1-2-事件循環\"><a href=\"#2-1-2-事件循環\" class=\"headerlink\" title=\"2.1.2 事件循環\"></a>2.1.2 事件循環</h4><p>Node.js 的事件循環特性就能比較好地 handle 這問題，他的運作方式如下：</p>\n<ol>\n<li>開一個事件等待循環（event loop）</li>\n<li>收到 request</li>\n<li>將 request 塞入處理隊列中，然後繼續監聽其他 request</li>\n<li>request 處理完成後，調用 I&#x2F;O，結束 request</li>\n</ol>\n<p>也就是說，Node.js 以一個監聽器來處理 request 的「請求」與「完成」，並不會從頭到尾監聽，而只在這兩種事件出現時才調用 I&#x2F;O 資源。</p>\n<h3 id=\"2-2-阻塞處理／非阻塞處理\"><a href=\"#2-2-阻塞處理／非阻塞處理\" class=\"headerlink\" title=\"2.2 阻塞處理／非阻塞處理\"></a>2.2 阻塞處理／非阻塞處理</h3><h4 id=\"2-2-1-阻塞處理\"><a href=\"#2-2-1-阻塞處理\" class=\"headerlink\" title=\"2.2.1 阻塞處理\"></a>2.2.1 阻塞處理</h4><p>會發生阻塞處理的語言有：Java、Ruby、PHP、Asp.Net 等，因為他們會照以下方式處理程序：</p>\n<ol>\n<li>先執行的函式尚未處理完，不會執行下一個函式</li>\n<li>所有的函式都要等待前一個函式處理完</li>\n<li>塞車</li>\n</ol>\n<h4 id=\"2-2-2-非阻塞處理\"><a href=\"#2-2-2-非阻塞處理\" class=\"headerlink\" title=\"2.2.2 非阻塞處理\"></a>2.2.2 非阻塞處理</h4><p>而 Node.js 就能有效解決這個問題，但相對地也會有弱勢。</p>\n<ol>\n<li>呼叫函式時，需傳入一個 callback，處理完畢後調用 callback</li>\n<li>一旦函式開始處理，不用等待結果，就繼續運行下一個函式</li>\n<li>整份檔案順暢跑完（但各函式不會同時處理完畢）！</li>\n</ol>\n<h3 id=\"2-3-Node-modules\"><a href=\"#2-3-Node-modules\" class=\"headerlink\" title=\"2.3 Node_modules\"></a>2.3 Node_modules</h3><p>Node.js 本身的 node_modules 就提供了相當多的套件可以使用，隨便舉幾個例子：</p>\n<ul>\n<li><code>http</code>：Web http request 處理</li>\n<li><code>fs</code>：文件處理</li>\n<li><code>path</code>：路徑處理</li>\n<li><code>url</code>：網址處理</li>\n<li><code>eventEmitter</code>：request 事件監聽處理</li>\n<li><code>uuid</code>：產生不重複 ID 的小工具</li>\n</ul>\n<p>而在部署時，並不需要將這些套件一起打包，只要在 config.json 的 dependencies 註明清楚，就可以透過 <code>npm install</code> 來安裝所有需要的套件包了。</p>\n<hr>\n<h2 id=\"3-開始-Node-s！\"><a href=\"#3-開始-Node-s！\" class=\"headerlink\" title=\"3. 開始 Node.s！\"></a>3. 開始 Node.s！</h2><h3 id=\"3-1-“Hello-World”\"><a href=\"#3-1-“Hello-World”\" class=\"headerlink\" title=\"3.1 “Hello World”\"></a>3.1 “Hello World”</h3><p>是的，學習一個新語言，當然都是從最基本的跟世界打個招呼來開始。首先知道如何運行它，然後才能一步步深入。</p>\n<ul>\n<li>檢查 Node.js 版本</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v <span class=\"comment\">// v10.16.0 // 看得到版本代表有成功安裝 Node.js</span></span><br><span class=\"line\">$ npm -v <span class=\"comment\">// 6.9.0 // 同時檢查 Node Package Manager 版本</span></span><br><span class=\"line\">$ node <span class=\"comment\">// 並跳轉至大於符號代表成功進入 Node 環境</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 Node.js 環境下，呼叫 <code>console</code> 輸出 Hello World</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>); <span class=\"comment\">// Node 環境下可以撰寫 JavaScript</span></span><br><span class=\"line\"><span class=\"title class_\">Hello</span> <span class=\"title class_\">World</span> <span class=\"comment\">// 這是 Node 吐出來的，成功使用 Node 了！</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> <span class=\"comment\">// 看到這個不要緊張，這是返回 console.log 這函數的值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他操作</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ .<span class=\"property\">help</span> <span class=\"comment\">// 查看 Node 幫助</span></span><br><span class=\"line\">$ .<span class=\"property\">exit</span> <span class=\"comment\">// 離開 Node</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-進一步的-Hello-World\"><a href=\"#3-2-進一步的-Hello-World\" class=\"headerlink\" title=\"3.2 進一步的 Hello World\"></a>3.2 進一步的 Hello World</h3><p>當然，我們不希望每次都在 Node.js 裡面打一堆程式碼，最好是能呼叫執行檔案。那麼具體的操作方法是怎麼樣呢？</p>\n<ol>\n<li>建立一個 helloworld.js 檔</li>\n<li>檔案內容為： <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;Hello Node.js!&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);</span><br></pre></td></tr></table></figure></li>\n<li>然後，在控制台使用 Node 運行這個檔案 <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node helloworld.<span class=\"property\">js</span> <span class=\"comment\">// 或 node helloworld</span></span><br><span class=\"line\"><span class=\"title class_\">Hello</span> <span class=\"title class_\">Node</span>.<span class=\"property\">js</span>!</span><br></pre></td></tr></table></figure></li>\n<li>成功使用 Node.js 呼叫檔案了！</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><hr>\n<h2 id=\"4-結語\"><a href=\"#4-結語\" class=\"headerlink\" title=\"4. 結語\"></a>4. 結語</h2><p>關於 Node.js 的入門學習，就到這邊告一段落了。接下來我會繼續學習如何使用 express 框架來開發 Node.js app，接著就要逐漸嘗試實作出即時聊天室或小遊戲啦！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/Node.js\" >Node.js - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=fBNz5xF-Kx4\" >Node.js Crash Course - Traversy Media<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://segmentfault.com/a/1190000008961775\" >Node.js之深入理解特性<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>由於公司有使用 Node.js 撰寫的專案，之後有維護需求，因此對 Node.js 一竅不通的我，只好趕快惡補。</p>","more":"<hr>\n<h2 id=\"1-Overview\"><a href=\"#1-Overview\" class=\"headerlink\" title=\"1. Overview\"></a>1. Overview</h2><h3 id=\"1-1-為什麼要學-Node-js\"><a href=\"#1-1-為什麼要學-Node-js\" class=\"headerlink\" title=\"1.1 為什麼要學 Node.js\"></a>1.1 為什麼要學 Node.js</h3><p>Node.js 有許多優勢，但對我而言最直接的原因就是，因為我在前端使用的是 JavaScript，Node.js 是使用 JavaScript 的後端語言，因此對於理解上，就少了一層障礙。</p>\n<ul>\n<li>使用 JavaScript 的後端語言</li>\n<li>能夠自己寫 web server</li>\n<li>非同步 IO，事件驅動的特性，降低等待時間與耗能</li>\n<li>許多第三方套件（如 express、socket…等等）</li>\n<li>入門簡單（<del>我不相信</del>）</li>\n</ul>\n<h3 id=\"1-2-基本認識-Node-js\"><a href=\"#1-2-基本認識-Node-js\" class=\"headerlink\" title=\"1.2 基本認識 Node.js\"></a>1.2 基本認識 Node.js</h3><blockquote>\n<p><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/Node.js\" >Node.js - 維基百科<i class=\"fas fa-external-link-alt\"></i></a><br><a class=\"link\"   href=\"https://segmentfault.com/a/1190000008961775\" >Node.js之深入理解特性<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>如上所述，Node.js 的特性有以下幾個：</p>\n<ul>\n<li>事件驅動才調用 I&#x2F;O 資源，減少耗能</li>\n<li>使用 JavaScript 語言編寫</li>\n</ul>\n<h3 id=\"1-3-如何學習-Node-js\"><a href=\"#1-3-如何學習-Node-js\" class=\"headerlink\" title=\"1.3 如何學習 Node.js\"></a>1.3 如何學習 Node.js</h3><p>那麼要學習 Node.js，具體來說應該要理解哪些事呢？我列出幾個學習重點，也方便日後檢視是否真的學會了這些東西：</p>\n<ul>\n<li>JavaScript 基礎</li>\n<li>Unix &#x2F; Linux 指令</li>\n<li>理解伺服器端腳本</li>\n<li>模組和套件管理</li>\n<li>異步 I&#x2F;O 與 Async 流程控制庫（Input &#x2F; Output，網路、文件、資料庫、使用者輸入等等的進出）</li>\n<li>事件處理機制</li>\n<li>Node.js 與 AJAX</li>\n<li>跨平台與跨瀏覽器的相容</li>\n<li>TCP&#x2F;UDP 網路程式設計</li>\n<li>HTTP&#x2F;HTTPS 應用程式設計</li>\n<li>Node.js 與資料庫互動</li>\n</ul>\n<h3 id=\"1-4-Node-js-可以做些什麼？\"><a href=\"#1-4-Node-js-可以做些什麼？\" class=\"headerlink\" title=\"1.4 Node.js 可以做些什麼？\"></a>1.4 Node.js 可以做些什麼？</h3><ul>\n<li>撰寫 REST APIs</li>\n<li>即時服務（線上聊天室、連線遊戲）</li>\n<li>串接資料庫、blog、社群平台</li>\n</ul>\n<p>我認為伺服器最主要功能就是做資源的處理，而前端是接口與呈現。所以在初步學習了 Node.js 之後，應該就會朝撰寫 API、串 WebSocket、串資料庫等方向去進一步探索吧。畢竟學程式就是要做出想做的作品嘛。</p>\n<hr>\n<h2 id=\"2-Node-js-基本概念\"><a href=\"#2-Node-js-基本概念\" class=\"headerlink\" title=\"2. Node.js 基本概念\"></a>2. Node.js 基本概念</h2><h3 id=\"2-1-線程處理與事件循環\"><a href=\"#2-1-線程處理與事件循環\" class=\"headerlink\" title=\"2.1 線程處理與事件循環\"></a>2.1 線程處理與事件循環</h3><h4 id=\"2-1-1-線程處理\"><a href=\"#2-1-1-線程處理\" class=\"headerlink\" title=\"2.1.1 線程處理\"></a>2.1.1 線程處理</h4><ol>\n<li>收到 request</li>\n<li>thread 應對</li>\n<li>request 處理完成，thread 釋放</li>\n</ol>\n<p>所謂線程處理，當收到請求時就依照以上步驟處理，因此當同時湧入大量請求時，伺服器負荷就會提高。例如 Apache 6,7,8,9 等版本。</p>\n<h4 id=\"2-1-2-事件循環\"><a href=\"#2-1-2-事件循環\" class=\"headerlink\" title=\"2.1.2 事件循環\"></a>2.1.2 事件循環</h4><p>Node.js 的事件循環特性就能比較好地 handle 這問題，他的運作方式如下：</p>\n<ol>\n<li>開一個事件等待循環（event loop）</li>\n<li>收到 request</li>\n<li>將 request 塞入處理隊列中，然後繼續監聽其他 request</li>\n<li>request 處理完成後，調用 I&#x2F;O，結束 request</li>\n</ol>\n<p>也就是說，Node.js 以一個監聽器來處理 request 的「請求」與「完成」，並不會從頭到尾監聽，而只在這兩種事件出現時才調用 I&#x2F;O 資源。</p>\n<h3 id=\"2-2-阻塞處理／非阻塞處理\"><a href=\"#2-2-阻塞處理／非阻塞處理\" class=\"headerlink\" title=\"2.2 阻塞處理／非阻塞處理\"></a>2.2 阻塞處理／非阻塞處理</h3><h4 id=\"2-2-1-阻塞處理\"><a href=\"#2-2-1-阻塞處理\" class=\"headerlink\" title=\"2.2.1 阻塞處理\"></a>2.2.1 阻塞處理</h4><p>會發生阻塞處理的語言有：Java、Ruby、PHP、Asp.Net 等，因為他們會照以下方式處理程序：</p>\n<ol>\n<li>先執行的函式尚未處理完，不會執行下一個函式</li>\n<li>所有的函式都要等待前一個函式處理完</li>\n<li>塞車</li>\n</ol>\n<h4 id=\"2-2-2-非阻塞處理\"><a href=\"#2-2-2-非阻塞處理\" class=\"headerlink\" title=\"2.2.2 非阻塞處理\"></a>2.2.2 非阻塞處理</h4><p>而 Node.js 就能有效解決這個問題，但相對地也會有弱勢。</p>\n<ol>\n<li>呼叫函式時，需傳入一個 callback，處理完畢後調用 callback</li>\n<li>一旦函式開始處理，不用等待結果，就繼續運行下一個函式</li>\n<li>整份檔案順暢跑完（但各函式不會同時處理完畢）！</li>\n</ol>\n<h3 id=\"2-3-Node-modules\"><a href=\"#2-3-Node-modules\" class=\"headerlink\" title=\"2.3 Node_modules\"></a>2.3 Node_modules</h3><p>Node.js 本身的 node_modules 就提供了相當多的套件可以使用，隨便舉幾個例子：</p>\n<ul>\n<li><code>http</code>：Web http request 處理</li>\n<li><code>fs</code>：文件處理</li>\n<li><code>path</code>：路徑處理</li>\n<li><code>url</code>：網址處理</li>\n<li><code>eventEmitter</code>：request 事件監聽處理</li>\n<li><code>uuid</code>：產生不重複 ID 的小工具</li>\n</ul>\n<p>而在部署時，並不需要將這些套件一起打包，只要在 config.json 的 dependencies 註明清楚，就可以透過 <code>npm install</code> 來安裝所有需要的套件包了。</p>\n<hr>\n<h2 id=\"3-開始-Node-s！\"><a href=\"#3-開始-Node-s！\" class=\"headerlink\" title=\"3. 開始 Node.s！\"></a>3. 開始 Node.s！</h2><h3 id=\"3-1-“Hello-World”\"><a href=\"#3-1-“Hello-World”\" class=\"headerlink\" title=\"3.1 “Hello World”\"></a>3.1 “Hello World”</h3><p>是的，學習一個新語言，當然都是從最基本的跟世界打個招呼來開始。首先知道如何運行它，然後才能一步步深入。</p>\n<ul>\n<li>檢查 Node.js 版本</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node -v <span class=\"comment\">// v10.16.0 // 看得到版本代表有成功安裝 Node.js</span></span><br><span class=\"line\">$ npm -v <span class=\"comment\">// 6.9.0 // 同時檢查 Node Package Manager 版本</span></span><br><span class=\"line\">$ node <span class=\"comment\">// 並跳轉至大於符號代表成功進入 Node 環境</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 Node.js 環境下，呼叫 <code>console</code> 輸出 Hello World</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Hello World&quot;</span>); <span class=\"comment\">// Node 環境下可以撰寫 JavaScript</span></span><br><span class=\"line\"><span class=\"title class_\">Hello</span> <span class=\"title class_\">World</span> <span class=\"comment\">// 這是 Node 吐出來的，成功使用 Node 了！</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> <span class=\"comment\">// 看到這個不要緊張，這是返回 console.log 這函數的值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他操作</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ .<span class=\"property\">help</span> <span class=\"comment\">// 查看 Node 幫助</span></span><br><span class=\"line\">$ .<span class=\"property\">exit</span> <span class=\"comment\">// 離開 Node</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-進一步的-Hello-World\"><a href=\"#3-2-進一步的-Hello-World\" class=\"headerlink\" title=\"3.2 進一步的 Hello World\"></a>3.2 進一步的 Hello World</h3><p>當然，我們不希望每次都在 Node.js 裡面打一堆程式碼，最好是能呼叫執行檔案。那麼具體的操作方法是怎麼樣呢？</p>\n<ol>\n<li>建立一個 helloworld.js 檔</li>\n<li>檔案內容為： <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;Hello Node.js!&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);</span><br></pre></td></tr></table></figure></li>\n<li>然後，在控制台使用 Node 運行這個檔案 <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node helloworld.<span class=\"property\">js</span> <span class=\"comment\">// 或 node helloworld</span></span><br><span class=\"line\"><span class=\"title class_\">Hello</span> <span class=\"title class_\">Node</span>.<span class=\"property\">js</span>!</span><br></pre></td></tr></table></figure></li>\n<li>成功使用 Node.js 呼叫檔案了！</li>\n</ol>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><hr>\n<h2 id=\"4-結語\"><a href=\"#4-結語\" class=\"headerlink\" title=\"4. 結語\"></a>4. 結語</h2><p>關於 Node.js 的入門學習，就到這邊告一段落了。接下來我會繼續學習如何使用 express 框架來開發 Node.js app，接著就要逐漸嘗試實作出即時聊天室或小遊戲啦！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/Node.js\" >Node.js - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=fBNz5xF-Kx4\" >Node.js Crash Course - Traversy Media<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://segmentfault.com/a/1190000008961775\" >Node.js之深入理解特性<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"OOP 學習筆記 - 什麼是物件導向程式設計？跟前端開發有什麼關係？","date":"2021-11-23T11:57:57.000Z","_content":"\n近來在開發網頁時，逐漸能感受到事先訂好類別規格的重要性。比方說，這次要新增的功能是「股票觀察清單」，若能事先定義好觀察清單、觀察對象（EX: 股票）、觀察清單的行為（EX: 建立、編輯、移除），那麼在開發時會清楚許多，往後若要為這功能增加或改動內容（維護階段），都可以從源頭來改。降低 bug 發生機率的同時，也能讓其他同事更迅速理解自己寫的架構，減少溝通鴻溝。為此，該來將先前粗略讀過的「物件導向程式設計」概念，拿出來再理解一遍了。\n\n<!--more-->\n\n---\n## 什麼是物件導向程式設計（Object-Oriented Programming）？\n\n> 根據 [《UML 物件導向系統分析與設計》](https://www.sanmin.com.tw/product/index/000747473)，在物件導向設計中，類別（Class）的實例（Instance）就叫做物件（Object）。物件作為程式的基本單元，每個物件都是獨立的個體，應該要能夠接收資料、處理資料、傳出資料，採用物件導向來設計程式，能夠大大提升程式的靈活性與可維護性。\n\n* 類（Class）：定義一個東西的抽象特徵。包含資料的形式以及對資料的操作。\n* 物件（Object）：是類的實例，類產生的具體例子。\n\n就像這類文章常見的那個例子一樣：\n```javascript=\n// 宣告一個 class，包含屬性以及方法\nclass Person {\n    name;\n    \n    constructor(pname) {\n        this.name = pname;\n    }\n    \n    murmur() {\n        console.log(\"我是\" + this.name + \"嗎?\");\n    }\n}\n\n// 宣告實例\nlet ming = new Person(\"小明\");\nlet hua  = new Person(\"小花\");\nming.murmur();  // 我是小明嗎?\nhua.murmur();   // 我是小花嗎?\n```\n\n`Person` 是一個 Class，而 `new Person()` 則會建立一個實例 Object。\n\n在初步了解物件導向是什麼了之後，就來看看它有哪些特性，以及需要依照怎樣的原則來設計程式吧。\n\n---\n## 物件導向四大特性\n\n物件導向有四個特性：\n* 抽象（Abstraction）\n* 封裝（Encapsulation）\n* 繼承（Inheritance）\n* 多型（Polymorphism）\n\n說真的，當時的我看到這些鬼東西，真是害怕極了。如今卻能大致理解這四項特性分別是在描述什麼，應該是有所成長了吧。\n\n### 1. 抽象（Abstraction）\n我自己覺得這可能是最難理解的概念，但是一但理解了抽象性，對於思考程式如何設計會有相當大的幫助。其實換個角度想，我們在生物課不就學過抽象性了嗎？\n\n> 不信你看：[生物分類法 - 維基百科](https://www.itsfun.com.tw/%E7%95%8C%E9%96%80%E7%B6%B1%E7%9B%AE%E7%A7%91%E5%B1%AC%E7%A8%AE/wiki-169944-298424)\n\n就我目前的理解，抽象就是一種分類的方法。透過整理來將一類對象抽象化，而定義出這個類別的特性及行為，以幫助人快速識別對象。這個道理是從大自然中學習來的，而套用在程式設計上也相當合用。\n\n就像上面的例子一樣，小明與小花都屬於 `Person` 這個 Class，但各自的 `name` 及 `murmur` 的內容卻又不同。\n\n### 2. 封裝（Encapsulation）\n封裝是將 Class 的部份內容包裝、隱藏起來的方法。這是一種防止外界呼叫、存取物件內部實作細節的手段。聽起來很美好，問題是親愛的 `JavaScript` 中並沒有簡單明瞭的設計來實現物件導向封裝特性。幸好，我們有 `TypeScript`。透過 `public` `private` `protected` 就能夠快速簡便地讓開發者及系統辨別公開或私有屬性。\n\n### 3. 繼承（Inheritance）\n一個物件有時會在父類別底下延伸出子類別，子類別會比父類別更加具體（但不是實例），且繼承父類別的屬性。\n\n比方說開頭提到的觀察清單類別，因為需要能夠容納「股票」類別以及「外匯」類別，就可以再分為「股票觀察清單類」及「外匯觀察清單類」。源頭都屬於觀察清單類別，但各自又多了部分不同的屬性。\n\n### 4. 多型（Polymorphism）\n由繼承產生的相關的不同類別，這些類別對同樣的呼叫，會給出不同的反應。這是什麼意思呢？讓我們修改一下開頭的案例：\n```javascript=\nclass Person {\n    murmur(){} // 此處定義了一個方法，但沒有內容\n}\n\nclass MalePerson extends Person {\n    murmur() {\n        console.log(\"我是男漢子!\"); // 定義內容\n    }\n}\n\nclass FemalePerson extends Person {\n    murmur() {\n        console.log(\"我是女漢子!\"); // 定義內容\n    }\n}\n\nlet man = new MalePerson();\nlet woman = new FemalePerson();\nman.murmur();   // 我是男漢子!\nwoman.murmur(); // 我是女漢子!\n```\n\n如上所示，在新類別繼承了 `Person` 這個類別時，也一併繼承了它的 `murmur()` 方法，並各自覆蓋了方法的內容。接著建立實例並呼叫此方法的時候，就會印出各自的內容，這就是多型。\n\n---\n## 物件導向設計 SOLID 原則\n\n> [SOLID (物件導向設計) - 維基百科](https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))\n> 每個專案沒聽到一次就渾身不對勁的 S.O.L.I.D. 原則\n\n`SOLID` 原則是取以下五個原則的開頭組合而成，剛好也表示依循這樣原則的程式設計會很「穩固」。因為要深入淺出這五個原則，以我目前的功力還辦不到，所以只能簡單做個筆記。有錯誤的部分也歡迎隨時指正。\n* 單一職責原則（Single responsibility principle, SRP）\n* 開放封閉原則（Open-Close principle, OCP）\n* 里氏替換原則（Liskov substitution principle, LSP）\n* 介面隔離原則（Interface segregation principle, ISP）\n* 依賴反轉原則（Dependency inversion principle, DIP）\n\n### 1. 單一職責原則(Single responsibility principle, SRP)\n\n```\n一個模組應該只對一個角色負責。\n```\n\n依我的理解，這意思就是一個 `calcTotal()` 的函式，不應該同時做多件事情，例如修改 `CompanyWallet.total` 以及 `CustomerWallet.total`，以防哪天因為變更了一點點 `calcTotal()` 的程式碼，卻影響到其他內容，這是會出大事的。\n\n那麼依循這個原則，可以這樣做：\n\n```typescript=\n// 建立一個抽象的介面，包含計算函式但不實作\nclass TotalCalculator {\n    public function calcTotal(): number;\n}\n\n// 各自繼承並實作計算函式的內容\nclass CompanyWallet extends TotalCalculator {\n    private total: number;\n    public function calcTotal() {\n        // 公司的計算方式\n    }\n}\nclass CustomerWallet extends TotalCalculator {\n    private total: number;\n    public function calcTotal() {\n        // 客戶的計算方式\n    }\n}\n```\n\n目前的我還不能很好地舉例解釋單一職責原則，或許是因為尚未滲透進骨髓，必須再繼續加深印象才行。\n\n\n### 2. 開放封閉原則(Open-Close principle, OCP)\n\n```\n開放擴展：當需求變更時，模組可以擴充功能。\n封閉修改：當進行擴沖時，模組不需修改既有的程式碼。\n```\n\n當一個已經完成的模組要加上新功能時，不應修改原本的程式碼，否則很有可能會在想像不到的地方產生 bug，這是很好理解的。\n\n### 3. 里氏替換原則(Liskov substitution principle, LSP)\n\n```\n子類別要能取代它的父類別。\n```\n\n大意是說，子類別繼承了父類別，實作時需依循下列原則：\n* 子類別的先決條件不能比父類強，但可以比父類弱\n* 子類別的後置條件不能比父類弱，但可以比父類強\n* 父類別的不變條件必須被繼承\n\n乍看很抽象，但用具體例子來看的話，就很好理解。基本上就是子類別實作的範疇不應跳脫父類別，而應該在父類別的範疇內實作。\n\n### 4. 介面隔離原則(Interface segregation principle, ISP)\n\n```\n使用不到的功能，不應被呼叫。\n```\n\n一樣又是很抽象的說明，具體舉個例子就是：\n```javascript=\nclass Website {\n    public function login();\n    public function logout();\n    public function adminMode();\n}\nclass Client {\n    site = new Website();\n    site.login();\n    site.logout();\n    site.adminMode(); // 明明是 client 為什麼可以開啟 admin?\n}\n```\n\n因為 `adminMode()` 並不是開放給所有人使用的，但偏偏 client 又可以呼叫它，這就表示違反了介面隔離原則。此時需要將 `adminMode()` 隔離出來，只有管理員可以實作這個介面，並呼叫本功能。\n\n### 5. 依賴反轉原則(Dependency inversion principle, DIP)\n\n```\n高層模組不應依賴低層模組，而都應該依賴抽象。\n```\n\n當高低模組之間有依賴關係時，此時就會有危險產生。萬一高層模組依賴低層模組，而低層模組的實作內容修改了，高層模組就會發生預期外的結果，要不然就必須去修改高層模組內容，出現高耦合的狀況。\n\n為了避免，可以在高低模組之間抽出一個抽象的介面，透過抽象去實作方法，這樣就可以降低耦合。\n\n\n以上就是 `SOLID` 原則。以我目前的程度，大概只有一知半解，而且要依照原則來設計程式，又比單純理解物件導向更難了。\n\n但我相信 `OOP` 能讓程式變得更好，所以我會持續精進 `SOLID`！\n\n---\n## OOP 如何應用在前端開發？\n\n前端工程師在學習的過程中幾乎都會看到「`JavaScript` 是一個基於物件導向的語言」這句話，接著就會看到原型鏈（Prototype）相關的介紹。當時的我還不是很能把這兩件事串在一起，如今看來之間的關聯再明顯不過了。\n\n再回到前面的例子，其實 `JavaScript` 的 Class 並不是真正的類別，而只是個偽裝過的 function，也就是常聽人家說的那一句：「Class 只是 ES6 的語法糖」。但是 ES6 究竟為何要這樣欺騙我們的感情呢？還不是為了讓你開發上更方便（巴頭）！關於這件事，MDN 是這樣說的：\n\n> [繼承與原型鏈 - MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n> JavaScript 是個沒有實做 class 關鍵字的動態語言，所以會對那些基於類別（class-based）語言（如 Java 或 C++）背景出身的開發者來說會有點困惑。（在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JavaScript 仍然是基於原型（prototype-based）的語言）。\n\n我目前對於 `Prototype` 還沒有系統性地去理解過，只大致上知道是怎麼回事而已，但這不是本篇主旨，所以先跳過。\n\n我關心的是，究竟 <strong>OOP 如何應用在前端開發</strong>？\n\n### 搭配神兵利器 `TypeScript`\n\n因為目前公司使用的前端框架是 `Angular`，使用的主要語言是 `TypeScript`，也因此潛移默化地習慣了事先定義型別、類別的作法，自然養成好習慣。現在要我用原生 JS 開發，如果要像 `TypeScript` 那樣定義型別，要花一大堆功夫，心裡會很不是滋味。\n\n如果 `OOP` 搭配使用 `TypeScript`，那麼在開發事前就能將類別、資料型別定義得更清楚了，倘若再用上 `UML`（這才發現我沒寫過 `UML` 的筆記，看來也該補一篇了）來分析專案，在前期就徹底分析需求，就可以大大減少遺漏需求的問題，也可以減少發生後端都已經部署好 API 了，前端卻在串接過程中發現資料格式不合用想要改結構的情況。這有時候是會影響到 DB schema 的，若能事先定好，就能在前期發現該釐清的事項。\n\n因此接下來我會用 `TypeScript` 來呈現 `JavaScript` 的部分。\n\n### 從「物件」作為出發點來思考\n\n程式是「本質先於存在」的產物，必須先有「需求」，而後才有對應的「解決方案」。若要在專案開發中導入 `OOP`，必須從需求分析切入，後續發展才能順暢。讓我們先假設一個需求：\n\n```\n開發一個檔案上傳管理系統。\n```\n\n好啦，老實說就是這個經驗：[後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！](https://gkfat.github.io/2021/09/05/python-file-upload-service)，不過當時的我並沒有將物件導向設計應用進去，因此若現在回頭看程式碼，不吐血才怪。\n\n現在從頭來思考這個需求，我會先做 `UML` 中的類圖分析，拆解出這個需求中包含下列類（Class）：\n\n```typescript=\n// 檔案\nclass UploadFile {\n    public id: number;      // 檔案 ID\n    public name: string;    // 檔名\n    public content: string; // 檔案內容，以 base64 儲存\n    public path: string;    // 上傳的路徑\n}\n\n// 使用者\nclass User {\n    public id: number;      // 使用者 ID\n    public name: string;    // 使用者名稱\n    public uploadFile(){}   // fn: 上傳檔案\n    public removeFile(){}   // fn: 刪除檔案\n    public readRecord(){}   // fn: 查詢上傳紀錄\n}\n\n// 上傳紀錄\nclass UploadRecord {\n    public id: number;      // 上傳紀錄 ID\n    public fileID: number;  // 檔案 ID\n    public userID: number;  // 使用者 ID\n    public uploadTime: Date;// 上傳時間\n}\n```\n\n花個 3 分鐘簡單拆解而已，就能大致看出個輪廓了（當然要能開始開發還遠遠不夠）。類圖分析完後，接著就能用活動圖來分析使用者、前端、後端、資料庫之間的活動，以及活動內容，再來就能推出各自要開發的項目細節了。\n\n---\n## 結論\n\n如此麻煩地套用 `OOP`，究竟會產生哪些影響？\n* 分析：搭配 `UML` 能更系統化分析專案，在前期就盡可能釐清 spec\n* 開發：開發過程中能清楚正在處理的資料型別，不用瞎子摸象亂猜一通\n* 協作：他人能更迅速理解程式碼的邏輯，工程師間的溝通更順暢\n* 維護：debug 或修改屬性、擴充功能都更方便\n\n最重要的，是幫助自己在程式設計的領域中提升思維高度，以更全面的角度來看待整個專案，對於成長很有幫助。\n\n所以，一起來學吧！\n\n---\n參考資料：\n* [物件導向程式設計 - 維基百科](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)\n* [UML 物件導向系統分析與設計 - Jim Arlow](https://www.sanmin.com.tw/product/index/000747473)\n* [TypeScript | 從 TS 開始學習物件導向 - Interface 用法 - 神Q超人](https://medium.com/enjoy-life-enjoy-coding/typescript-%E5%BE%9E-ts-%E9%96%8B%E5%A7%8B%E5%AD%B8%E7%BF%92%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-interface-%E7%94%A8%E6%B3%95-77fd0959769f)","source":"_posts/oop-basic.md","raw":"---\ntitle: OOP 學習筆記 - 什麼是物件導向程式設計？跟前端開發有什麼關係？\ndate: 2021-11-23 19:57:57\ntags: [OOP, TypeScript, SOLID]\n---\n\n近來在開發網頁時，逐漸能感受到事先訂好類別規格的重要性。比方說，這次要新增的功能是「股票觀察清單」，若能事先定義好觀察清單、觀察對象（EX: 股票）、觀察清單的行為（EX: 建立、編輯、移除），那麼在開發時會清楚許多，往後若要為這功能增加或改動內容（維護階段），都可以從源頭來改。降低 bug 發生機率的同時，也能讓其他同事更迅速理解自己寫的架構，減少溝通鴻溝。為此，該來將先前粗略讀過的「物件導向程式設計」概念，拿出來再理解一遍了。\n\n<!--more-->\n\n---\n## 什麼是物件導向程式設計（Object-Oriented Programming）？\n\n> 根據 [《UML 物件導向系統分析與設計》](https://www.sanmin.com.tw/product/index/000747473)，在物件導向設計中，類別（Class）的實例（Instance）就叫做物件（Object）。物件作為程式的基本單元，每個物件都是獨立的個體，應該要能夠接收資料、處理資料、傳出資料，採用物件導向來設計程式，能夠大大提升程式的靈活性與可維護性。\n\n* 類（Class）：定義一個東西的抽象特徵。包含資料的形式以及對資料的操作。\n* 物件（Object）：是類的實例，類產生的具體例子。\n\n就像這類文章常見的那個例子一樣：\n```javascript=\n// 宣告一個 class，包含屬性以及方法\nclass Person {\n    name;\n    \n    constructor(pname) {\n        this.name = pname;\n    }\n    \n    murmur() {\n        console.log(\"我是\" + this.name + \"嗎?\");\n    }\n}\n\n// 宣告實例\nlet ming = new Person(\"小明\");\nlet hua  = new Person(\"小花\");\nming.murmur();  // 我是小明嗎?\nhua.murmur();   // 我是小花嗎?\n```\n\n`Person` 是一個 Class，而 `new Person()` 則會建立一個實例 Object。\n\n在初步了解物件導向是什麼了之後，就來看看它有哪些特性，以及需要依照怎樣的原則來設計程式吧。\n\n---\n## 物件導向四大特性\n\n物件導向有四個特性：\n* 抽象（Abstraction）\n* 封裝（Encapsulation）\n* 繼承（Inheritance）\n* 多型（Polymorphism）\n\n說真的，當時的我看到這些鬼東西，真是害怕極了。如今卻能大致理解這四項特性分別是在描述什麼，應該是有所成長了吧。\n\n### 1. 抽象（Abstraction）\n我自己覺得這可能是最難理解的概念，但是一但理解了抽象性，對於思考程式如何設計會有相當大的幫助。其實換個角度想，我們在生物課不就學過抽象性了嗎？\n\n> 不信你看：[生物分類法 - 維基百科](https://www.itsfun.com.tw/%E7%95%8C%E9%96%80%E7%B6%B1%E7%9B%AE%E7%A7%91%E5%B1%AC%E7%A8%AE/wiki-169944-298424)\n\n就我目前的理解，抽象就是一種分類的方法。透過整理來將一類對象抽象化，而定義出這個類別的特性及行為，以幫助人快速識別對象。這個道理是從大自然中學習來的，而套用在程式設計上也相當合用。\n\n就像上面的例子一樣，小明與小花都屬於 `Person` 這個 Class，但各自的 `name` 及 `murmur` 的內容卻又不同。\n\n### 2. 封裝（Encapsulation）\n封裝是將 Class 的部份內容包裝、隱藏起來的方法。這是一種防止外界呼叫、存取物件內部實作細節的手段。聽起來很美好，問題是親愛的 `JavaScript` 中並沒有簡單明瞭的設計來實現物件導向封裝特性。幸好，我們有 `TypeScript`。透過 `public` `private` `protected` 就能夠快速簡便地讓開發者及系統辨別公開或私有屬性。\n\n### 3. 繼承（Inheritance）\n一個物件有時會在父類別底下延伸出子類別，子類別會比父類別更加具體（但不是實例），且繼承父類別的屬性。\n\n比方說開頭提到的觀察清單類別，因為需要能夠容納「股票」類別以及「外匯」類別，就可以再分為「股票觀察清單類」及「外匯觀察清單類」。源頭都屬於觀察清單類別，但各自又多了部分不同的屬性。\n\n### 4. 多型（Polymorphism）\n由繼承產生的相關的不同類別，這些類別對同樣的呼叫，會給出不同的反應。這是什麼意思呢？讓我們修改一下開頭的案例：\n```javascript=\nclass Person {\n    murmur(){} // 此處定義了一個方法，但沒有內容\n}\n\nclass MalePerson extends Person {\n    murmur() {\n        console.log(\"我是男漢子!\"); // 定義內容\n    }\n}\n\nclass FemalePerson extends Person {\n    murmur() {\n        console.log(\"我是女漢子!\"); // 定義內容\n    }\n}\n\nlet man = new MalePerson();\nlet woman = new FemalePerson();\nman.murmur();   // 我是男漢子!\nwoman.murmur(); // 我是女漢子!\n```\n\n如上所示，在新類別繼承了 `Person` 這個類別時，也一併繼承了它的 `murmur()` 方法，並各自覆蓋了方法的內容。接著建立實例並呼叫此方法的時候，就會印出各自的內容，這就是多型。\n\n---\n## 物件導向設計 SOLID 原則\n\n> [SOLID (物件導向設計) - 維基百科](https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1))\n> 每個專案沒聽到一次就渾身不對勁的 S.O.L.I.D. 原則\n\n`SOLID` 原則是取以下五個原則的開頭組合而成，剛好也表示依循這樣原則的程式設計會很「穩固」。因為要深入淺出這五個原則，以我目前的功力還辦不到，所以只能簡單做個筆記。有錯誤的部分也歡迎隨時指正。\n* 單一職責原則（Single responsibility principle, SRP）\n* 開放封閉原則（Open-Close principle, OCP）\n* 里氏替換原則（Liskov substitution principle, LSP）\n* 介面隔離原則（Interface segregation principle, ISP）\n* 依賴反轉原則（Dependency inversion principle, DIP）\n\n### 1. 單一職責原則(Single responsibility principle, SRP)\n\n```\n一個模組應該只對一個角色負責。\n```\n\n依我的理解，這意思就是一個 `calcTotal()` 的函式，不應該同時做多件事情，例如修改 `CompanyWallet.total` 以及 `CustomerWallet.total`，以防哪天因為變更了一點點 `calcTotal()` 的程式碼，卻影響到其他內容，這是會出大事的。\n\n那麼依循這個原則，可以這樣做：\n\n```typescript=\n// 建立一個抽象的介面，包含計算函式但不實作\nclass TotalCalculator {\n    public function calcTotal(): number;\n}\n\n// 各自繼承並實作計算函式的內容\nclass CompanyWallet extends TotalCalculator {\n    private total: number;\n    public function calcTotal() {\n        // 公司的計算方式\n    }\n}\nclass CustomerWallet extends TotalCalculator {\n    private total: number;\n    public function calcTotal() {\n        // 客戶的計算方式\n    }\n}\n```\n\n目前的我還不能很好地舉例解釋單一職責原則，或許是因為尚未滲透進骨髓，必須再繼續加深印象才行。\n\n\n### 2. 開放封閉原則(Open-Close principle, OCP)\n\n```\n開放擴展：當需求變更時，模組可以擴充功能。\n封閉修改：當進行擴沖時，模組不需修改既有的程式碼。\n```\n\n當一個已經完成的模組要加上新功能時，不應修改原本的程式碼，否則很有可能會在想像不到的地方產生 bug，這是很好理解的。\n\n### 3. 里氏替換原則(Liskov substitution principle, LSP)\n\n```\n子類別要能取代它的父類別。\n```\n\n大意是說，子類別繼承了父類別，實作時需依循下列原則：\n* 子類別的先決條件不能比父類強，但可以比父類弱\n* 子類別的後置條件不能比父類弱，但可以比父類強\n* 父類別的不變條件必須被繼承\n\n乍看很抽象，但用具體例子來看的話，就很好理解。基本上就是子類別實作的範疇不應跳脫父類別，而應該在父類別的範疇內實作。\n\n### 4. 介面隔離原則(Interface segregation principle, ISP)\n\n```\n使用不到的功能，不應被呼叫。\n```\n\n一樣又是很抽象的說明，具體舉個例子就是：\n```javascript=\nclass Website {\n    public function login();\n    public function logout();\n    public function adminMode();\n}\nclass Client {\n    site = new Website();\n    site.login();\n    site.logout();\n    site.adminMode(); // 明明是 client 為什麼可以開啟 admin?\n}\n```\n\n因為 `adminMode()` 並不是開放給所有人使用的，但偏偏 client 又可以呼叫它，這就表示違反了介面隔離原則。此時需要將 `adminMode()` 隔離出來，只有管理員可以實作這個介面，並呼叫本功能。\n\n### 5. 依賴反轉原則(Dependency inversion principle, DIP)\n\n```\n高層模組不應依賴低層模組，而都應該依賴抽象。\n```\n\n當高低模組之間有依賴關係時，此時就會有危險產生。萬一高層模組依賴低層模組，而低層模組的實作內容修改了，高層模組就會發生預期外的結果，要不然就必須去修改高層模組內容，出現高耦合的狀況。\n\n為了避免，可以在高低模組之間抽出一個抽象的介面，透過抽象去實作方法，這樣就可以降低耦合。\n\n\n以上就是 `SOLID` 原則。以我目前的程度，大概只有一知半解，而且要依照原則來設計程式，又比單純理解物件導向更難了。\n\n但我相信 `OOP` 能讓程式變得更好，所以我會持續精進 `SOLID`！\n\n---\n## OOP 如何應用在前端開發？\n\n前端工程師在學習的過程中幾乎都會看到「`JavaScript` 是一個基於物件導向的語言」這句話，接著就會看到原型鏈（Prototype）相關的介紹。當時的我還不是很能把這兩件事串在一起，如今看來之間的關聯再明顯不過了。\n\n再回到前面的例子，其實 `JavaScript` 的 Class 並不是真正的類別，而只是個偽裝過的 function，也就是常聽人家說的那一句：「Class 只是 ES6 的語法糖」。但是 ES6 究竟為何要這樣欺騙我們的感情呢？還不是為了讓你開發上更方便（巴頭）！關於這件事，MDN 是這樣說的：\n\n> [繼承與原型鏈 - MDN](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n> JavaScript 是個沒有實做 class 關鍵字的動態語言，所以會對那些基於類別（class-based）語言（如 Java 或 C++）背景出身的開發者來說會有點困惑。（在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JavaScript 仍然是基於原型（prototype-based）的語言）。\n\n我目前對於 `Prototype` 還沒有系統性地去理解過，只大致上知道是怎麼回事而已，但這不是本篇主旨，所以先跳過。\n\n我關心的是，究竟 <strong>OOP 如何應用在前端開發</strong>？\n\n### 搭配神兵利器 `TypeScript`\n\n因為目前公司使用的前端框架是 `Angular`，使用的主要語言是 `TypeScript`，也因此潛移默化地習慣了事先定義型別、類別的作法，自然養成好習慣。現在要我用原生 JS 開發，如果要像 `TypeScript` 那樣定義型別，要花一大堆功夫，心裡會很不是滋味。\n\n如果 `OOP` 搭配使用 `TypeScript`，那麼在開發事前就能將類別、資料型別定義得更清楚了，倘若再用上 `UML`（這才發現我沒寫過 `UML` 的筆記，看來也該補一篇了）來分析專案，在前期就徹底分析需求，就可以大大減少遺漏需求的問題，也可以減少發生後端都已經部署好 API 了，前端卻在串接過程中發現資料格式不合用想要改結構的情況。這有時候是會影響到 DB schema 的，若能事先定好，就能在前期發現該釐清的事項。\n\n因此接下來我會用 `TypeScript` 來呈現 `JavaScript` 的部分。\n\n### 從「物件」作為出發點來思考\n\n程式是「本質先於存在」的產物，必須先有「需求」，而後才有對應的「解決方案」。若要在專案開發中導入 `OOP`，必須從需求分析切入，後續發展才能順暢。讓我們先假設一個需求：\n\n```\n開發一個檔案上傳管理系統。\n```\n\n好啦，老實說就是這個經驗：[後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！](https://gkfat.github.io/2021/09/05/python-file-upload-service)，不過當時的我並沒有將物件導向設計應用進去，因此若現在回頭看程式碼，不吐血才怪。\n\n現在從頭來思考這個需求，我會先做 `UML` 中的類圖分析，拆解出這個需求中包含下列類（Class）：\n\n```typescript=\n// 檔案\nclass UploadFile {\n    public id: number;      // 檔案 ID\n    public name: string;    // 檔名\n    public content: string; // 檔案內容，以 base64 儲存\n    public path: string;    // 上傳的路徑\n}\n\n// 使用者\nclass User {\n    public id: number;      // 使用者 ID\n    public name: string;    // 使用者名稱\n    public uploadFile(){}   // fn: 上傳檔案\n    public removeFile(){}   // fn: 刪除檔案\n    public readRecord(){}   // fn: 查詢上傳紀錄\n}\n\n// 上傳紀錄\nclass UploadRecord {\n    public id: number;      // 上傳紀錄 ID\n    public fileID: number;  // 檔案 ID\n    public userID: number;  // 使用者 ID\n    public uploadTime: Date;// 上傳時間\n}\n```\n\n花個 3 分鐘簡單拆解而已，就能大致看出個輪廓了（當然要能開始開發還遠遠不夠）。類圖分析完後，接著就能用活動圖來分析使用者、前端、後端、資料庫之間的活動，以及活動內容，再來就能推出各自要開發的項目細節了。\n\n---\n## 結論\n\n如此麻煩地套用 `OOP`，究竟會產生哪些影響？\n* 分析：搭配 `UML` 能更系統化分析專案，在前期就盡可能釐清 spec\n* 開發：開發過程中能清楚正在處理的資料型別，不用瞎子摸象亂猜一通\n* 協作：他人能更迅速理解程式碼的邏輯，工程師間的溝通更順暢\n* 維護：debug 或修改屬性、擴充功能都更方便\n\n最重要的，是幫助自己在程式設計的領域中提升思維高度，以更全面的角度來看待整個專案，對於成長很有幫助。\n\n所以，一起來學吧！\n\n---\n參考資料：\n* [物件導向程式設計 - 維基百科](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)\n* [UML 物件導向系統分析與設計 - Jim Arlow](https://www.sanmin.com.tw/product/index/000747473)\n* [TypeScript | 從 TS 開始學習物件導向 - Interface 用法 - 神Q超人](https://medium.com/enjoy-life-enjoy-coding/typescript-%E5%BE%9E-ts-%E9%96%8B%E5%A7%8B%E5%AD%B8%E7%BF%92%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-interface-%E7%94%A8%E6%B3%95-77fd0959769f)","slug":"oop-basic","published":1,"updated":"2022-03-12T12:58:21.353Z","_id":"cl0nustva001zz6us1eifgqof","comments":1,"layout":"post","photos":[],"link":"","content":"<p>近來在開發網頁時，逐漸能感受到事先訂好類別規格的重要性。比方說，這次要新增的功能是「股票觀察清單」，若能事先定義好觀察清單、觀察對象（EX: 股票）、觀察清單的行為（EX: 建立、編輯、移除），那麼在開發時會清楚許多，往後若要為這功能增加或改動內容（維護階段），都可以從源頭來改。降低 bug 發生機率的同時，也能讓其他同事更迅速理解自己寫的架構，減少溝通鴻溝。為此，該來將先前粗略讀過的「物件導向程式設計」概念，拿出來再理解一遍了。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"什麼是物件導向程式設計（Object-Oriented-Programming）？\"><a href=\"#什麼是物件導向程式設計（Object-Oriented-Programming）？\" class=\"headerlink\" title=\"什麼是物件導向程式設計（Object-Oriented Programming）？\"></a>什麼是物件導向程式設計（Object-Oriented Programming）？</h2><blockquote>\n<p>根據 <a class=\"link\"   href=\"https://www.sanmin.com.tw/product/index/000747473\" >《UML 物件導向系統分析與設計》<i class=\"fas fa-external-link-alt\"></i></a>，在物件導向設計中，類別（Class）的實例（Instance）就叫做物件（Object）。物件作為程式的基本單元，每個物件都是獨立的個體，應該要能夠接收資料、處理資料、傳出資料，採用物件導向來設計程式，能夠大大提升程式的靈活性與可維護性。</p>\n</blockquote>\n<ul>\n<li>類（Class）：定義一個東西的抽象特徵。包含資料的形式以及對資料的操作。</li>\n<li>物件（Object）：是類的實例，類產生的具體例子。</li>\n</ul>\n<p>就像這類文章常見的那個例子一樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 宣告一個 class，包含屬性以及方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">pname</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = pname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是&quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;嗎?&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宣告實例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ming = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小明&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> hua  = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小花&quot;</span>);</span><br><span class=\"line\">ming.<span class=\"title function_\">murmur</span>();  <span class=\"comment\">// 我是小明嗎?</span></span><br><span class=\"line\">hua.<span class=\"title function_\">murmur</span>();   <span class=\"comment\">// 我是小花嗎?</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Person</code> 是一個 Class，而 <code>new Person()</code> 則會建立一個實例 Object。</p>\n<p>在初步了解物件導向是什麼了之後，就來看看它有哪些特性，以及需要依照怎樣的原則來設計程式吧。</p>\n<hr>\n<h2 id=\"物件導向四大特性\"><a href=\"#物件導向四大特性\" class=\"headerlink\" title=\"物件導向四大特性\"></a>物件導向四大特性</h2><p>物件導向有四個特性：</p>\n<ul>\n<li>抽象（Abstraction）</li>\n<li>封裝（Encapsulation）</li>\n<li>繼承（Inheritance）</li>\n<li>多型（Polymorphism）</li>\n</ul>\n<p>說真的，當時的我看到這些鬼東西，真是害怕極了。如今卻能大致理解這四項特性分別是在描述什麼，應該是有所成長了吧。</p>\n<h3 id=\"1-抽象（Abstraction）\"><a href=\"#1-抽象（Abstraction）\" class=\"headerlink\" title=\"1. 抽象（Abstraction）\"></a>1. 抽象（Abstraction）</h3><p>我自己覺得這可能是最難理解的概念，但是一但理解了抽象性，對於思考程式如何設計會有相當大的幫助。其實換個角度想，我們在生物課不就學過抽象性了嗎？</p>\n<blockquote>\n<p>不信你看：<a class=\"link\"   href=\"https://www.itsfun.com.tw/%E7%95%8C%E9%96%80%E7%B6%B1%E7%9B%AE%E7%A7%91%E5%B1%AC%E7%A8%AE/wiki-169944-298424\" >生物分類法 - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>就我目前的理解，抽象就是一種分類的方法。透過整理來將一類對象抽象化，而定義出這個類別的特性及行為，以幫助人快速識別對象。這個道理是從大自然中學習來的，而套用在程式設計上也相當合用。</p>\n<p>就像上面的例子一樣，小明與小花都屬於 <code>Person</code> 這個 Class，但各自的 <code>name</code> 及 <code>murmur</code> 的內容卻又不同。</p>\n<h3 id=\"2-封裝（Encapsulation）\"><a href=\"#2-封裝（Encapsulation）\" class=\"headerlink\" title=\"2. 封裝（Encapsulation）\"></a>2. 封裝（Encapsulation）</h3><p>封裝是將 Class 的部份內容包裝、隱藏起來的方法。這是一種防止外界呼叫、存取物件內部實作細節的手段。聽起來很美好，問題是親愛的 <code>JavaScript</code> 中並沒有簡單明瞭的設計來實現物件導向封裝特性。幸好，我們有 <code>TypeScript</code>。透過 <code>public</code> <code>private</code> <code>protected</code> 就能夠快速簡便地讓開發者及系統辨別公開或私有屬性。</p>\n<h3 id=\"3-繼承（Inheritance）\"><a href=\"#3-繼承（Inheritance）\" class=\"headerlink\" title=\"3. 繼承（Inheritance）\"></a>3. 繼承（Inheritance）</h3><p>一個物件有時會在父類別底下延伸出子類別，子類別會比父類別更加具體（但不是實例），且繼承父類別的屬性。</p>\n<p>比方說開頭提到的觀察清單類別，因為需要能夠容納「股票」類別以及「外匯」類別，就可以再分為「股票觀察清單類」及「外匯觀察清單類」。源頭都屬於觀察清單類別，但各自又多了部分不同的屬性。</p>\n<h3 id=\"4-多型（Polymorphism）\"><a href=\"#4-多型（Polymorphism）\" class=\"headerlink\" title=\"4. 多型（Polymorphism）\"></a>4. 多型（Polymorphism）</h3><p>由繼承產生的相關的不同類別，這些類別對同樣的呼叫，會給出不同的反應。這是什麼意思呢？讓我們修改一下開頭的案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>)&#123;&#125; <span class=\"comment\">// 此處定義了一個方法，但沒有內容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MalePerson</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是男漢子!&quot;</span>); <span class=\"comment\">// 定義內容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FemalePerson</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是女漢子!&quot;</span>); <span class=\"comment\">// 定義內容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> man = <span class=\"keyword\">new</span> <span class=\"title class_\">MalePerson</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> woman = <span class=\"keyword\">new</span> <span class=\"title class_\">FemalePerson</span>();</span><br><span class=\"line\">man.<span class=\"title function_\">murmur</span>();   <span class=\"comment\">// 我是男漢子!</span></span><br><span class=\"line\">woman.<span class=\"title function_\">murmur</span>(); <span class=\"comment\">// 我是女漢子!</span></span><br></pre></td></tr></table></figure>\n\n<p>如上所示，在新類別繼承了 <code>Person</code> 這個類別時，也一併繼承了它的 <code>murmur()</code> 方法，並各自覆蓋了方法的內容。接著建立實例並呼叫此方法的時候，就會印出各自的內容，這就是多型。</p>\n<hr>\n<h2 id=\"物件導向設計-SOLID-原則\"><a href=\"#物件導向設計-SOLID-原則\" class=\"headerlink\" title=\"物件導向設計 SOLID 原則\"></a>物件導向設計 SOLID 原則</h2><blockquote>\n<p><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)\" >SOLID (物件導向設計) - 維基百科<i class=\"fas fa-external-link-alt\"></i></a><br>每個專案沒聽到一次就渾身不對勁的 S.O.L.I.D. 原則</p>\n</blockquote>\n<p><code>SOLID</code> 原則是取以下五個原則的開頭組合而成，剛好也表示依循這樣原則的程式設計會很「穩固」。因為要深入淺出這五個原則，以我目前的功力還辦不到，所以只能簡單做個筆記。有錯誤的部分也歡迎隨時指正。</p>\n<ul>\n<li>單一職責原則（Single responsibility principle, SRP）</li>\n<li>開放封閉原則（Open-Close principle, OCP）</li>\n<li>里氏替換原則（Liskov substitution principle, LSP）</li>\n<li>介面隔離原則（Interface segregation principle, ISP）</li>\n<li>依賴反轉原則（Dependency inversion principle, DIP）</li>\n</ul>\n<h3 id=\"1-單一職責原則-Single-responsibility-principle-SRP\"><a href=\"#1-單一職責原則-Single-responsibility-principle-SRP\" class=\"headerlink\" title=\"1. 單一職責原則(Single responsibility principle, SRP)\"></a>1. 單一職責原則(Single responsibility principle, SRP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一個模組應該只對一個角色負責。</span><br></pre></td></tr></table></figure>\n\n<p>依我的理解，這意思就是一個 <code>calcTotal()</code> 的函式，不應該同時做多件事情，例如修改 <code>CompanyWallet.total</code> 以及 <code>CustomerWallet.total</code>，以防哪天因為變更了一點點 <code>calcTotal()</code> 的程式碼，卻影響到其他內容，這是會出大事的。</p>\n<p>那麼依循這個原則，可以這樣做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立一個抽象的介面，包含計算函式但不實作</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 各自繼承並實作計算函式的內容</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CompanyWallet</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">total</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 公司的計算方式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomerWallet</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">total</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 客戶的計算方式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前的我還不能很好地舉例解釋單一職責原則，或許是因為尚未滲透進骨髓，必須再繼續加深印象才行。</p>\n<h3 id=\"2-開放封閉原則-Open-Close-principle-OCP\"><a href=\"#2-開放封閉原則-Open-Close-principle-OCP\" class=\"headerlink\" title=\"2. 開放封閉原則(Open-Close principle, OCP)\"></a>2. 開放封閉原則(Open-Close principle, OCP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">開放擴展：當需求變更時，模組可以擴充功能。</span><br><span class=\"line\">封閉修改：當進行擴沖時，模組不需修改既有的程式碼。</span><br></pre></td></tr></table></figure>\n\n<p>當一個已經完成的模組要加上新功能時，不應修改原本的程式碼，否則很有可能會在想像不到的地方產生 bug，這是很好理解的。</p>\n<h3 id=\"3-里氏替換原則-Liskov-substitution-principle-LSP\"><a href=\"#3-里氏替換原則-Liskov-substitution-principle-LSP\" class=\"headerlink\" title=\"3. 里氏替換原則(Liskov substitution principle, LSP)\"></a>3. 里氏替換原則(Liskov substitution principle, LSP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子類別要能取代它的父類別。</span><br></pre></td></tr></table></figure>\n\n<p>大意是說，子類別繼承了父類別，實作時需依循下列原則：</p>\n<ul>\n<li>子類別的先決條件不能比父類強，但可以比父類弱</li>\n<li>子類別的後置條件不能比父類弱，但可以比父類強</li>\n<li>父類別的不變條件必須被繼承</li>\n</ul>\n<p>乍看很抽象，但用具體例子來看的話，就很好理解。基本上就是子類別實作的範疇不應跳脫父類別，而應該在父類別的範疇內實作。</p>\n<h3 id=\"4-介面隔離原則-Interface-segregation-principle-ISP\"><a href=\"#4-介面隔離原則-Interface-segregation-principle-ISP\" class=\"headerlink\" title=\"4. 介面隔離原則(Interface segregation principle, ISP)\"></a>4. 介面隔離原則(Interface segregation principle, ISP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用不到的功能，不應被呼叫。</span><br></pre></td></tr></table></figure>\n\n<p>一樣又是很抽象的說明，具體舉個例子就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Website</span> &#123;</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">login</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">logout</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">adminMode</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    site = <span class=\"keyword\">new</span> <span class=\"title class_\">Website</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">login</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">logout</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">adminMode</span>(); <span class=\"comment\">// 明明是 client 為什麼可以開啟 admin?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因為 <code>adminMode()</code> 並不是開放給所有人使用的，但偏偏 client 又可以呼叫它，這就表示違反了介面隔離原則。此時需要將 <code>adminMode()</code> 隔離出來，只有管理員可以實作這個介面，並呼叫本功能。</p>\n<h3 id=\"5-依賴反轉原則-Dependency-inversion-principle-DIP\"><a href=\"#5-依賴反轉原則-Dependency-inversion-principle-DIP\" class=\"headerlink\" title=\"5. 依賴反轉原則(Dependency inversion principle, DIP)\"></a>5. 依賴反轉原則(Dependency inversion principle, DIP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高層模組不應依賴低層模組，而都應該依賴抽象。</span><br></pre></td></tr></table></figure>\n\n<p>當高低模組之間有依賴關係時，此時就會有危險產生。萬一高層模組依賴低層模組，而低層模組的實作內容修改了，高層模組就會發生預期外的結果，要不然就必須去修改高層模組內容，出現高耦合的狀況。</p>\n<p>為了避免，可以在高低模組之間抽出一個抽象的介面，透過抽象去實作方法，這樣就可以降低耦合。</p>\n<p>以上就是 <code>SOLID</code> 原則。以我目前的程度，大概只有一知半解，而且要依照原則來設計程式，又比單純理解物件導向更難了。</p>\n<p>但我相信 <code>OOP</code> 能讓程式變得更好，所以我會持續精進 <code>SOLID</code>！</p>\n<hr>\n<h2 id=\"OOP-如何應用在前端開發？\"><a href=\"#OOP-如何應用在前端開發？\" class=\"headerlink\" title=\"OOP 如何應用在前端開發？\"></a>OOP 如何應用在前端開發？</h2><p>前端工程師在學習的過程中幾乎都會看到「<code>JavaScript</code> 是一個基於物件導向的語言」這句話，接著就會看到原型鏈（Prototype）相關的介紹。當時的我還不是很能把這兩件事串在一起，如今看來之間的關聯再明顯不過了。</p>\n<p>再回到前面的例子，其實 <code>JavaScript</code> 的 Class 並不是真正的類別，而只是個偽裝過的 function，也就是常聽人家說的那一句：「Class 只是 ES6 的語法糖」。但是 ES6 究竟為何要這樣欺騙我們的感情呢？還不是為了讓你開發上更方便（巴頭）！關於這件事，MDN 是這樣說的：</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" >繼承與原型鏈 - MDN<i class=\"fas fa-external-link-alt\"></i></a><br>JavaScript 是個沒有實做 class 關鍵字的動態語言，所以會對那些基於類別（class-based）語言（如 Java 或 C++）背景出身的開發者來說會有點困惑。（在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JavaScript 仍然是基於原型（prototype-based）的語言）。</p>\n</blockquote>\n<p>我目前對於 <code>Prototype</code> 還沒有系統性地去理解過，只大致上知道是怎麼回事而已，但這不是本篇主旨，所以先跳過。</p>\n<p>我關心的是，究竟 <strong>OOP 如何應用在前端開發</strong>？</p>\n<h3 id=\"搭配神兵利器-TypeScript\"><a href=\"#搭配神兵利器-TypeScript\" class=\"headerlink\" title=\"搭配神兵利器 TypeScript\"></a>搭配神兵利器 <code>TypeScript</code></h3><p>因為目前公司使用的前端框架是 <code>Angular</code>，使用的主要語言是 <code>TypeScript</code>，也因此潛移默化地習慣了事先定義型別、類別的作法，自然養成好習慣。現在要我用原生 JS 開發，如果要像 <code>TypeScript</code> 那樣定義型別，要花一大堆功夫，心裡會很不是滋味。</p>\n<p>如果 <code>OOP</code> 搭配使用 <code>TypeScript</code>，那麼在開發事前就能將類別、資料型別定義得更清楚了，倘若再用上 <code>UML</code>（這才發現我沒寫過 <code>UML</code> 的筆記，看來也該補一篇了）來分析專案，在前期就徹底分析需求，就可以大大減少遺漏需求的問題，也可以減少發生後端都已經部署好 API 了，前端卻在串接過程中發現資料格式不合用想要改結構的情況。這有時候是會影響到 DB schema 的，若能事先定好，就能在前期發現該釐清的事項。</p>\n<p>因此接下來我會用 <code>TypeScript</code> 來呈現 <code>JavaScript</code> 的部分。</p>\n<h3 id=\"從「物件」作為出發點來思考\"><a href=\"#從「物件」作為出發點來思考\" class=\"headerlink\" title=\"從「物件」作為出發點來思考\"></a>從「物件」作為出發點來思考</h3><p>程式是「本質先於存在」的產物，必須先有「需求」，而後才有對應的「解決方案」。若要在專案開發中導入 <code>OOP</code>，必須從需求分析切入，後續發展才能順暢。讓我們先假設一個需求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">開發一個檔案上傳管理系統。</span><br></pre></td></tr></table></figure>\n\n<p>好啦，老實說就是這個經驗：<a href=\"https://gkfat.github.io/2021/09/05/python-file-upload-service\">後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！</a>，不過當時的我並沒有將物件導向設計應用進去，因此若現在回頭看程式碼，不吐血才怪。</p>\n<p>現在從頭來思考這個需求，我會先做 <code>UML</code> 中的類圖分析，拆解出這個需求中包含下列類（Class）：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 檔案</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UploadFile</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 檔案 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 檔名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>; <span class=\"comment\">// 檔案內容，以 base64 儲存</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 上傳的路徑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 使用者 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 使用者名稱</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">uploadFile</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 上傳檔案</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">removeFile</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 刪除檔案</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">readRecord</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 查詢上傳紀錄</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上傳紀錄</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UploadRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 上傳紀錄 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">fileID</span>: <span class=\"built_in\">number</span>;  <span class=\"comment\">// 檔案 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">userID</span>: <span class=\"built_in\">number</span>;  <span class=\"comment\">// 使用者 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">uploadTime</span>: <span class=\"title class_\">Date</span>;<span class=\"comment\">// 上傳時間</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花個 3 分鐘簡單拆解而已，就能大致看出個輪廓了（當然要能開始開發還遠遠不夠）。類圖分析完後，接著就能用活動圖來分析使用者、前端、後端、資料庫之間的活動，以及活動內容，再來就能推出各自要開發的項目細節了。</p>\n<hr>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>如此麻煩地套用 <code>OOP</code>，究竟會產生哪些影響？</p>\n<ul>\n<li>分析：搭配 <code>UML</code> 能更系統化分析專案，在前期就盡可能釐清 spec</li>\n<li>開發：開發過程中能清楚正在處理的資料型別，不用瞎子摸象亂猜一通</li>\n<li>協作：他人能更迅速理解程式碼的邏輯，工程師間的溝通更順暢</li>\n<li>維護：debug 或修改屬性、擴充功能都更方便</li>\n</ul>\n<p>最重要的，是幫助自己在程式設計的領域中提升思維高度，以更全面的角度來看待整個專案，對於成長很有幫助。</p>\n<p>所以，一起來學吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\" >物件導向程式設計 - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.sanmin.com.tw/product/index/000747473\" >UML 物件導向系統分析與設計 - Jim Arlow<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/enjoy-life-enjoy-coding/typescript-%E5%BE%9E-ts-%E9%96%8B%E5%A7%8B%E5%AD%B8%E7%BF%92%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-interface-%E7%94%A8%E6%B3%95-77fd0959769f\" >TypeScript | 從 TS 開始學習物件導向 - Interface 用法 - 神Q超人<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>近來在開發網頁時，逐漸能感受到事先訂好類別規格的重要性。比方說，這次要新增的功能是「股票觀察清單」，若能事先定義好觀察清單、觀察對象（EX: 股票）、觀察清單的行為（EX: 建立、編輯、移除），那麼在開發時會清楚許多，往後若要為這功能增加或改動內容（維護階段），都可以從源頭來改。降低 bug 發生機率的同時，也能讓其他同事更迅速理解自己寫的架構，減少溝通鴻溝。為此，該來將先前粗略讀過的「物件導向程式設計」概念，拿出來再理解一遍了。</p>","more":"<hr>\n<h2 id=\"什麼是物件導向程式設計（Object-Oriented-Programming）？\"><a href=\"#什麼是物件導向程式設計（Object-Oriented-Programming）？\" class=\"headerlink\" title=\"什麼是物件導向程式設計（Object-Oriented Programming）？\"></a>什麼是物件導向程式設計（Object-Oriented Programming）？</h2><blockquote>\n<p>根據 <a class=\"link\"   href=\"https://www.sanmin.com.tw/product/index/000747473\" >《UML 物件導向系統分析與設計》<i class=\"fas fa-external-link-alt\"></i></a>，在物件導向設計中，類別（Class）的實例（Instance）就叫做物件（Object）。物件作為程式的基本單元，每個物件都是獨立的個體，應該要能夠接收資料、處理資料、傳出資料，採用物件導向來設計程式，能夠大大提升程式的靈活性與可維護性。</p>\n</blockquote>\n<ul>\n<li>類（Class）：定義一個東西的抽象特徵。包含資料的形式以及對資料的操作。</li>\n<li>物件（Object）：是類的實例，類產生的具體例子。</li>\n</ul>\n<p>就像這類文章常見的那個例子一樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 宣告一個 class，包含屬性以及方法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">pname</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = pname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是&quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;嗎?&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宣告實例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ming = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小明&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> hua  = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;小花&quot;</span>);</span><br><span class=\"line\">ming.<span class=\"title function_\">murmur</span>();  <span class=\"comment\">// 我是小明嗎?</span></span><br><span class=\"line\">hua.<span class=\"title function_\">murmur</span>();   <span class=\"comment\">// 我是小花嗎?</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Person</code> 是一個 Class，而 <code>new Person()</code> 則會建立一個實例 Object。</p>\n<p>在初步了解物件導向是什麼了之後，就來看看它有哪些特性，以及需要依照怎樣的原則來設計程式吧。</p>\n<hr>\n<h2 id=\"物件導向四大特性\"><a href=\"#物件導向四大特性\" class=\"headerlink\" title=\"物件導向四大特性\"></a>物件導向四大特性</h2><p>物件導向有四個特性：</p>\n<ul>\n<li>抽象（Abstraction）</li>\n<li>封裝（Encapsulation）</li>\n<li>繼承（Inheritance）</li>\n<li>多型（Polymorphism）</li>\n</ul>\n<p>說真的，當時的我看到這些鬼東西，真是害怕極了。如今卻能大致理解這四項特性分別是在描述什麼，應該是有所成長了吧。</p>\n<h3 id=\"1-抽象（Abstraction）\"><a href=\"#1-抽象（Abstraction）\" class=\"headerlink\" title=\"1. 抽象（Abstraction）\"></a>1. 抽象（Abstraction）</h3><p>我自己覺得這可能是最難理解的概念，但是一但理解了抽象性，對於思考程式如何設計會有相當大的幫助。其實換個角度想，我們在生物課不就學過抽象性了嗎？</p>\n<blockquote>\n<p>不信你看：<a class=\"link\"   href=\"https://www.itsfun.com.tw/%E7%95%8C%E9%96%80%E7%B6%B1%E7%9B%AE%E7%A7%91%E5%B1%AC%E7%A8%AE/wiki-169944-298424\" >生物分類法 - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>就我目前的理解，抽象就是一種分類的方法。透過整理來將一類對象抽象化，而定義出這個類別的特性及行為，以幫助人快速識別對象。這個道理是從大自然中學習來的，而套用在程式設計上也相當合用。</p>\n<p>就像上面的例子一樣，小明與小花都屬於 <code>Person</code> 這個 Class，但各自的 <code>name</code> 及 <code>murmur</code> 的內容卻又不同。</p>\n<h3 id=\"2-封裝（Encapsulation）\"><a href=\"#2-封裝（Encapsulation）\" class=\"headerlink\" title=\"2. 封裝（Encapsulation）\"></a>2. 封裝（Encapsulation）</h3><p>封裝是將 Class 的部份內容包裝、隱藏起來的方法。這是一種防止外界呼叫、存取物件內部實作細節的手段。聽起來很美好，問題是親愛的 <code>JavaScript</code> 中並沒有簡單明瞭的設計來實現物件導向封裝特性。幸好，我們有 <code>TypeScript</code>。透過 <code>public</code> <code>private</code> <code>protected</code> 就能夠快速簡便地讓開發者及系統辨別公開或私有屬性。</p>\n<h3 id=\"3-繼承（Inheritance）\"><a href=\"#3-繼承（Inheritance）\" class=\"headerlink\" title=\"3. 繼承（Inheritance）\"></a>3. 繼承（Inheritance）</h3><p>一個物件有時會在父類別底下延伸出子類別，子類別會比父類別更加具體（但不是實例），且繼承父類別的屬性。</p>\n<p>比方說開頭提到的觀察清單類別，因為需要能夠容納「股票」類別以及「外匯」類別，就可以再分為「股票觀察清單類」及「外匯觀察清單類」。源頭都屬於觀察清單類別，但各自又多了部分不同的屬性。</p>\n<h3 id=\"4-多型（Polymorphism）\"><a href=\"#4-多型（Polymorphism）\" class=\"headerlink\" title=\"4. 多型（Polymorphism）\"></a>4. 多型（Polymorphism）</h3><p>由繼承產生的相關的不同類別，這些類別對同樣的呼叫，會給出不同的反應。這是什麼意思呢？讓我們修改一下開頭的案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>)&#123;&#125; <span class=\"comment\">// 此處定義了一個方法，但沒有內容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MalePerson</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是男漢子!&quot;</span>); <span class=\"comment\">// 定義內容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FemalePerson</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">murmur</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;我是女漢子!&quot;</span>); <span class=\"comment\">// 定義內容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> man = <span class=\"keyword\">new</span> <span class=\"title class_\">MalePerson</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> woman = <span class=\"keyword\">new</span> <span class=\"title class_\">FemalePerson</span>();</span><br><span class=\"line\">man.<span class=\"title function_\">murmur</span>();   <span class=\"comment\">// 我是男漢子!</span></span><br><span class=\"line\">woman.<span class=\"title function_\">murmur</span>(); <span class=\"comment\">// 我是女漢子!</span></span><br></pre></td></tr></table></figure>\n\n<p>如上所示，在新類別繼承了 <code>Person</code> 這個類別時，也一併繼承了它的 <code>murmur()</code> 方法，並各自覆蓋了方法的內容。接著建立實例並呼叫此方法的時候，就會印出各自的內容，這就是多型。</p>\n<hr>\n<h2 id=\"物件導向設計-SOLID-原則\"><a href=\"#物件導向設計-SOLID-原則\" class=\"headerlink\" title=\"物件導向設計 SOLID 原則\"></a>物件導向設計 SOLID 原則</h2><blockquote>\n<p><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)\" >SOLID (物件導向設計) - 維基百科<i class=\"fas fa-external-link-alt\"></i></a><br>每個專案沒聽到一次就渾身不對勁的 S.O.L.I.D. 原則</p>\n</blockquote>\n<p><code>SOLID</code> 原則是取以下五個原則的開頭組合而成，剛好也表示依循這樣原則的程式設計會很「穩固」。因為要深入淺出這五個原則，以我目前的功力還辦不到，所以只能簡單做個筆記。有錯誤的部分也歡迎隨時指正。</p>\n<ul>\n<li>單一職責原則（Single responsibility principle, SRP）</li>\n<li>開放封閉原則（Open-Close principle, OCP）</li>\n<li>里氏替換原則（Liskov substitution principle, LSP）</li>\n<li>介面隔離原則（Interface segregation principle, ISP）</li>\n<li>依賴反轉原則（Dependency inversion principle, DIP）</li>\n</ul>\n<h3 id=\"1-單一職責原則-Single-responsibility-principle-SRP\"><a href=\"#1-單一職責原則-Single-responsibility-principle-SRP\" class=\"headerlink\" title=\"1. 單一職責原則(Single responsibility principle, SRP)\"></a>1. 單一職責原則(Single responsibility principle, SRP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一個模組應該只對一個角色負責。</span><br></pre></td></tr></table></figure>\n\n<p>依我的理解，這意思就是一個 <code>calcTotal()</code> 的函式，不應該同時做多件事情，例如修改 <code>CompanyWallet.total</code> 以及 <code>CustomerWallet.total</code>，以防哪天因為變更了一點點 <code>calcTotal()</code> 的程式碼，卻影響到其他內容，這是會出大事的。</p>\n<p>那麼依循這個原則，可以這樣做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立一個抽象的介面，包含計算函式但不實作</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>): <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 各自繼承並實作計算函式的內容</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CompanyWallet</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">total</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 公司的計算方式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomerWallet</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">TotalCalculator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">total</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">function</span> <span class=\"title function_\">calcTotal</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 客戶的計算方式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前的我還不能很好地舉例解釋單一職責原則，或許是因為尚未滲透進骨髓，必須再繼續加深印象才行。</p>\n<h3 id=\"2-開放封閉原則-Open-Close-principle-OCP\"><a href=\"#2-開放封閉原則-Open-Close-principle-OCP\" class=\"headerlink\" title=\"2. 開放封閉原則(Open-Close principle, OCP)\"></a>2. 開放封閉原則(Open-Close principle, OCP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">開放擴展：當需求變更時，模組可以擴充功能。</span><br><span class=\"line\">封閉修改：當進行擴沖時，模組不需修改既有的程式碼。</span><br></pre></td></tr></table></figure>\n\n<p>當一個已經完成的模組要加上新功能時，不應修改原本的程式碼，否則很有可能會在想像不到的地方產生 bug，這是很好理解的。</p>\n<h3 id=\"3-里氏替換原則-Liskov-substitution-principle-LSP\"><a href=\"#3-里氏替換原則-Liskov-substitution-principle-LSP\" class=\"headerlink\" title=\"3. 里氏替換原則(Liskov substitution principle, LSP)\"></a>3. 里氏替換原則(Liskov substitution principle, LSP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">子類別要能取代它的父類別。</span><br></pre></td></tr></table></figure>\n\n<p>大意是說，子類別繼承了父類別，實作時需依循下列原則：</p>\n<ul>\n<li>子類別的先決條件不能比父類強，但可以比父類弱</li>\n<li>子類別的後置條件不能比父類弱，但可以比父類強</li>\n<li>父類別的不變條件必須被繼承</li>\n</ul>\n<p>乍看很抽象，但用具體例子來看的話，就很好理解。基本上就是子類別實作的範疇不應跳脫父類別，而應該在父類別的範疇內實作。</p>\n<h3 id=\"4-介面隔離原則-Interface-segregation-principle-ISP\"><a href=\"#4-介面隔離原則-Interface-segregation-principle-ISP\" class=\"headerlink\" title=\"4. 介面隔離原則(Interface segregation principle, ISP)\"></a>4. 介面隔離原則(Interface segregation principle, ISP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用不到的功能，不應被呼叫。</span><br></pre></td></tr></table></figure>\n\n<p>一樣又是很抽象的說明，具體舉個例子就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Website</span> &#123;</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">login</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">logout</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">    public <span class=\"keyword\">function</span> <span class=\"title function_\">adminMode</span>(<span class=\"params\"></span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    site = <span class=\"keyword\">new</span> <span class=\"title class_\">Website</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">login</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">logout</span>();</span><br><span class=\"line\">    site.<span class=\"title function_\">adminMode</span>(); <span class=\"comment\">// 明明是 client 為什麼可以開啟 admin?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因為 <code>adminMode()</code> 並不是開放給所有人使用的，但偏偏 client 又可以呼叫它，這就表示違反了介面隔離原則。此時需要將 <code>adminMode()</code> 隔離出來，只有管理員可以實作這個介面，並呼叫本功能。</p>\n<h3 id=\"5-依賴反轉原則-Dependency-inversion-principle-DIP\"><a href=\"#5-依賴反轉原則-Dependency-inversion-principle-DIP\" class=\"headerlink\" title=\"5. 依賴反轉原則(Dependency inversion principle, DIP)\"></a>5. 依賴反轉原則(Dependency inversion principle, DIP)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高層模組不應依賴低層模組，而都應該依賴抽象。</span><br></pre></td></tr></table></figure>\n\n<p>當高低模組之間有依賴關係時，此時就會有危險產生。萬一高層模組依賴低層模組，而低層模組的實作內容修改了，高層模組就會發生預期外的結果，要不然就必須去修改高層模組內容，出現高耦合的狀況。</p>\n<p>為了避免，可以在高低模組之間抽出一個抽象的介面，透過抽象去實作方法，這樣就可以降低耦合。</p>\n<p>以上就是 <code>SOLID</code> 原則。以我目前的程度，大概只有一知半解，而且要依照原則來設計程式，又比單純理解物件導向更難了。</p>\n<p>但我相信 <code>OOP</code> 能讓程式變得更好，所以我會持續精進 <code>SOLID</code>！</p>\n<hr>\n<h2 id=\"OOP-如何應用在前端開發？\"><a href=\"#OOP-如何應用在前端開發？\" class=\"headerlink\" title=\"OOP 如何應用在前端開發？\"></a>OOP 如何應用在前端開發？</h2><p>前端工程師在學習的過程中幾乎都會看到「<code>JavaScript</code> 是一個基於物件導向的語言」這句話，接著就會看到原型鏈（Prototype）相關的介紹。當時的我還不是很能把這兩件事串在一起，如今看來之間的關聯再明顯不過了。</p>\n<p>再回到前面的例子，其實 <code>JavaScript</code> 的 Class 並不是真正的類別，而只是個偽裝過的 function，也就是常聽人家說的那一句：「Class 只是 ES6 的語法糖」。但是 ES6 究竟為何要這樣欺騙我們的感情呢？還不是為了讓你開發上更方便（巴頭）！關於這件事，MDN 是這樣說的：</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" >繼承與原型鏈 - MDN<i class=\"fas fa-external-link-alt\"></i></a><br>JavaScript 是個沒有實做 class 關鍵字的動態語言，所以會對那些基於類別（class-based）語言（如 Java 或 C++）背景出身的開發者來說會有點困惑。（在 ES2015 有提供 class 關鍵字，但那只是個語法糖，JavaScript 仍然是基於原型（prototype-based）的語言）。</p>\n</blockquote>\n<p>我目前對於 <code>Prototype</code> 還沒有系統性地去理解過，只大致上知道是怎麼回事而已，但這不是本篇主旨，所以先跳過。</p>\n<p>我關心的是，究竟 <strong>OOP 如何應用在前端開發</strong>？</p>\n<h3 id=\"搭配神兵利器-TypeScript\"><a href=\"#搭配神兵利器-TypeScript\" class=\"headerlink\" title=\"搭配神兵利器 TypeScript\"></a>搭配神兵利器 <code>TypeScript</code></h3><p>因為目前公司使用的前端框架是 <code>Angular</code>，使用的主要語言是 <code>TypeScript</code>，也因此潛移默化地習慣了事先定義型別、類別的作法，自然養成好習慣。現在要我用原生 JS 開發，如果要像 <code>TypeScript</code> 那樣定義型別，要花一大堆功夫，心裡會很不是滋味。</p>\n<p>如果 <code>OOP</code> 搭配使用 <code>TypeScript</code>，那麼在開發事前就能將類別、資料型別定義得更清楚了，倘若再用上 <code>UML</code>（這才發現我沒寫過 <code>UML</code> 的筆記，看來也該補一篇了）來分析專案，在前期就徹底分析需求，就可以大大減少遺漏需求的問題，也可以減少發生後端都已經部署好 API 了，前端卻在串接過程中發現資料格式不合用想要改結構的情況。這有時候是會影響到 DB schema 的，若能事先定好，就能在前期發現該釐清的事項。</p>\n<p>因此接下來我會用 <code>TypeScript</code> 來呈現 <code>JavaScript</code> 的部分。</p>\n<h3 id=\"從「物件」作為出發點來思考\"><a href=\"#從「物件」作為出發點來思考\" class=\"headerlink\" title=\"從「物件」作為出發點來思考\"></a>從「物件」作為出發點來思考</h3><p>程式是「本質先於存在」的產物，必須先有「需求」，而後才有對應的「解決方案」。若要在專案開發中導入 <code>OOP</code>，必須從需求分析切入，後續發展才能順暢。讓我們先假設一個需求：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">開發一個檔案上傳管理系統。</span><br></pre></td></tr></table></figure>\n\n<p>好啦，老實說就是這個經驗：<a href=\"https://gkfat.github.io/2021/09/05/python-file-upload-service\">後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！</a>，不過當時的我並沒有將物件導向設計應用進去，因此若現在回頭看程式碼，不吐血才怪。</p>\n<p>現在從頭來思考這個需求，我會先做 <code>UML</code> 中的類圖分析，拆解出這個需求中包含下列類（Class）：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 檔案</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UploadFile</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 檔案 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 檔名</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>; <span class=\"comment\">// 檔案內容，以 base64 儲存</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">path</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 上傳的路徑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 使用者 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;    <span class=\"comment\">// 使用者名稱</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">uploadFile</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 上傳檔案</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">removeFile</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 刪除檔案</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">readRecord</span>(<span class=\"params\"></span>)&#123;&#125;   <span class=\"comment\">// fn: 查詢上傳紀錄</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上傳紀錄</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UploadRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">id</span>: <span class=\"built_in\">number</span>;      <span class=\"comment\">// 上傳紀錄 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">fileID</span>: <span class=\"built_in\">number</span>;  <span class=\"comment\">// 檔案 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">userID</span>: <span class=\"built_in\">number</span>;  <span class=\"comment\">// 使用者 ID</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"attr\">uploadTime</span>: <span class=\"title class_\">Date</span>;<span class=\"comment\">// 上傳時間</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花個 3 分鐘簡單拆解而已，就能大致看出個輪廓了（當然要能開始開發還遠遠不夠）。類圖分析完後，接著就能用活動圖來分析使用者、前端、後端、資料庫之間的活動，以及活動內容，再來就能推出各自要開發的項目細節了。</p>\n<hr>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>如此麻煩地套用 <code>OOP</code>，究竟會產生哪些影響？</p>\n<ul>\n<li>分析：搭配 <code>UML</code> 能更系統化分析專案，在前期就盡可能釐清 spec</li>\n<li>開發：開發過程中能清楚正在處理的資料型別，不用瞎子摸象亂猜一通</li>\n<li>協作：他人能更迅速理解程式碼的邏輯，工程師間的溝通更順暢</li>\n<li>維護：debug 或修改屬性、擴充功能都更方便</li>\n</ul>\n<p>最重要的，是幫助自己在程式設計的領域中提升思維高度，以更全面的角度來看待整個專案，對於成長很有幫助。</p>\n<p>所以，一起來學吧！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\" >物件導向程式設計 - 維基百科<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.sanmin.com.tw/product/index/000747473\" >UML 物件導向系統分析與設計 - Jim Arlow<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://medium.com/enjoy-life-enjoy-coding/typescript-%E5%BE%9E-ts-%E9%96%8B%E5%A7%8B%E5%AD%B8%E7%BF%92%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-interface-%E7%94%A8%E6%B3%95-77fd0959769f\" >TypeScript | 從 TS 開始學習物件導向 - Interface 用法 - 神Q超人<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！","date":"2021-09-05T00:31:08.000Z","_content":"\n公司裡有個部門每天都會產出一定份量的繪圖檔案，目前都是人工手動上傳到 NAS，但是對於資料夾與檔案的命名卻沒有任何規範，根本就是個野生叢林！該部門的主管想建立一套規則來更有系統地管理這些檔案（還有管理這些繪圖人員），因此開了這個需求給我。\n\n<!--more-->\n\n* [需求解析](##需求解析)\n* [開發](##開發)\n* [部署](##部署)\n\n---\n## 需求解析\n\n### 前言\n（~~客戶~~）某部門主管：「可以幫我做一個上傳圖紙到 NAS 的工具嗎？簡單就好，不要花你太多時間。」\nGK：「（你知道我只是個前端工程師嗎？）好啊，沒問題，你的需求是什麼？」\n（~~客戶~~）某部門主管：「？就是剛剛說的那樣啊...」\nGK：「？？？哦......好...好吧...」\n\n由於某些原因，我的部門裡沒有後端工程師，沒有系統分析師，也沒有 DBA，全部都得自己來。幸好經歷過 [這個歷練](https://gkfat.github.io/2021/03/19/system-deploying/)，我對於要建立一個系統服務，還算是有點概念。\n\n看來，這又是天上掉下來的機會，要讓我拓展視野了。\n\n### 系統分析\n在開始寫程式之前絕對該做的事，就是系統分析（SA）。首先把我的角色從 `產品經理（PM）` 切換成 `系統分析師（SA）`，經過一番思考後，犧牲了不少腦細胞，但也得出以下架構（因為涉及公司隱私，所以公開的部分有簡化過）。\n\n#### 系統架構\n\n|服務|選擇|\n|-|-|\n|VM|Linux CenteOS 7（既有）|\n|Backend Application|Python3|\n|Database|MariaDB（既有）|\n|Web Application|Angular 11|\n|HTTP Server|Apache|\n\n> 本來是想學著用 Golang 開發的，但為了讓另外幾位 Python 底的工程師也能夠維護或擴充這個服務，就選擇用 Python 了（反正兩個都是從頭學）（~~但寫完這個專案後我真的是很討厭 Python~~）。\n\n#### 活動\n* 上傳檔案功能\n    * 可將檔案上傳到 NAS 目標資料夾，並儲存紀錄至 DB\n* 查詢紀錄功能\n    * 可取得 DB 上傳紀錄，並做分頁、排序、篩選\n* 同步 NAS\n    * 可同步 NAS 上資料夾與 DB 客戶、型號\n\n#### 類別設計\n* 檔案上傳紀錄類\n* 客戶類\n* 型號類\n\n#### 資料庫設計\n* NAS 同步紀錄表\n* 客戶表\n* 型號表\n* 檔案上傳紀錄表\n\n#### API 設計\n* 同步 NAS API\n* 上傳檔案 API\n* 查詢紀錄 API\n* 查詢客戶、型號 API\n\n#### 介面\n* 上傳檔案頁面\n    * 取得客戶、型號\n    * 選擇檔案，組成目標格式\n    * 上傳檔案\n* 查詢紀錄頁面\n    * 同步 NAS\n    * 查詢上傳紀錄（分頁、排序、篩選）\n\n大致上就完成了一次簡易版 SA 分析，接著就是依據這些規格來開發了（角色切換成 `後端工程師(Back End)`）。如果開發文件寫得我看不懂，我就定死你 SA！欸，等等，SA 也是我自己？\n\n---\n## 開發\n好的，那麼來到了工程師們最喜歡的開發橋段了。有了辛辛苦苦做好的 SA 分析，就可以照著步驟無腦開發了！當然因為一條龍都是我，就沒有把規格訂得太詳細了，開發時再想就好了（這真的不是一個好習慣，後來在整理時發現，要寫 API 文件或後續要再擴充，都要再從程式碼裡找規格）。\n\n### 後端開發\n\n#### 選擇套件\n因為 Python 套件非常多，在網路上查詢整理後，選擇了這幾個套件來做核心處理。\n\n|套件|處理範圍|\n|-|-|\n|flask|http server|\n|flask-sqlalchemy|DB 相關操作|\n|pysmb|NAS 相關操作|\n\n#### 專案架構\n愉快的開發時間就咻地略過，來看看完成後的模樣吧。以下是憑~~直覺~~後端基礎寫出來的架構。\n```\nfile-uploader\n|-- app.py                // 專案的進入點，啟動 http server\n|-- deploy.sh             // 讓懶人可以一鍵部署到虛擬機的 Shell Script\n|-- venv                  // Python 必備虛擬環境，套件都裝在裡面\n|-- config                // DB、NAS 連線帳號密碼設定檔\n    |-- config.py\n|-- connection            // 處理連線，原本裡面有 DB 連線，後來發現不需要\n    |-- conNas.py\n|-- model                 // Model 與 Table schema\n    |-- dbTable.py\n|-- view                  // API routes 以及分配到哪個 Controller\n    |-- fileUpload.py\n|-- controller            // 業務邏輯\n    |-- uploadControl.py\n    |-- retrieveControl.py\n    |-- deleteControl.py\n    |-- fetchControl.py\n    |-- customerControl.py\n    |-- syncControl.py\n```\n\n以上是大致上的專案架構說明，大部分 Controller 都大同小異在對 NAS、DB 做一些基本的 CRUD 操作。比較值得一提的是在 `controller/uploadControl.py` 裡面對上傳檔案的操作，若一次上傳多個檔案，有開 `thread` 來並行處理，大概的程式碼如下：\n\n```python=\n// 上傳檔案\ndef UploadFile():\n    uploadList = []  // 要上傳的檔案陣列\n    \n    // 從 API 取出要上傳的檔案，加入 uploadList\n    for item in request.get_json()['files']:\n        uploadList.append(dict(\n            state = 0,    // 檔案上傳成功／失敗狀態\n            file  = item\n        ))\n    \n    // 產生多個 Thread，分別執行檔案上傳\n    for file in uplaodList:\n       uplaod_thread = threading.Thread(\n           target=UploadControl.UploadFileThread,\n           args=(item,)   // 少了那個逗號會有問題，我也不曉得為什麼\n       )\n       file = upload_thread.start()\n       \n       // 等全部的 thread 都完成後才進行下一步\n       uplaod_thread.join()\n    \n    // 一些跟 DB 有關的操作\n    // 回傳 API response\n\n\n// 每個 Thread 上傳檔案的操作\ndef UploadFileThread(file):\n    // 一些跟 NAS 有關的操作\n    // 回傳檔案上傳結果\n```\n\n\n### 前端開發\n前端就不是筆記的重點了，就是依 SA 分析的功能來開發。\n* Model：用 `typescript` 的 `namespace` 來建立類別 struct\n* UI：用 Bootstrap 達到最基本的呈現\n* UX：跳過 wireframe，靠經驗\n\n#### 拖曳上傳檔案\n比較值得一提的地方是，這次嘗試用 Angular 的 `directive` 來製作出「拖曳式上傳檔案」的監聽檔案拖曳區域，內容相當簡易：\n```javascript=\n// dropZone.directive.ts\nimport { Directive, HostListener, Output, EventEmitter } from \"@angular/core\";\nimport * as $ from 'jquery';\n\n@Directive({\n  selector: '[appDropZone]'\n})\nexport class dropZoneDirective {\n  @Output() filesDropped = new EventEmitter<any>();\n\n  @HostListener('dragover', ['$event']) onDragOver($event: any) {\n    $event.preventDefault();\n    $event.stopPropagation();\n    $('.dropZone').addClass('grayBGC');\n  }\n  @HostListener('dragleave', ['$event']) public onDragLeave($event: any) {\n    $event.preventDefault();\n    $event.stopPropagation();\n    $('.dropZone').removeClass('grayBGC');\n  }\n  @HostListener('drop', ['$event']) public onDrop($event: any) {\n    $event.stopPropagation();\n    $('.dropZone').removeClass('grayBGC');\n  }\n\n}\n\n// upload.html\n<div class=\"dropZone\" *ngIf=\"canUpload\" appDropZone (filesDropped)=\"chooseFile($event)\">\n    <input #fileDropRef id=\"fileDropRef\" type=\"file\" multiple\n            (change)=\"chooseFile($event)\">\n    <h5>拖曳檔案至此處</h5>\n    <label for=\"fileDropRef\">\n        或點擊此處選擇上傳檔案\n    </label>\n</div>\n```\n\n基本上就只是在監聽「拖曳進入」「拖曳離開」事件，為區域加上 css 讓使用者得到回饋，然後在「丟下檔案」的時候，emit 給 `upload.ts` 的 `chooseFile()` 接收。\n\n另外還有用 `cdkDropList` 結合 `bootstrap` 卡片呈現，製作出拖拉調整順序的介面。除外的就不值一提，很普通XD。\n\n---\n## 部署\n後端跟前端都寫好之後，部署的順序如下：\n* 將後端專案複製到虛擬機專案路徑底下\n    * 對目標 DB 做 Migration\n    * Systemctl 建立 service daemon file\n    * 啟用服務\n* 將前端專案複製到虛擬機專案路徑底下\n    * 設定 Apache proxy，將目標網址導向後端 API 或前端網頁\n    * 設定防火牆，讓使用者能存取 port\n\n### Database Migration\n在 Migration 這關其實也摸索了滿久的，後來逐漸認知到步驟其實很單純（我用 `flask-sqlalchemy` 來做 DB Migration）：\n* `flask db migrate` 來產生 migration file（比對 `dbTable.py` 中 table schema 與目標資料庫中的 schema）\n* 檢查 upgrade file 裡的操作是否都符合需求\n* `flask db upgrade` 就 Migrate 成功啦！\n\n至於 `backup`、`rollback`，就之後再考慮吧。\n\n### Linux Service\n\n> 之前有整理過一份 `systemctl` 的操作，指令都在 [這裡](https://gkfat.github.io/2021/08/01/linux-systemctl/)。\n* 在虛擬機建立 system daemon file\n* `systmectl daemon-reload` 來載入 service\n* `systemctl start <service>` 就啟用服務啦！\n\n---\n## 結語\n現在回頭看看，2021 年初時我還連 DB 怎麼下 query 都搞不懂，連 Linux 都不會操作，過了半年後，居然能夠一條龍做到下列事項：\n* 使用 Python 撰寫 http server、撰寫 API 文件、撰寫方便部署的 Shell Script\n* 串接 MariaDB 資料庫、執行 DB migration、串接 NAS\n* 使用 Angular 串接 http server\n* 部署後端服務、前端專案到虛擬機\n* 設定 Apache、防火牆讓使用者能夠連線\n\n真的是滿感謝有這個大好機會，讓我對整套專案的執行有了進一步的了解（但不敢說這就叫全端），經過了一兩季後，這個專案也已經逐漸成長到了 1.5 版本，對於後端也愈來愈能理解了。接下來想把重心放在學習 Golang，以及加強後端 Concurrency 處理的觀念。\n\n---\n參考資料：\n* [TechBridge 技術共筆 - 簡明 SQL 資料庫語法入門教學](https://blog.techbridge.cc/2020/02/09/sql-basic-tutorial/)","source":"_posts/python-file-upload-service.md","raw":"---\ntitle: 後端學習筆記 - 來寫一個串接 NAS 的檔案管理服務吧！\ndate: 2021-09-05 08:31:08\ntags: [後端開發, Python, API, NAS]\n---\n\n公司裡有個部門每天都會產出一定份量的繪圖檔案，目前都是人工手動上傳到 NAS，但是對於資料夾與檔案的命名卻沒有任何規範，根本就是個野生叢林！該部門的主管想建立一套規則來更有系統地管理這些檔案（還有管理這些繪圖人員），因此開了這個需求給我。\n\n<!--more-->\n\n* [需求解析](##需求解析)\n* [開發](##開發)\n* [部署](##部署)\n\n---\n## 需求解析\n\n### 前言\n（~~客戶~~）某部門主管：「可以幫我做一個上傳圖紙到 NAS 的工具嗎？簡單就好，不要花你太多時間。」\nGK：「（你知道我只是個前端工程師嗎？）好啊，沒問題，你的需求是什麼？」\n（~~客戶~~）某部門主管：「？就是剛剛說的那樣啊...」\nGK：「？？？哦......好...好吧...」\n\n由於某些原因，我的部門裡沒有後端工程師，沒有系統分析師，也沒有 DBA，全部都得自己來。幸好經歷過 [這個歷練](https://gkfat.github.io/2021/03/19/system-deploying/)，我對於要建立一個系統服務，還算是有點概念。\n\n看來，這又是天上掉下來的機會，要讓我拓展視野了。\n\n### 系統分析\n在開始寫程式之前絕對該做的事，就是系統分析（SA）。首先把我的角色從 `產品經理（PM）` 切換成 `系統分析師（SA）`，經過一番思考後，犧牲了不少腦細胞，但也得出以下架構（因為涉及公司隱私，所以公開的部分有簡化過）。\n\n#### 系統架構\n\n|服務|選擇|\n|-|-|\n|VM|Linux CenteOS 7（既有）|\n|Backend Application|Python3|\n|Database|MariaDB（既有）|\n|Web Application|Angular 11|\n|HTTP Server|Apache|\n\n> 本來是想學著用 Golang 開發的，但為了讓另外幾位 Python 底的工程師也能夠維護或擴充這個服務，就選擇用 Python 了（反正兩個都是從頭學）（~~但寫完這個專案後我真的是很討厭 Python~~）。\n\n#### 活動\n* 上傳檔案功能\n    * 可將檔案上傳到 NAS 目標資料夾，並儲存紀錄至 DB\n* 查詢紀錄功能\n    * 可取得 DB 上傳紀錄，並做分頁、排序、篩選\n* 同步 NAS\n    * 可同步 NAS 上資料夾與 DB 客戶、型號\n\n#### 類別設計\n* 檔案上傳紀錄類\n* 客戶類\n* 型號類\n\n#### 資料庫設計\n* NAS 同步紀錄表\n* 客戶表\n* 型號表\n* 檔案上傳紀錄表\n\n#### API 設計\n* 同步 NAS API\n* 上傳檔案 API\n* 查詢紀錄 API\n* 查詢客戶、型號 API\n\n#### 介面\n* 上傳檔案頁面\n    * 取得客戶、型號\n    * 選擇檔案，組成目標格式\n    * 上傳檔案\n* 查詢紀錄頁面\n    * 同步 NAS\n    * 查詢上傳紀錄（分頁、排序、篩選）\n\n大致上就完成了一次簡易版 SA 分析，接著就是依據這些規格來開發了（角色切換成 `後端工程師(Back End)`）。如果開發文件寫得我看不懂，我就定死你 SA！欸，等等，SA 也是我自己？\n\n---\n## 開發\n好的，那麼來到了工程師們最喜歡的開發橋段了。有了辛辛苦苦做好的 SA 分析，就可以照著步驟無腦開發了！當然因為一條龍都是我，就沒有把規格訂得太詳細了，開發時再想就好了（這真的不是一個好習慣，後來在整理時發現，要寫 API 文件或後續要再擴充，都要再從程式碼裡找規格）。\n\n### 後端開發\n\n#### 選擇套件\n因為 Python 套件非常多，在網路上查詢整理後，選擇了這幾個套件來做核心處理。\n\n|套件|處理範圍|\n|-|-|\n|flask|http server|\n|flask-sqlalchemy|DB 相關操作|\n|pysmb|NAS 相關操作|\n\n#### 專案架構\n愉快的開發時間就咻地略過，來看看完成後的模樣吧。以下是憑~~直覺~~後端基礎寫出來的架構。\n```\nfile-uploader\n|-- app.py                // 專案的進入點，啟動 http server\n|-- deploy.sh             // 讓懶人可以一鍵部署到虛擬機的 Shell Script\n|-- venv                  // Python 必備虛擬環境，套件都裝在裡面\n|-- config                // DB、NAS 連線帳號密碼設定檔\n    |-- config.py\n|-- connection            // 處理連線，原本裡面有 DB 連線，後來發現不需要\n    |-- conNas.py\n|-- model                 // Model 與 Table schema\n    |-- dbTable.py\n|-- view                  // API routes 以及分配到哪個 Controller\n    |-- fileUpload.py\n|-- controller            // 業務邏輯\n    |-- uploadControl.py\n    |-- retrieveControl.py\n    |-- deleteControl.py\n    |-- fetchControl.py\n    |-- customerControl.py\n    |-- syncControl.py\n```\n\n以上是大致上的專案架構說明，大部分 Controller 都大同小異在對 NAS、DB 做一些基本的 CRUD 操作。比較值得一提的是在 `controller/uploadControl.py` 裡面對上傳檔案的操作，若一次上傳多個檔案，有開 `thread` 來並行處理，大概的程式碼如下：\n\n```python=\n// 上傳檔案\ndef UploadFile():\n    uploadList = []  // 要上傳的檔案陣列\n    \n    // 從 API 取出要上傳的檔案，加入 uploadList\n    for item in request.get_json()['files']:\n        uploadList.append(dict(\n            state = 0,    // 檔案上傳成功／失敗狀態\n            file  = item\n        ))\n    \n    // 產生多個 Thread，分別執行檔案上傳\n    for file in uplaodList:\n       uplaod_thread = threading.Thread(\n           target=UploadControl.UploadFileThread,\n           args=(item,)   // 少了那個逗號會有問題，我也不曉得為什麼\n       )\n       file = upload_thread.start()\n       \n       // 等全部的 thread 都完成後才進行下一步\n       uplaod_thread.join()\n    \n    // 一些跟 DB 有關的操作\n    // 回傳 API response\n\n\n// 每個 Thread 上傳檔案的操作\ndef UploadFileThread(file):\n    // 一些跟 NAS 有關的操作\n    // 回傳檔案上傳結果\n```\n\n\n### 前端開發\n前端就不是筆記的重點了，就是依 SA 分析的功能來開發。\n* Model：用 `typescript` 的 `namespace` 來建立類別 struct\n* UI：用 Bootstrap 達到最基本的呈現\n* UX：跳過 wireframe，靠經驗\n\n#### 拖曳上傳檔案\n比較值得一提的地方是，這次嘗試用 Angular 的 `directive` 來製作出「拖曳式上傳檔案」的監聽檔案拖曳區域，內容相當簡易：\n```javascript=\n// dropZone.directive.ts\nimport { Directive, HostListener, Output, EventEmitter } from \"@angular/core\";\nimport * as $ from 'jquery';\n\n@Directive({\n  selector: '[appDropZone]'\n})\nexport class dropZoneDirective {\n  @Output() filesDropped = new EventEmitter<any>();\n\n  @HostListener('dragover', ['$event']) onDragOver($event: any) {\n    $event.preventDefault();\n    $event.stopPropagation();\n    $('.dropZone').addClass('grayBGC');\n  }\n  @HostListener('dragleave', ['$event']) public onDragLeave($event: any) {\n    $event.preventDefault();\n    $event.stopPropagation();\n    $('.dropZone').removeClass('grayBGC');\n  }\n  @HostListener('drop', ['$event']) public onDrop($event: any) {\n    $event.stopPropagation();\n    $('.dropZone').removeClass('grayBGC');\n  }\n\n}\n\n// upload.html\n<div class=\"dropZone\" *ngIf=\"canUpload\" appDropZone (filesDropped)=\"chooseFile($event)\">\n    <input #fileDropRef id=\"fileDropRef\" type=\"file\" multiple\n            (change)=\"chooseFile($event)\">\n    <h5>拖曳檔案至此處</h5>\n    <label for=\"fileDropRef\">\n        或點擊此處選擇上傳檔案\n    </label>\n</div>\n```\n\n基本上就只是在監聽「拖曳進入」「拖曳離開」事件，為區域加上 css 讓使用者得到回饋，然後在「丟下檔案」的時候，emit 給 `upload.ts` 的 `chooseFile()` 接收。\n\n另外還有用 `cdkDropList` 結合 `bootstrap` 卡片呈現，製作出拖拉調整順序的介面。除外的就不值一提，很普通XD。\n\n---\n## 部署\n後端跟前端都寫好之後，部署的順序如下：\n* 將後端專案複製到虛擬機專案路徑底下\n    * 對目標 DB 做 Migration\n    * Systemctl 建立 service daemon file\n    * 啟用服務\n* 將前端專案複製到虛擬機專案路徑底下\n    * 設定 Apache proxy，將目標網址導向後端 API 或前端網頁\n    * 設定防火牆，讓使用者能存取 port\n\n### Database Migration\n在 Migration 這關其實也摸索了滿久的，後來逐漸認知到步驟其實很單純（我用 `flask-sqlalchemy` 來做 DB Migration）：\n* `flask db migrate` 來產生 migration file（比對 `dbTable.py` 中 table schema 與目標資料庫中的 schema）\n* 檢查 upgrade file 裡的操作是否都符合需求\n* `flask db upgrade` 就 Migrate 成功啦！\n\n至於 `backup`、`rollback`，就之後再考慮吧。\n\n### Linux Service\n\n> 之前有整理過一份 `systemctl` 的操作，指令都在 [這裡](https://gkfat.github.io/2021/08/01/linux-systemctl/)。\n* 在虛擬機建立 system daemon file\n* `systmectl daemon-reload` 來載入 service\n* `systemctl start <service>` 就啟用服務啦！\n\n---\n## 結語\n現在回頭看看，2021 年初時我還連 DB 怎麼下 query 都搞不懂，連 Linux 都不會操作，過了半年後，居然能夠一條龍做到下列事項：\n* 使用 Python 撰寫 http server、撰寫 API 文件、撰寫方便部署的 Shell Script\n* 串接 MariaDB 資料庫、執行 DB migration、串接 NAS\n* 使用 Angular 串接 http server\n* 部署後端服務、前端專案到虛擬機\n* 設定 Apache、防火牆讓使用者能夠連線\n\n真的是滿感謝有這個大好機會，讓我對整套專案的執行有了進一步的了解（但不敢說這就叫全端），經過了一兩季後，這個專案也已經逐漸成長到了 1.5 版本，對於後端也愈來愈能理解了。接下來想把重心放在學習 Golang，以及加強後端 Concurrency 處理的觀念。\n\n---\n參考資料：\n* [TechBridge 技術共筆 - 簡明 SQL 資料庫語法入門教學](https://blog.techbridge.cc/2020/02/09/sql-basic-tutorial/)","slug":"python-file-upload-service","published":1,"updated":"2022-03-12T12:58:21.423Z","_id":"cl0nustxw0026z6ushmks9z26","comments":1,"layout":"post","photos":[],"link":"","content":"<p>公司裡有個部門每天都會產出一定份量的繪圖檔案，目前都是人工手動上傳到 NAS，但是對於資料夾與檔案的命名卻沒有任何規範，根本就是個野生叢林！該部門的主管想建立一套規則來更有系統地管理這些檔案（還有管理這些繪圖人員），因此開了這個需求給我。</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><a href=\"##%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90\">需求解析</a></li>\n<li><a href=\"##%E9%96%8B%E7%99%BC\">開發</a></li>\n<li><a href=\"##%E9%83%A8%E7%BD%B2\">部署</a></li>\n</ul>\n<hr>\n<h2 id=\"需求解析\"><a href=\"#需求解析\" class=\"headerlink\" title=\"需求解析\"></a>需求解析</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>（<del>客戶</del>）某部門主管：「可以幫我做一個上傳圖紙到 NAS 的工具嗎？簡單就好，不要花你太多時間。」<br>GK：「（你知道我只是個前端工程師嗎？）好啊，沒問題，你的需求是什麼？」<br>（<del>客戶</del>）某部門主管：「？就是剛剛說的那樣啊…」<br>GK：「？？？哦……好…好吧…」</p>\n<p>由於某些原因，我的部門裡沒有後端工程師，沒有系統分析師，也沒有 DBA，全部都得自己來。幸好經歷過 <a href=\"https://gkfat.github.io/2021/03/19/system-deploying/\">這個歷練</a>，我對於要建立一個系統服務，還算是有點概念。</p>\n<p>看來，這又是天上掉下來的機會，要讓我拓展視野了。</p>\n<h3 id=\"系統分析\"><a href=\"#系統分析\" class=\"headerlink\" title=\"系統分析\"></a>系統分析</h3><p>在開始寫程式之前絕對該做的事，就是系統分析（SA）。首先把我的角色從 <code>產品經理（PM）</code> 切換成 <code>系統分析師（SA）</code>，經過一番思考後，犧牲了不少腦細胞，但也得出以下架構（因為涉及公司隱私，所以公開的部分有簡化過）。</p>\n<h4 id=\"系統架構\"><a href=\"#系統架構\" class=\"headerlink\" title=\"系統架構\"></a>系統架構</h4><table>\n<thead>\n<tr>\n<th>服務</th>\n<th>選擇</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VM</td>\n<td>Linux CenteOS 7（既有）</td>\n</tr>\n<tr>\n<td>Backend Application</td>\n<td>Python3</td>\n</tr>\n<tr>\n<td>Database</td>\n<td>MariaDB（既有）</td>\n</tr>\n<tr>\n<td>Web Application</td>\n<td>Angular 11</td>\n</tr>\n<tr>\n<td>HTTP Server</td>\n<td>Apache</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>本來是想學著用 Golang 開發的，但為了讓另外幾位 Python 底的工程師也能夠維護或擴充這個服務，就選擇用 Python 了（反正兩個都是從頭學）（<del>但寫完這個專案後我真的是很討厭 Python</del>）。</p>\n</blockquote>\n<h4 id=\"活動\"><a href=\"#活動\" class=\"headerlink\" title=\"活動\"></a>活動</h4><ul>\n<li>上傳檔案功能<ul>\n<li>可將檔案上傳到 NAS 目標資料夾，並儲存紀錄至 DB</li>\n</ul>\n</li>\n<li>查詢紀錄功能<ul>\n<li>可取得 DB 上傳紀錄，並做分頁、排序、篩選</li>\n</ul>\n</li>\n<li>同步 NAS<ul>\n<li>可同步 NAS 上資料夾與 DB 客戶、型號</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"類別設計\"><a href=\"#類別設計\" class=\"headerlink\" title=\"類別設計\"></a>類別設計</h4><ul>\n<li>檔案上傳紀錄類</li>\n<li>客戶類</li>\n<li>型號類</li>\n</ul>\n<h4 id=\"資料庫設計\"><a href=\"#資料庫設計\" class=\"headerlink\" title=\"資料庫設計\"></a>資料庫設計</h4><ul>\n<li>NAS 同步紀錄表</li>\n<li>客戶表</li>\n<li>型號表</li>\n<li>檔案上傳紀錄表</li>\n</ul>\n<h4 id=\"API-設計\"><a href=\"#API-設計\" class=\"headerlink\" title=\"API 設計\"></a>API 設計</h4><ul>\n<li>同步 NAS API</li>\n<li>上傳檔案 API</li>\n<li>查詢紀錄 API</li>\n<li>查詢客戶、型號 API</li>\n</ul>\n<h4 id=\"介面\"><a href=\"#介面\" class=\"headerlink\" title=\"介面\"></a>介面</h4><ul>\n<li>上傳檔案頁面<ul>\n<li>取得客戶、型號</li>\n<li>選擇檔案，組成目標格式</li>\n<li>上傳檔案</li>\n</ul>\n</li>\n<li>查詢紀錄頁面<ul>\n<li>同步 NAS</li>\n<li>查詢上傳紀錄（分頁、排序、篩選）</li>\n</ul>\n</li>\n</ul>\n<p>大致上就完成了一次簡易版 SA 分析，接著就是依據這些規格來開發了（角色切換成 <code>後端工程師(Back End)</code>）。如果開發文件寫得我看不懂，我就定死你 SA！欸，等等，SA 也是我自己？</p>\n<hr>\n<h2 id=\"開發\"><a href=\"#開發\" class=\"headerlink\" title=\"開發\"></a>開發</h2><p>好的，那麼來到了工程師們最喜歡的開發橋段了。有了辛辛苦苦做好的 SA 分析，就可以照著步驟無腦開發了！當然因為一條龍都是我，就沒有把規格訂得太詳細了，開發時再想就好了（這真的不是一個好習慣，後來在整理時發現，要寫 API 文件或後續要再擴充，都要再從程式碼裡找規格）。</p>\n<h3 id=\"後端開發\"><a href=\"#後端開發\" class=\"headerlink\" title=\"後端開發\"></a>後端開發</h3><h4 id=\"選擇套件\"><a href=\"#選擇套件\" class=\"headerlink\" title=\"選擇套件\"></a>選擇套件</h4><p>因為 Python 套件非常多，在網路上查詢整理後，選擇了這幾個套件來做核心處理。</p>\n<table>\n<thead>\n<tr>\n<th>套件</th>\n<th>處理範圍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>flask</td>\n<td>http server</td>\n</tr>\n<tr>\n<td>flask-sqlalchemy</td>\n<td>DB 相關操作</td>\n</tr>\n<tr>\n<td>pysmb</td>\n<td>NAS 相關操作</td>\n</tr>\n</tbody></table>\n<h4 id=\"專案架構\"><a href=\"#專案架構\" class=\"headerlink\" title=\"專案架構\"></a>專案架構</h4><p>愉快的開發時間就咻地略過，來看看完成後的模樣吧。以下是憑<del>直覺</del>後端基礎寫出來的架構。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file-uploader</span><br><span class=\"line\">|-- app.py                // 專案的進入點，啟動 http server</span><br><span class=\"line\">|-- deploy.sh             // 讓懶人可以一鍵部署到虛擬機的 Shell Script</span><br><span class=\"line\">|-- venv                  // Python 必備虛擬環境，套件都裝在裡面</span><br><span class=\"line\">|-- config                // DB、NAS 連線帳號密碼設定檔</span><br><span class=\"line\">    |-- config.py</span><br><span class=\"line\">|-- connection            // 處理連線，原本裡面有 DB 連線，後來發現不需要</span><br><span class=\"line\">    |-- conNas.py</span><br><span class=\"line\">|-- model                 // Model 與 Table schema</span><br><span class=\"line\">    |-- dbTable.py</span><br><span class=\"line\">|-- view                  // API routes 以及分配到哪個 Controller</span><br><span class=\"line\">    |-- fileUpload.py</span><br><span class=\"line\">|-- controller            // 業務邏輯</span><br><span class=\"line\">    |-- uploadControl.py</span><br><span class=\"line\">    |-- retrieveControl.py</span><br><span class=\"line\">    |-- deleteControl.py</span><br><span class=\"line\">    |-- fetchControl.py</span><br><span class=\"line\">    |-- customerControl.py</span><br><span class=\"line\">    |-- syncControl.py</span><br></pre></td></tr></table></figure>\n\n<p>以上是大致上的專案架構說明，大部分 Controller 都大同小異在對 NAS、DB 做一些基本的 CRUD 操作。比較值得一提的是在 <code>controller/uploadControl.py</code> 裡面對上傳檔案的操作，若一次上傳多個檔案，有開 <code>thread</code> 來並行處理，大概的程式碼如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上傳檔案</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">UploadFile</span>():</span><br><span class=\"line\">    uploadList = []  // 要上傳的檔案陣列</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 從 API 取出要上傳的檔案，加入 uploadList</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> request.get_json()[<span class=\"string\">&#x27;files&#x27;</span>]:</span><br><span class=\"line\">        uploadList.append(<span class=\"built_in\">dict</span>(</span><br><span class=\"line\">            state = <span class=\"number\">0</span>,    // 檔案上傳成功／失敗狀態</span><br><span class=\"line\">            file  = item</span><br><span class=\"line\">        ))</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 產生多個 Thread，分別執行檔案上傳</span><br><span class=\"line\">    <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> uplaodList:</span><br><span class=\"line\">       uplaod_thread = threading.Thread(</span><br><span class=\"line\">           target=UploadControl.UploadFileThread,</span><br><span class=\"line\">           args=(item,)   // 少了那個逗號會有問題，我也不曉得為什麼</span><br><span class=\"line\">       )</span><br><span class=\"line\">       file = upload_thread.start()</span><br><span class=\"line\">       </span><br><span class=\"line\">       // 等全部的 thread 都完成後才進行下一步</span><br><span class=\"line\">       uplaod_thread.join()</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 一些跟 DB 有關的操作</span><br><span class=\"line\">    // 回傳 API response</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 每個 Thread 上傳檔案的操作</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">UploadFileThread</span>(<span class=\"params\">file</span>):</span><br><span class=\"line\">    // 一些跟 NAS 有關的操作</span><br><span class=\"line\">    // 回傳檔案上傳結果</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"前端開發\"><a href=\"#前端開發\" class=\"headerlink\" title=\"前端開發\"></a>前端開發</h3><p>前端就不是筆記的重點了，就是依 SA 分析的功能來開發。</p>\n<ul>\n<li>Model：用 <code>typescript</code> 的 <code>namespace</code> 來建立類別 struct</li>\n<li>UI：用 Bootstrap 達到最基本的呈現</li>\n<li>UX：跳過 wireframe，靠經驗</li>\n</ul>\n<h4 id=\"拖曳上傳檔案\"><a href=\"#拖曳上傳檔案\" class=\"headerlink\" title=\"拖曳上傳檔案\"></a>拖曳上傳檔案</h4><p>比較值得一提的地方是，這次嘗試用 Angular 的 <code>directive</code> 來製作出「拖曳式上傳檔案」的監聽檔案拖曳區域，內容相當簡易：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dropZone.directive.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Directive</span>, <span class=\"title class_\">HostListener</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/core&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&#x27;jquery&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"title class_\">Directive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;[appDropZone]&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">dropZoneDirective</span> &#123;</span><br><span class=\"line\">  @<span class=\"title class_\">Output</span>() filesDropped = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;dragover&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) <span class=\"title function_\">onDragOver</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;dragleave&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) public <span class=\"title function_\">onDragLeave</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;drop&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) public <span class=\"title function_\">onDrop</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// upload.html</span></span><br><span class=\"line\">&lt;div <span class=\"keyword\">class</span>=<span class=\"string\">&quot;dropZone&quot;</span> *ngIf=<span class=\"string\">&quot;canUpload&quot;</span> appDropZone (filesDropped)=<span class=\"string\">&quot;chooseFile($event)&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">fileDropRef</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fileDropRef&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">multiple</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            (<span class=\"attr\">change</span>)=<span class=\"string\">&quot;chooseFile($event)&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>拖曳檔案至此處<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;fileDropRef&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        或點擊此處選擇上傳檔案</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>基本上就只是在監聽「拖曳進入」「拖曳離開」事件，為區域加上 css 讓使用者得到回饋，然後在「丟下檔案」的時候，emit 給 <code>upload.ts</code> 的 <code>chooseFile()</code> 接收。</p>\n<p>另外還有用 <code>cdkDropList</code> 結合 <code>bootstrap</code> 卡片呈現，製作出拖拉調整順序的介面。除外的就不值一提，很普通XD。</p>\n<hr>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>後端跟前端都寫好之後，部署的順序如下：</p>\n<ul>\n<li>將後端專案複製到虛擬機專案路徑底下<ul>\n<li>對目標 DB 做 Migration</li>\n<li>Systemctl 建立 service daemon file</li>\n<li>啟用服務</li>\n</ul>\n</li>\n<li>將前端專案複製到虛擬機專案路徑底下<ul>\n<li>設定 Apache proxy，將目標網址導向後端 API 或前端網頁</li>\n<li>設定防火牆，讓使用者能存取 port</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Database-Migration\"><a href=\"#Database-Migration\" class=\"headerlink\" title=\"Database Migration\"></a>Database Migration</h3><p>在 Migration 這關其實也摸索了滿久的，後來逐漸認知到步驟其實很單純（我用 <code>flask-sqlalchemy</code> 來做 DB Migration）：</p>\n<ul>\n<li><code>flask db migrate</code> 來產生 migration file（比對 <code>dbTable.py</code> 中 table schema 與目標資料庫中的 schema）</li>\n<li>檢查 upgrade file 裡的操作是否都符合需求</li>\n<li><code>flask db upgrade</code> 就 Migrate 成功啦！</li>\n</ul>\n<p>至於 <code>backup</code>、<code>rollback</code>，就之後再考慮吧。</p>\n<h3 id=\"Linux-Service\"><a href=\"#Linux-Service\" class=\"headerlink\" title=\"Linux Service\"></a>Linux Service</h3><blockquote>\n<p>之前有整理過一份 <code>systemctl</code> 的操作，指令都在 <a href=\"https://gkfat.github.io/2021/08/01/linux-systemctl/\">這裡</a>。</p>\n</blockquote>\n<ul>\n<li>在虛擬機建立 system daemon file</li>\n<li><code>systmectl daemon-reload</code> 來載入 service</li>\n<li><code>systemctl start &lt;service&gt;</code> 就啟用服務啦！</li>\n</ul>\n<hr>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>現在回頭看看，2021 年初時我還連 DB 怎麼下 query 都搞不懂，連 Linux 都不會操作，過了半年後，居然能夠一條龍做到下列事項：</p>\n<ul>\n<li>使用 Python 撰寫 http server、撰寫 API 文件、撰寫方便部署的 Shell Script</li>\n<li>串接 MariaDB 資料庫、執行 DB migration、串接 NAS</li>\n<li>使用 Angular 串接 http server</li>\n<li>部署後端服務、前端專案到虛擬機</li>\n<li>設定 Apache、防火牆讓使用者能夠連線</li>\n</ul>\n<p>真的是滿感謝有這個大好機會，讓我對整套專案的執行有了進一步的了解（但不敢說這就叫全端），經過了一兩季後，這個專案也已經逐漸成長到了 1.5 版本，對於後端也愈來愈能理解了。接下來想把重心放在學習 Golang，以及加強後端 Concurrency 處理的觀念。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2020/02/09/sql-basic-tutorial/\" >TechBridge 技術共筆 - 簡明 SQL 資料庫語法入門教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>公司裡有個部門每天都會產出一定份量的繪圖檔案，目前都是人工手動上傳到 NAS，但是對於資料夾與檔案的命名卻沒有任何規範，根本就是個野生叢林！該部門的主管想建立一套規則來更有系統地管理這些檔案（還有管理這些繪圖人員），因此開了這個需求給我。</p>","more":"<ul>\n<li><a href=\"##%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90\">需求解析</a></li>\n<li><a href=\"##%E9%96%8B%E7%99%BC\">開發</a></li>\n<li><a href=\"##%E9%83%A8%E7%BD%B2\">部署</a></li>\n</ul>\n<hr>\n<h2 id=\"需求解析\"><a href=\"#需求解析\" class=\"headerlink\" title=\"需求解析\"></a>需求解析</h2><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>（<del>客戶</del>）某部門主管：「可以幫我做一個上傳圖紙到 NAS 的工具嗎？簡單就好，不要花你太多時間。」<br>GK：「（你知道我只是個前端工程師嗎？）好啊，沒問題，你的需求是什麼？」<br>（<del>客戶</del>）某部門主管：「？就是剛剛說的那樣啊…」<br>GK：「？？？哦……好…好吧…」</p>\n<p>由於某些原因，我的部門裡沒有後端工程師，沒有系統分析師，也沒有 DBA，全部都得自己來。幸好經歷過 <a href=\"https://gkfat.github.io/2021/03/19/system-deploying/\">這個歷練</a>，我對於要建立一個系統服務，還算是有點概念。</p>\n<p>看來，這又是天上掉下來的機會，要讓我拓展視野了。</p>\n<h3 id=\"系統分析\"><a href=\"#系統分析\" class=\"headerlink\" title=\"系統分析\"></a>系統分析</h3><p>在開始寫程式之前絕對該做的事，就是系統分析（SA）。首先把我的角色從 <code>產品經理（PM）</code> 切換成 <code>系統分析師（SA）</code>，經過一番思考後，犧牲了不少腦細胞，但也得出以下架構（因為涉及公司隱私，所以公開的部分有簡化過）。</p>\n<h4 id=\"系統架構\"><a href=\"#系統架構\" class=\"headerlink\" title=\"系統架構\"></a>系統架構</h4><table>\n<thead>\n<tr>\n<th>服務</th>\n<th>選擇</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>VM</td>\n<td>Linux CenteOS 7（既有）</td>\n</tr>\n<tr>\n<td>Backend Application</td>\n<td>Python3</td>\n</tr>\n<tr>\n<td>Database</td>\n<td>MariaDB（既有）</td>\n</tr>\n<tr>\n<td>Web Application</td>\n<td>Angular 11</td>\n</tr>\n<tr>\n<td>HTTP Server</td>\n<td>Apache</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>本來是想學著用 Golang 開發的，但為了讓另外幾位 Python 底的工程師也能夠維護或擴充這個服務，就選擇用 Python 了（反正兩個都是從頭學）（<del>但寫完這個專案後我真的是很討厭 Python</del>）。</p>\n</blockquote>\n<h4 id=\"活動\"><a href=\"#活動\" class=\"headerlink\" title=\"活動\"></a>活動</h4><ul>\n<li>上傳檔案功能<ul>\n<li>可將檔案上傳到 NAS 目標資料夾，並儲存紀錄至 DB</li>\n</ul>\n</li>\n<li>查詢紀錄功能<ul>\n<li>可取得 DB 上傳紀錄，並做分頁、排序、篩選</li>\n</ul>\n</li>\n<li>同步 NAS<ul>\n<li>可同步 NAS 上資料夾與 DB 客戶、型號</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"類別設計\"><a href=\"#類別設計\" class=\"headerlink\" title=\"類別設計\"></a>類別設計</h4><ul>\n<li>檔案上傳紀錄類</li>\n<li>客戶類</li>\n<li>型號類</li>\n</ul>\n<h4 id=\"資料庫設計\"><a href=\"#資料庫設計\" class=\"headerlink\" title=\"資料庫設計\"></a>資料庫設計</h4><ul>\n<li>NAS 同步紀錄表</li>\n<li>客戶表</li>\n<li>型號表</li>\n<li>檔案上傳紀錄表</li>\n</ul>\n<h4 id=\"API-設計\"><a href=\"#API-設計\" class=\"headerlink\" title=\"API 設計\"></a>API 設計</h4><ul>\n<li>同步 NAS API</li>\n<li>上傳檔案 API</li>\n<li>查詢紀錄 API</li>\n<li>查詢客戶、型號 API</li>\n</ul>\n<h4 id=\"介面\"><a href=\"#介面\" class=\"headerlink\" title=\"介面\"></a>介面</h4><ul>\n<li>上傳檔案頁面<ul>\n<li>取得客戶、型號</li>\n<li>選擇檔案，組成目標格式</li>\n<li>上傳檔案</li>\n</ul>\n</li>\n<li>查詢紀錄頁面<ul>\n<li>同步 NAS</li>\n<li>查詢上傳紀錄（分頁、排序、篩選）</li>\n</ul>\n</li>\n</ul>\n<p>大致上就完成了一次簡易版 SA 分析，接著就是依據這些規格來開發了（角色切換成 <code>後端工程師(Back End)</code>）。如果開發文件寫得我看不懂，我就定死你 SA！欸，等等，SA 也是我自己？</p>\n<hr>\n<h2 id=\"開發\"><a href=\"#開發\" class=\"headerlink\" title=\"開發\"></a>開發</h2><p>好的，那麼來到了工程師們最喜歡的開發橋段了。有了辛辛苦苦做好的 SA 分析，就可以照著步驟無腦開發了！當然因為一條龍都是我，就沒有把規格訂得太詳細了，開發時再想就好了（這真的不是一個好習慣，後來在整理時發現，要寫 API 文件或後續要再擴充，都要再從程式碼裡找規格）。</p>\n<h3 id=\"後端開發\"><a href=\"#後端開發\" class=\"headerlink\" title=\"後端開發\"></a>後端開發</h3><h4 id=\"選擇套件\"><a href=\"#選擇套件\" class=\"headerlink\" title=\"選擇套件\"></a>選擇套件</h4><p>因為 Python 套件非常多，在網路上查詢整理後，選擇了這幾個套件來做核心處理。</p>\n<table>\n<thead>\n<tr>\n<th>套件</th>\n<th>處理範圍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>flask</td>\n<td>http server</td>\n</tr>\n<tr>\n<td>flask-sqlalchemy</td>\n<td>DB 相關操作</td>\n</tr>\n<tr>\n<td>pysmb</td>\n<td>NAS 相關操作</td>\n</tr>\n</tbody></table>\n<h4 id=\"專案架構\"><a href=\"#專案架構\" class=\"headerlink\" title=\"專案架構\"></a>專案架構</h4><p>愉快的開發時間就咻地略過，來看看完成後的模樣吧。以下是憑<del>直覺</del>後端基礎寫出來的架構。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file-uploader</span><br><span class=\"line\">|-- app.py                // 專案的進入點，啟動 http server</span><br><span class=\"line\">|-- deploy.sh             // 讓懶人可以一鍵部署到虛擬機的 Shell Script</span><br><span class=\"line\">|-- venv                  // Python 必備虛擬環境，套件都裝在裡面</span><br><span class=\"line\">|-- config                // DB、NAS 連線帳號密碼設定檔</span><br><span class=\"line\">    |-- config.py</span><br><span class=\"line\">|-- connection            // 處理連線，原本裡面有 DB 連線，後來發現不需要</span><br><span class=\"line\">    |-- conNas.py</span><br><span class=\"line\">|-- model                 // Model 與 Table schema</span><br><span class=\"line\">    |-- dbTable.py</span><br><span class=\"line\">|-- view                  // API routes 以及分配到哪個 Controller</span><br><span class=\"line\">    |-- fileUpload.py</span><br><span class=\"line\">|-- controller            // 業務邏輯</span><br><span class=\"line\">    |-- uploadControl.py</span><br><span class=\"line\">    |-- retrieveControl.py</span><br><span class=\"line\">    |-- deleteControl.py</span><br><span class=\"line\">    |-- fetchControl.py</span><br><span class=\"line\">    |-- customerControl.py</span><br><span class=\"line\">    |-- syncControl.py</span><br></pre></td></tr></table></figure>\n\n<p>以上是大致上的專案架構說明，大部分 Controller 都大同小異在對 NAS、DB 做一些基本的 CRUD 操作。比較值得一提的是在 <code>controller/uploadControl.py</code> 裡面對上傳檔案的操作，若一次上傳多個檔案，有開 <code>thread</code> 來並行處理，大概的程式碼如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 上傳檔案</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">UploadFile</span>():</span><br><span class=\"line\">    uploadList = []  // 要上傳的檔案陣列</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 從 API 取出要上傳的檔案，加入 uploadList</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> request.get_json()[<span class=\"string\">&#x27;files&#x27;</span>]:</span><br><span class=\"line\">        uploadList.append(<span class=\"built_in\">dict</span>(</span><br><span class=\"line\">            state = <span class=\"number\">0</span>,    // 檔案上傳成功／失敗狀態</span><br><span class=\"line\">            file  = item</span><br><span class=\"line\">        ))</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 產生多個 Thread，分別執行檔案上傳</span><br><span class=\"line\">    <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> uplaodList:</span><br><span class=\"line\">       uplaod_thread = threading.Thread(</span><br><span class=\"line\">           target=UploadControl.UploadFileThread,</span><br><span class=\"line\">           args=(item,)   // 少了那個逗號會有問題，我也不曉得為什麼</span><br><span class=\"line\">       )</span><br><span class=\"line\">       file = upload_thread.start()</span><br><span class=\"line\">       </span><br><span class=\"line\">       // 等全部的 thread 都完成後才進行下一步</span><br><span class=\"line\">       uplaod_thread.join()</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 一些跟 DB 有關的操作</span><br><span class=\"line\">    // 回傳 API response</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 每個 Thread 上傳檔案的操作</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">UploadFileThread</span>(<span class=\"params\">file</span>):</span><br><span class=\"line\">    // 一些跟 NAS 有關的操作</span><br><span class=\"line\">    // 回傳檔案上傳結果</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"前端開發\"><a href=\"#前端開發\" class=\"headerlink\" title=\"前端開發\"></a>前端開發</h3><p>前端就不是筆記的重點了，就是依 SA 分析的功能來開發。</p>\n<ul>\n<li>Model：用 <code>typescript</code> 的 <code>namespace</code> 來建立類別 struct</li>\n<li>UI：用 Bootstrap 達到最基本的呈現</li>\n<li>UX：跳過 wireframe，靠經驗</li>\n</ul>\n<h4 id=\"拖曳上傳檔案\"><a href=\"#拖曳上傳檔案\" class=\"headerlink\" title=\"拖曳上傳檔案\"></a>拖曳上傳檔案</h4><p>比較值得一提的地方是，這次嘗試用 Angular 的 <code>directive</code> 來製作出「拖曳式上傳檔案」的監聽檔案拖曳區域，內容相當簡易：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dropZone.directive.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Directive</span>, <span class=\"title class_\">HostListener</span>, <span class=\"title class_\">Output</span>, <span class=\"title class_\">EventEmitter</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/core&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&#x27;jquery&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"title class_\">Directive</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">selector</span>: <span class=\"string\">&#x27;[appDropZone]&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> <span class=\"title class_\">dropZoneDirective</span> &#123;</span><br><span class=\"line\">  @<span class=\"title class_\">Output</span>() filesDropped = <span class=\"keyword\">new</span> <span class=\"title class_\">EventEmitter</span>&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;dragover&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) <span class=\"title function_\">onDragOver</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;dragleave&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) public <span class=\"title function_\">onDragLeave</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @<span class=\"title class_\">HostListener</span>(<span class=\"string\">&#x27;drop&#x27;</span>, [<span class=\"string\">&#x27;$event&#x27;</span>]) public <span class=\"title function_\">onDrop</span>(<span class=\"params\">$event: any</span>) &#123;</span><br><span class=\"line\">    $event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.dropZone&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;grayBGC&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// upload.html</span></span><br><span class=\"line\">&lt;div <span class=\"keyword\">class</span>=<span class=\"string\">&quot;dropZone&quot;</span> *ngIf=<span class=\"string\">&quot;canUpload&quot;</span> appDropZone (filesDropped)=<span class=\"string\">&quot;chooseFile($event)&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">fileDropRef</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fileDropRef&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">multiple</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            (<span class=\"attr\">change</span>)=<span class=\"string\">&quot;chooseFile($event)&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>拖曳檔案至此處<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;fileDropRef&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        或點擊此處選擇上傳檔案</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>基本上就只是在監聽「拖曳進入」「拖曳離開」事件，為區域加上 css 讓使用者得到回饋，然後在「丟下檔案」的時候，emit 給 <code>upload.ts</code> 的 <code>chooseFile()</code> 接收。</p>\n<p>另外還有用 <code>cdkDropList</code> 結合 <code>bootstrap</code> 卡片呈現，製作出拖拉調整順序的介面。除外的就不值一提，很普通XD。</p>\n<hr>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>後端跟前端都寫好之後，部署的順序如下：</p>\n<ul>\n<li>將後端專案複製到虛擬機專案路徑底下<ul>\n<li>對目標 DB 做 Migration</li>\n<li>Systemctl 建立 service daemon file</li>\n<li>啟用服務</li>\n</ul>\n</li>\n<li>將前端專案複製到虛擬機專案路徑底下<ul>\n<li>設定 Apache proxy，將目標網址導向後端 API 或前端網頁</li>\n<li>設定防火牆，讓使用者能存取 port</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Database-Migration\"><a href=\"#Database-Migration\" class=\"headerlink\" title=\"Database Migration\"></a>Database Migration</h3><p>在 Migration 這關其實也摸索了滿久的，後來逐漸認知到步驟其實很單純（我用 <code>flask-sqlalchemy</code> 來做 DB Migration）：</p>\n<ul>\n<li><code>flask db migrate</code> 來產生 migration file（比對 <code>dbTable.py</code> 中 table schema 與目標資料庫中的 schema）</li>\n<li>檢查 upgrade file 裡的操作是否都符合需求</li>\n<li><code>flask db upgrade</code> 就 Migrate 成功啦！</li>\n</ul>\n<p>至於 <code>backup</code>、<code>rollback</code>，就之後再考慮吧。</p>\n<h3 id=\"Linux-Service\"><a href=\"#Linux-Service\" class=\"headerlink\" title=\"Linux Service\"></a>Linux Service</h3><blockquote>\n<p>之前有整理過一份 <code>systemctl</code> 的操作，指令都在 <a href=\"https://gkfat.github.io/2021/08/01/linux-systemctl/\">這裡</a>。</p>\n</blockquote>\n<ul>\n<li>在虛擬機建立 system daemon file</li>\n<li><code>systmectl daemon-reload</code> 來載入 service</li>\n<li><code>systemctl start &lt;service&gt;</code> 就啟用服務啦！</li>\n</ul>\n<hr>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>現在回頭看看，2021 年初時我還連 DB 怎麼下 query 都搞不懂，連 Linux 都不會操作，過了半年後，居然能夠一條龍做到下列事項：</p>\n<ul>\n<li>使用 Python 撰寫 http server、撰寫 API 文件、撰寫方便部署的 Shell Script</li>\n<li>串接 MariaDB 資料庫、執行 DB migration、串接 NAS</li>\n<li>使用 Angular 串接 http server</li>\n<li>部署後端服務、前端專案到虛擬機</li>\n<li>設定 Apache、防火牆讓使用者能夠連線</li>\n</ul>\n<p>真的是滿感謝有這個大好機會，讓我對整套專案的執行有了進一步的了解（但不敢說這就叫全端），經過了一兩季後，這個專案也已經逐漸成長到了 1.5 版本，對於後端也愈來愈能理解了。接下來想把重心放在學習 Golang，以及加強後端 Concurrency 處理的觀念。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2020/02/09/sql-basic-tutorial/\" >TechBridge 技術共筆 - 簡明 SQL 資料庫語法入門教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Road to Front-End Developer","date":"2019-10-14T23:30:33.000Z","_content":"當我還是個稚嫩的高中生時，我非常討厭電腦課教的程式語言（C++／VB），認為這輩子都跟程式絕緣。殊不知在日新月異的前端領域中，我找到了比設計、文案更巨大的成就感。下定決心轉職的幾個月後，我已經找到一份前端工程師的工作了。\n<!--more-->\n\n---\n\n## 一切都始於一個小小的契機\n\n> 在成為前端工程師的路上，用微小而堅定的步伐，努力邁進。\n\n說到為什麼會想要轉職成前端工程師，原因其實還滿單純的：因為寫程式很有成就感。\n\n2018 / 6 月前後，我當時的工作是文案企劃，做著做著就也想順便弄一下自己的部落格（當時比較各家之後選用 WordPress.org），買了網域、找了厲害的工程師朋友幫忙處理後台，勉勉強強也是讓部落格上線了。無奈的是，想要自訂點畫面，卻連 CSS 都看不懂，只能一直加裝 plugin，網站就一直增肥，幾個月後只好放棄。\n\n大概就是從那個時候開始，覺得 CSS 很有趣。設定點東西，畫面就會改變，這件事帶來相當巨大的成就感。\n\n從那之後就會時不時地看一下 [W3Schools](https://www.w3schools.com/)，想要多了解一點程式語言，從此一腳踏進前端的世界，回不了頭了。\n\n---\n## 莫名其妙開始的自學之路\n\n> 你真的知道自己在做什麼嗎？\n\n不過當時我連前端／後端具體是什麼都還不清楚，一下就看 W3School，對初學者的我而言難度太高。於是，我決定先研究一下大方向，了解一下這產業的環境。\n\n### 學習路徑\n\n> 摸黑如何前進？\n\n我爬了不少文章跟網站，總算稍微分得清前／後端。但嚇人的是，程式語言的語言、框架、函式庫、專業術語就像床上的塵蟎一樣，想到就頭皮發麻。我一直不斷地搜尋、整理、調整，總算列出自己想要的學習路徑，之後才是去驗證這條路徑到底適不適合我（必須且戰且走才知道！）。\n\n下面列出一些滿值得參考的文件，沒方向的時候就上去看看自己在哪個階段、應該要去學什麼：\n\n* [前端資源懶人包](https://docs.google.com/document/d/13nK_XY9u5uIleTpSCw88lMupzgCSwXd6j6je44eLhMQ/edit)\n* [前端九部 - 入門者手冊2019](https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8)\n* [胡立 - 前端循序漸進學習路程](https://github.com/aszx87410/frontend-intermediate-course)\n* 網路上許多大大的轉職心得文\n\n東看看西看看之後，我得到的結論是，前端的一切其實都是從這三個東西延伸出來的：\n\n* HTML\n* CSS\n* JavaScript\n\n你知道，我知道，獨眼龍也知道，這些都是基本中的基本。基本，很枯燥乏味，但不論學什麼，打好地基都是幫助之後快速成長最快的途徑，這是我的信念。正因如此，在學會使用框架、函式庫之前，必須學會使用原生的方式寫出任何想要呈現的效果，才夠格說自己會前端。很多問題其實在網路上都有解答，真的要用的時候剪貼過來就好了，問題是我看不看得懂人家在寫什麼。如果只是要會用，那難度其實不會太高，但是我絕不要做一個只會 Ctrl+C / Ctrl+V 的工程師。\n\n我要能夠自己變出來啊！\n\n這是我對自己的要求，所以前面好幾個月，我把時間全部投注在打基礎上。\n\n> 在這個階段，很適合去看一些基礎的教學影片，或跟著免費課程一步一步學習，例如：\n> - [澎澎的 JavaScript 前端工程](https://www.youtube.com/user/padalab/playlists?view=50&sort=dd&shelf_id=4)\n> - [Traversy Media](https://www.youtube.com/user/TechGuyWeb)\n> - [Free Code Camp](https://www.freecodecamp.org/)\n> - [CodeCademy](https://www.codecademy.com/)\n\n### 自學最重要的事\n\n> 如果你都不放過自己，還有誰會放過你？\n\n我認為自學最重要的事情，就是要認知到下面兩點：\n1. 沒有人會逼你，所以你得逼自己\n2. 何時該放自己一馬\n\n第一點人人都明白，但假如你沒辦法讓自己適當地休息，掌控自己的節奏，那很容易會把自己逼到盡頭，如果你是喜歡挑戰極限的人，這樣做當然挺好的，但如果你像我一樣是個凡人，那逼到極限就意味著離放棄不遠了。\n\n要時常回想，當時為什麼要開始學程式？回想起那些富有成就感的時刻，想想初衷，好好放鬆一下身心，然後繼續再戰。\n\n這樣，才能走得長遠。\n\n### 支撐我繼續走下去的成就感來源：進入心流\n\n> 支撐你繼續堅持下去的，又是什麼呢？\n\n學習前端好一陣子，終於能夠開始寫點小作品了的時候，我有時會體驗到進入心流的感覺。那是一種專心致志、全神貫注、腦子非常清楚、全然投入的感覺，有好幾天 coding 到晚上 11、12 點，睡覺夢到某個問題的解法，清晨 4、5 點就清醒，然後再也睡不著，只想繼續寫。\n\n最近在開發一個案子，也有滿高的機率開啟心流。那種感覺，真的只有一個爽字能形容！\n\n但我逐漸認知到，這種時刻通常都是出現在「產出」，而非「吸收」的時候，也因此要避免自己只想寫不想學，這樣只會把自己榨乾而已。該累積養分的時候還是得乖乖學習的唷。\n\n---\n## 確定要來真的了嗎？轉職的轉捩點\n\n> 你是何時開始認真看待自己要轉職到一個完全陌生的領域這件事呢？\n\n大約是在 2019 / 4 月左右，當時覺得對於 HTML / CSS 已經有基礎的了解， CodeCademy、FreeCodeCamp 上的免費教程也已經做到有點索然無味了，想要來認真加深 JavaScript 能力，一方面也想著：「是不是該來認真考慮轉職的事了？」\n\n### 果斷辭職\n\n> 有時候，純粹是一股衝動。\n\n搜尋了一陣子 JS 課程後，我報了台大資訊系統的一門實體課，叫做「網頁前端實務 JavaScript」，教的內容完全符合我的需求，既超出我的程度，又不會到完全不懂，但需要很努力才能跟上腳步的那種。\n\n我原本一直是用業餘的時間來學程式，但漸漸地發現，這樣下去我的學習成果不會好。既然已經決定要轉職了，那就必須投入 100% 努力才行。因此在 2019 / 5 月中，我果斷離開原本的工作，專心在學習程式、準備轉職上。\n\n### 久到令人心慌的空窗期\n\n> 前途一片迷茫。何時才能結束？\n\n前前後後空窗了 4 個半月，是我人生中目前為止空窗最久的一段時間了。\n\n這段期間，每天大部分的時間都花在學習程式上。當然，「假如失敗」的念頭，三不五時就會冒出來。每當這種時候，轉移注意力、貨回憶初衷，都是很有效的辦法，能將自己拉回正軌。\n\n當你專注在一件事情上的時候，全宇宙都會來推你一把！就是在這個時期，我參加了幾個前端 Facebook 社團，而剛好看到了 Luka 大大創立的 [程式柴 Codeshiba](https://www.facebook.com/CodeShiba/) 專頁，當時正準備開啟一連串的職涯領航計畫，衝著免費我就報名了。\n\n發現有一群人跟自己在同樣的道路上掙扎前進，那種感覺是無可比擬的，就好像原本是獨自一人在跑馬拉松，突然發現其實身邊全是夥伴的感覺。而且有個 mentor 領跑，更能夠幫助自己看清方向，去除掉不必要的、浪費時間的事，更有效率地專注在達成目標上。\n\nCodeShiba 社團真的給予我很大的助力，跪拜 Luka 大大。\n\n> 想加入需要通過審核，請自行私訊程式柴粉絲頁\n> * 粉絲頁： [程式柴 Codeshiba](https://www.facebook.com/CodeShiba/) \n> * 社團： [CodeShiba 學員專區](https://www.facebook.com/groups/1723508807794929/)\n\n---\n## 跌跌撞撞的面試\n\n### 面試才知道自己哪裡不足\n\n> 你以為公司為什麼過這麼久都不通知你？\n\n這幾個月都是在 Udemy / Youtube 上找課程、影片學習，偶爾有靈感的時候，就會自己寫個小作品（寫的時候很有成就感，寫完回頭看才覺得怎麼那麼醜，哈哈哈）。\n\n差不多七月中，開始有公司會發面試邀請過來，但面試完幾乎都沒有下文。我心裡很清楚是因為程度不足被刷掉，所以每一次的面試，我都會盡量去記被問到答不出來、或答得卡卡的部分，那些就是我該補強的地方（結果多到數不清...）。\n\n以下是每次面試都會被問到的部分：\n* git 能力\n* CSS 切版（Float、Flexbox、Grid）\n* CSS 權重觀念\n* JS DOM／陣列 操作\n* JS 串接 API、Ajax、ES6\n\n除了自己去面試，也可以多多參考他人的履歷，Luka 相當熟知怎樣的履歷看起來會吸引人而且程度很高，被他調整履歷了之後不久，我就找到目前的工作了（當然，還是有一些運氣成份，幸好面試主管實際問到的問題我答得出來）。實在是可喜可賀！\n\n> [GK 的履歷，看看笑笑就好](https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang)\n\n---\n## Road to Front End Developer Never Ends\n\n> 這是一條沒有盡頭的路。\n\n我畢竟還是個全然的跨領域轉職者，雖然已經有一些基礎了，但比起原本就在這一行裡打滾的前輩們，根本完全不夠。接下來我為自己設定的方向如下：\n\n* 在公司裡能學到的\n    * 業界協作流程（git）\n    * 與 server 互動（串資料）\n    * JS 框架（Angular）\n* 自行練習\n    * CSS（Materialize、Bulma、BootStrap 等套件）\n    * jQuery（沒錯！我還不會 jQuery，通通都是寫原生）\n    * 補足瀏覽器、http 協定等相關知識\n    * 加深 JavaScript 觀念\n    * 學習 Node.js\n\n原本的目標是兩年內要能夠自己寫含前後端的部落格，不過我現在期望自己能夠盡快學會跟 App 有關的能力，因為我有一些有趣的遊戲跟應用的點子，卻寫不出來，很痛苦啊。\n\n對我來說，轉職只是個中繼點，通過這個 check point，不代表已經到終點了，還是必須繼續朝目標前進。終極目標是什麼？其實我也不曉得，就且戰且走吧。\n\n總而言之，祝各位在轉職的路上，穩定踏實地邁進！\n","source":"_posts/road-to-front-end.md","raw":"---\ntitle: Road to Front-End Developer\ndate: 2019-10-15 07:30:33\ntags: Career\n---\n當我還是個稚嫩的高中生時，我非常討厭電腦課教的程式語言（C++／VB），認為這輩子都跟程式絕緣。殊不知在日新月異的前端領域中，我找到了比設計、文案更巨大的成就感。下定決心轉職的幾個月後，我已經找到一份前端工程師的工作了。\n<!--more-->\n\n---\n\n## 一切都始於一個小小的契機\n\n> 在成為前端工程師的路上，用微小而堅定的步伐，努力邁進。\n\n說到為什麼會想要轉職成前端工程師，原因其實還滿單純的：因為寫程式很有成就感。\n\n2018 / 6 月前後，我當時的工作是文案企劃，做著做著就也想順便弄一下自己的部落格（當時比較各家之後選用 WordPress.org），買了網域、找了厲害的工程師朋友幫忙處理後台，勉勉強強也是讓部落格上線了。無奈的是，想要自訂點畫面，卻連 CSS 都看不懂，只能一直加裝 plugin，網站就一直增肥，幾個月後只好放棄。\n\n大概就是從那個時候開始，覺得 CSS 很有趣。設定點東西，畫面就會改變，這件事帶來相當巨大的成就感。\n\n從那之後就會時不時地看一下 [W3Schools](https://www.w3schools.com/)，想要多了解一點程式語言，從此一腳踏進前端的世界，回不了頭了。\n\n---\n## 莫名其妙開始的自學之路\n\n> 你真的知道自己在做什麼嗎？\n\n不過當時我連前端／後端具體是什麼都還不清楚，一下就看 W3School，對初學者的我而言難度太高。於是，我決定先研究一下大方向，了解一下這產業的環境。\n\n### 學習路徑\n\n> 摸黑如何前進？\n\n我爬了不少文章跟網站，總算稍微分得清前／後端。但嚇人的是，程式語言的語言、框架、函式庫、專業術語就像床上的塵蟎一樣，想到就頭皮發麻。我一直不斷地搜尋、整理、調整，總算列出自己想要的學習路徑，之後才是去驗證這條路徑到底適不適合我（必須且戰且走才知道！）。\n\n下面列出一些滿值得參考的文件，沒方向的時候就上去看看自己在哪個階段、應該要去學什麼：\n\n* [前端資源懶人包](https://docs.google.com/document/d/13nK_XY9u5uIleTpSCw88lMupzgCSwXd6j6je44eLhMQ/edit)\n* [前端九部 - 入門者手冊2019](https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8)\n* [胡立 - 前端循序漸進學習路程](https://github.com/aszx87410/frontend-intermediate-course)\n* 網路上許多大大的轉職心得文\n\n東看看西看看之後，我得到的結論是，前端的一切其實都是從這三個東西延伸出來的：\n\n* HTML\n* CSS\n* JavaScript\n\n你知道，我知道，獨眼龍也知道，這些都是基本中的基本。基本，很枯燥乏味，但不論學什麼，打好地基都是幫助之後快速成長最快的途徑，這是我的信念。正因如此，在學會使用框架、函式庫之前，必須學會使用原生的方式寫出任何想要呈現的效果，才夠格說自己會前端。很多問題其實在網路上都有解答，真的要用的時候剪貼過來就好了，問題是我看不看得懂人家在寫什麼。如果只是要會用，那難度其實不會太高，但是我絕不要做一個只會 Ctrl+C / Ctrl+V 的工程師。\n\n我要能夠自己變出來啊！\n\n這是我對自己的要求，所以前面好幾個月，我把時間全部投注在打基礎上。\n\n> 在這個階段，很適合去看一些基礎的教學影片，或跟著免費課程一步一步學習，例如：\n> - [澎澎的 JavaScript 前端工程](https://www.youtube.com/user/padalab/playlists?view=50&sort=dd&shelf_id=4)\n> - [Traversy Media](https://www.youtube.com/user/TechGuyWeb)\n> - [Free Code Camp](https://www.freecodecamp.org/)\n> - [CodeCademy](https://www.codecademy.com/)\n\n### 自學最重要的事\n\n> 如果你都不放過自己，還有誰會放過你？\n\n我認為自學最重要的事情，就是要認知到下面兩點：\n1. 沒有人會逼你，所以你得逼自己\n2. 何時該放自己一馬\n\n第一點人人都明白，但假如你沒辦法讓自己適當地休息，掌控自己的節奏，那很容易會把自己逼到盡頭，如果你是喜歡挑戰極限的人，這樣做當然挺好的，但如果你像我一樣是個凡人，那逼到極限就意味著離放棄不遠了。\n\n要時常回想，當時為什麼要開始學程式？回想起那些富有成就感的時刻，想想初衷，好好放鬆一下身心，然後繼續再戰。\n\n這樣，才能走得長遠。\n\n### 支撐我繼續走下去的成就感來源：進入心流\n\n> 支撐你繼續堅持下去的，又是什麼呢？\n\n學習前端好一陣子，終於能夠開始寫點小作品了的時候，我有時會體驗到進入心流的感覺。那是一種專心致志、全神貫注、腦子非常清楚、全然投入的感覺，有好幾天 coding 到晚上 11、12 點，睡覺夢到某個問題的解法，清晨 4、5 點就清醒，然後再也睡不著，只想繼續寫。\n\n最近在開發一個案子，也有滿高的機率開啟心流。那種感覺，真的只有一個爽字能形容！\n\n但我逐漸認知到，這種時刻通常都是出現在「產出」，而非「吸收」的時候，也因此要避免自己只想寫不想學，這樣只會把自己榨乾而已。該累積養分的時候還是得乖乖學習的唷。\n\n---\n## 確定要來真的了嗎？轉職的轉捩點\n\n> 你是何時開始認真看待自己要轉職到一個完全陌生的領域這件事呢？\n\n大約是在 2019 / 4 月左右，當時覺得對於 HTML / CSS 已經有基礎的了解， CodeCademy、FreeCodeCamp 上的免費教程也已經做到有點索然無味了，想要來認真加深 JavaScript 能力，一方面也想著：「是不是該來認真考慮轉職的事了？」\n\n### 果斷辭職\n\n> 有時候，純粹是一股衝動。\n\n搜尋了一陣子 JS 課程後，我報了台大資訊系統的一門實體課，叫做「網頁前端實務 JavaScript」，教的內容完全符合我的需求，既超出我的程度，又不會到完全不懂，但需要很努力才能跟上腳步的那種。\n\n我原本一直是用業餘的時間來學程式，但漸漸地發現，這樣下去我的學習成果不會好。既然已經決定要轉職了，那就必須投入 100% 努力才行。因此在 2019 / 5 月中，我果斷離開原本的工作，專心在學習程式、準備轉職上。\n\n### 久到令人心慌的空窗期\n\n> 前途一片迷茫。何時才能結束？\n\n前前後後空窗了 4 個半月，是我人生中目前為止空窗最久的一段時間了。\n\n這段期間，每天大部分的時間都花在學習程式上。當然，「假如失敗」的念頭，三不五時就會冒出來。每當這種時候，轉移注意力、貨回憶初衷，都是很有效的辦法，能將自己拉回正軌。\n\n當你專注在一件事情上的時候，全宇宙都會來推你一把！就是在這個時期，我參加了幾個前端 Facebook 社團，而剛好看到了 Luka 大大創立的 [程式柴 Codeshiba](https://www.facebook.com/CodeShiba/) 專頁，當時正準備開啟一連串的職涯領航計畫，衝著免費我就報名了。\n\n發現有一群人跟自己在同樣的道路上掙扎前進，那種感覺是無可比擬的，就好像原本是獨自一人在跑馬拉松，突然發現其實身邊全是夥伴的感覺。而且有個 mentor 領跑，更能夠幫助自己看清方向，去除掉不必要的、浪費時間的事，更有效率地專注在達成目標上。\n\nCodeShiba 社團真的給予我很大的助力，跪拜 Luka 大大。\n\n> 想加入需要通過審核，請自行私訊程式柴粉絲頁\n> * 粉絲頁： [程式柴 Codeshiba](https://www.facebook.com/CodeShiba/) \n> * 社團： [CodeShiba 學員專區](https://www.facebook.com/groups/1723508807794929/)\n\n---\n## 跌跌撞撞的面試\n\n### 面試才知道自己哪裡不足\n\n> 你以為公司為什麼過這麼久都不通知你？\n\n這幾個月都是在 Udemy / Youtube 上找課程、影片學習，偶爾有靈感的時候，就會自己寫個小作品（寫的時候很有成就感，寫完回頭看才覺得怎麼那麼醜，哈哈哈）。\n\n差不多七月中，開始有公司會發面試邀請過來，但面試完幾乎都沒有下文。我心裡很清楚是因為程度不足被刷掉，所以每一次的面試，我都會盡量去記被問到答不出來、或答得卡卡的部分，那些就是我該補強的地方（結果多到數不清...）。\n\n以下是每次面試都會被問到的部分：\n* git 能力\n* CSS 切版（Float、Flexbox、Grid）\n* CSS 權重觀念\n* JS DOM／陣列 操作\n* JS 串接 API、Ajax、ES6\n\n除了自己去面試，也可以多多參考他人的履歷，Luka 相當熟知怎樣的履歷看起來會吸引人而且程度很高，被他調整履歷了之後不久，我就找到目前的工作了（當然，還是有一些運氣成份，幸好面試主管實際問到的問題我答得出來）。實在是可喜可賀！\n\n> [GK 的履歷，看看笑笑就好](https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang)\n\n---\n## Road to Front End Developer Never Ends\n\n> 這是一條沒有盡頭的路。\n\n我畢竟還是個全然的跨領域轉職者，雖然已經有一些基礎了，但比起原本就在這一行裡打滾的前輩們，根本完全不夠。接下來我為自己設定的方向如下：\n\n* 在公司裡能學到的\n    * 業界協作流程（git）\n    * 與 server 互動（串資料）\n    * JS 框架（Angular）\n* 自行練習\n    * CSS（Materialize、Bulma、BootStrap 等套件）\n    * jQuery（沒錯！我還不會 jQuery，通通都是寫原生）\n    * 補足瀏覽器、http 協定等相關知識\n    * 加深 JavaScript 觀念\n    * 學習 Node.js\n\n原本的目標是兩年內要能夠自己寫含前後端的部落格，不過我現在期望自己能夠盡快學會跟 App 有關的能力，因為我有一些有趣的遊戲跟應用的點子，卻寫不出來，很痛苦啊。\n\n對我來說，轉職只是個中繼點，通過這個 check point，不代表已經到終點了，還是必須繼續朝目標前進。終極目標是什麼？其實我也不曉得，就且戰且走吧。\n\n總而言之，祝各位在轉職的路上，穩定踏實地邁進！\n","slug":"road-to-front-end","published":1,"updated":"2022-03-12T12:58:21.491Z","_id":"cl0nustxx0027z6us95ob969x","comments":1,"layout":"post","photos":[],"link":"","content":"<p>當我還是個稚嫩的高中生時，我非常討厭電腦課教的程式語言（C++／VB），認為這輩子都跟程式絕緣。殊不知在日新月異的前端領域中，我找到了比設計、文案更巨大的成就感。下定決心轉職的幾個月後，我已經找到一份前端工程師的工作了。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"一切都始於一個小小的契機\"><a href=\"#一切都始於一個小小的契機\" class=\"headerlink\" title=\"一切都始於一個小小的契機\"></a>一切都始於一個小小的契機</h2><blockquote>\n<p>在成為前端工程師的路上，用微小而堅定的步伐，努力邁進。</p>\n</blockquote>\n<p>說到為什麼會想要轉職成前端工程師，原因其實還滿單純的：因為寫程式很有成就感。</p>\n<p>2018 &#x2F; 6 月前後，我當時的工作是文案企劃，做著做著就也想順便弄一下自己的部落格（當時比較各家之後選用 WordPress.org），買了網域、找了厲害的工程師朋友幫忙處理後台，勉勉強強也是讓部落格上線了。無奈的是，想要自訂點畫面，卻連 CSS 都看不懂，只能一直加裝 plugin，網站就一直增肥，幾個月後只好放棄。</p>\n<p>大概就是從那個時候開始，覺得 CSS 很有趣。設定點東西，畫面就會改變，這件事帶來相當巨大的成就感。</p>\n<p>從那之後就會時不時地看一下 <a class=\"link\"   href=\"https://www.w3schools.com/\" >W3Schools<i class=\"fas fa-external-link-alt\"></i></a>，想要多了解一點程式語言，從此一腳踏進前端的世界，回不了頭了。</p>\n<hr>\n<h2 id=\"莫名其妙開始的自學之路\"><a href=\"#莫名其妙開始的自學之路\" class=\"headerlink\" title=\"莫名其妙開始的自學之路\"></a>莫名其妙開始的自學之路</h2><blockquote>\n<p>你真的知道自己在做什麼嗎？</p>\n</blockquote>\n<p>不過當時我連前端／後端具體是什麼都還不清楚，一下就看 W3School，對初學者的我而言難度太高。於是，我決定先研究一下大方向，了解一下這產業的環境。</p>\n<h3 id=\"學習路徑\"><a href=\"#學習路徑\" class=\"headerlink\" title=\"學習路徑\"></a>學習路徑</h3><blockquote>\n<p>摸黑如何前進？</p>\n</blockquote>\n<p>我爬了不少文章跟網站，總算稍微分得清前／後端。但嚇人的是，程式語言的語言、框架、函式庫、專業術語就像床上的塵蟎一樣，想到就頭皮發麻。我一直不斷地搜尋、整理、調整，總算列出自己想要的學習路徑，之後才是去驗證這條路徑到底適不適合我（必須且戰且走才知道！）。</p>\n<p>下面列出一些滿值得參考的文件，沒方向的時候就上去看看自己在哪個階段、應該要去學什麼：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://docs.google.com/document/d/13nK_XY9u5uIleTpSCw88lMupzgCSwXd6j6je44eLhMQ/edit\" >前端資源懶人包<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8\" >前端九部 - 入門者手冊2019<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/aszx87410/frontend-intermediate-course\" >胡立 - 前端循序漸進學習路程<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>網路上許多大大的轉職心得文</li>\n</ul>\n<p>東看看西看看之後，我得到的結論是，前端的一切其實都是從這三個東西延伸出來的：</p>\n<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ul>\n<p>你知道，我知道，獨眼龍也知道，這些都是基本中的基本。基本，很枯燥乏味，但不論學什麼，打好地基都是幫助之後快速成長最快的途徑，這是我的信念。正因如此，在學會使用框架、函式庫之前，必須學會使用原生的方式寫出任何想要呈現的效果，才夠格說自己會前端。很多問題其實在網路上都有解答，真的要用的時候剪貼過來就好了，問題是我看不看得懂人家在寫什麼。如果只是要會用，那難度其實不會太高，但是我絕不要做一個只會 Ctrl+C &#x2F; Ctrl+V 的工程師。</p>\n<p>我要能夠自己變出來啊！</p>\n<p>這是我對自己的要求，所以前面好幾個月，我把時間全部投注在打基礎上。</p>\n<blockquote>\n<p>在這個階段，很適合去看一些基礎的教學影片，或跟著免費課程一步一步學習，例如：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.youtube.com/user/padalab/playlists?view=50&sort=dd&shelf_id=4\" >澎澎的 JavaScript 前端工程<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/user/TechGuyWeb\" >Traversy Media<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.freecodecamp.org/\" >Free Code Camp<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.codecademy.com/\" >CodeCademy<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n</blockquote>\n<h3 id=\"自學最重要的事\"><a href=\"#自學最重要的事\" class=\"headerlink\" title=\"自學最重要的事\"></a>自學最重要的事</h3><blockquote>\n<p>如果你都不放過自己，還有誰會放過你？</p>\n</blockquote>\n<p>我認為自學最重要的事情，就是要認知到下面兩點：</p>\n<ol>\n<li>沒有人會逼你，所以你得逼自己</li>\n<li>何時該放自己一馬</li>\n</ol>\n<p>第一點人人都明白，但假如你沒辦法讓自己適當地休息，掌控自己的節奏，那很容易會把自己逼到盡頭，如果你是喜歡挑戰極限的人，這樣做當然挺好的，但如果你像我一樣是個凡人，那逼到極限就意味著離放棄不遠了。</p>\n<p>要時常回想，當時為什麼要開始學程式？回想起那些富有成就感的時刻，想想初衷，好好放鬆一下身心，然後繼續再戰。</p>\n<p>這樣，才能走得長遠。</p>\n<h3 id=\"支撐我繼續走下去的成就感來源：進入心流\"><a href=\"#支撐我繼續走下去的成就感來源：進入心流\" class=\"headerlink\" title=\"支撐我繼續走下去的成就感來源：進入心流\"></a>支撐我繼續走下去的成就感來源：進入心流</h3><blockquote>\n<p>支撐你繼續堅持下去的，又是什麼呢？</p>\n</blockquote>\n<p>學習前端好一陣子，終於能夠開始寫點小作品了的時候，我有時會體驗到進入心流的感覺。那是一種專心致志、全神貫注、腦子非常清楚、全然投入的感覺，有好幾天 coding 到晚上 11、12 點，睡覺夢到某個問題的解法，清晨 4、5 點就清醒，然後再也睡不著，只想繼續寫。</p>\n<p>最近在開發一個案子，也有滿高的機率開啟心流。那種感覺，真的只有一個爽字能形容！</p>\n<p>但我逐漸認知到，這種時刻通常都是出現在「產出」，而非「吸收」的時候，也因此要避免自己只想寫不想學，這樣只會把自己榨乾而已。該累積養分的時候還是得乖乖學習的唷。</p>\n<hr>\n<h2 id=\"確定要來真的了嗎？轉職的轉捩點\"><a href=\"#確定要來真的了嗎？轉職的轉捩點\" class=\"headerlink\" title=\"確定要來真的了嗎？轉職的轉捩點\"></a>確定要來真的了嗎？轉職的轉捩點</h2><blockquote>\n<p>你是何時開始認真看待自己要轉職到一個完全陌生的領域這件事呢？</p>\n</blockquote>\n<p>大約是在 2019 &#x2F; 4 月左右，當時覺得對於 HTML &#x2F; CSS 已經有基礎的了解， CodeCademy、FreeCodeCamp 上的免費教程也已經做到有點索然無味了，想要來認真加深 JavaScript 能力，一方面也想著：「是不是該來認真考慮轉職的事了？」</p>\n<h3 id=\"果斷辭職\"><a href=\"#果斷辭職\" class=\"headerlink\" title=\"果斷辭職\"></a>果斷辭職</h3><blockquote>\n<p>有時候，純粹是一股衝動。</p>\n</blockquote>\n<p>搜尋了一陣子 JS 課程後，我報了台大資訊系統的一門實體課，叫做「網頁前端實務 JavaScript」，教的內容完全符合我的需求，既超出我的程度，又不會到完全不懂，但需要很努力才能跟上腳步的那種。</p>\n<p>我原本一直是用業餘的時間來學程式，但漸漸地發現，這樣下去我的學習成果不會好。既然已經決定要轉職了，那就必須投入 100% 努力才行。因此在 2019 &#x2F; 5 月中，我果斷離開原本的工作，專心在學習程式、準備轉職上。</p>\n<h3 id=\"久到令人心慌的空窗期\"><a href=\"#久到令人心慌的空窗期\" class=\"headerlink\" title=\"久到令人心慌的空窗期\"></a>久到令人心慌的空窗期</h3><blockquote>\n<p>前途一片迷茫。何時才能結束？</p>\n</blockquote>\n<p>前前後後空窗了 4 個半月，是我人生中目前為止空窗最久的一段時間了。</p>\n<p>這段期間，每天大部分的時間都花在學習程式上。當然，「假如失敗」的念頭，三不五時就會冒出來。每當這種時候，轉移注意力、貨回憶初衷，都是很有效的辦法，能將自己拉回正軌。</p>\n<p>當你專注在一件事情上的時候，全宇宙都會來推你一把！就是在這個時期，我參加了幾個前端 Facebook 社團，而剛好看到了 Luka 大大創立的 <a class=\"link\"   href=\"https://www.facebook.com/CodeShiba/\" >程式柴 Codeshiba<i class=\"fas fa-external-link-alt\"></i></a> 專頁，當時正準備開啟一連串的職涯領航計畫，衝著免費我就報名了。</p>\n<p>發現有一群人跟自己在同樣的道路上掙扎前進，那種感覺是無可比擬的，就好像原本是獨自一人在跑馬拉松，突然發現其實身邊全是夥伴的感覺。而且有個 mentor 領跑，更能夠幫助自己看清方向，去除掉不必要的、浪費時間的事，更有效率地專注在達成目標上。</p>\n<p>CodeShiba 社團真的給予我很大的助力，跪拜 Luka 大大。</p>\n<blockquote>\n<p>想加入需要通過審核，請自行私訊程式柴粉絲頁</p>\n<ul>\n<li>粉絲頁： <a class=\"link\"   href=\"https://www.facebook.com/CodeShiba/\" >程式柴 Codeshiba<i class=\"fas fa-external-link-alt\"></i></a> </li>\n<li>社團： <a class=\"link\"   href=\"https://www.facebook.com/groups/1723508807794929/\" >CodeShiba 學員專區<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"跌跌撞撞的面試\"><a href=\"#跌跌撞撞的面試\" class=\"headerlink\" title=\"跌跌撞撞的面試\"></a>跌跌撞撞的面試</h2><h3 id=\"面試才知道自己哪裡不足\"><a href=\"#面試才知道自己哪裡不足\" class=\"headerlink\" title=\"面試才知道自己哪裡不足\"></a>面試才知道自己哪裡不足</h3><blockquote>\n<p>你以為公司為什麼過這麼久都不通知你？</p>\n</blockquote>\n<p>這幾個月都是在 Udemy &#x2F; Youtube 上找課程、影片學習，偶爾有靈感的時候，就會自己寫個小作品（寫的時候很有成就感，寫完回頭看才覺得怎麼那麼醜，哈哈哈）。</p>\n<p>差不多七月中，開始有公司會發面試邀請過來，但面試完幾乎都沒有下文。我心裡很清楚是因為程度不足被刷掉，所以每一次的面試，我都會盡量去記被問到答不出來、或答得卡卡的部分，那些就是我該補強的地方（結果多到數不清…）。</p>\n<p>以下是每次面試都會被問到的部分：</p>\n<ul>\n<li>git 能力</li>\n<li>CSS 切版（Float、Flexbox、Grid）</li>\n<li>CSS 權重觀念</li>\n<li>JS DOM／陣列 操作</li>\n<li>JS 串接 API、Ajax、ES6</li>\n</ul>\n<p>除了自己去面試，也可以多多參考他人的履歷，Luka 相當熟知怎樣的履歷看起來會吸引人而且程度很高，被他調整履歷了之後不久，我就找到目前的工作了（當然，還是有一些運氣成份，幸好面試主管實際問到的問題我答得出來）。實在是可喜可賀！</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\" >GK 的履歷，看看笑笑就好<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<hr>\n<h2 id=\"Road-to-Front-End-Developer-Never-Ends\"><a href=\"#Road-to-Front-End-Developer-Never-Ends\" class=\"headerlink\" title=\"Road to Front End Developer Never Ends\"></a>Road to Front End Developer Never Ends</h2><blockquote>\n<p>這是一條沒有盡頭的路。</p>\n</blockquote>\n<p>我畢竟還是個全然的跨領域轉職者，雖然已經有一些基礎了，但比起原本就在這一行裡打滾的前輩們，根本完全不夠。接下來我為自己設定的方向如下：</p>\n<ul>\n<li>在公司裡能學到的<ul>\n<li>業界協作流程（git）</li>\n<li>與 server 互動（串資料）</li>\n<li>JS 框架（Angular）</li>\n</ul>\n</li>\n<li>自行練習<ul>\n<li>CSS（Materialize、Bulma、BootStrap 等套件）</li>\n<li>jQuery（沒錯！我還不會 jQuery，通通都是寫原生）</li>\n<li>補足瀏覽器、http 協定等相關知識</li>\n<li>加深 JavaScript 觀念</li>\n<li>學習 Node.js</li>\n</ul>\n</li>\n</ul>\n<p>原本的目標是兩年內要能夠自己寫含前後端的部落格，不過我現在期望自己能夠盡快學會跟 App 有關的能力，因為我有一些有趣的遊戲跟應用的點子，卻寫不出來，很痛苦啊。</p>\n<p>對我來說，轉職只是個中繼點，通過這個 check point，不代表已經到終點了，還是必須繼續朝目標前進。終極目標是什麼？其實我也不曉得，就且戰且走吧。</p>\n<p>總而言之，祝各位在轉職的路上，穩定踏實地邁進！</p>\n","site":{"data":{}},"excerpt":"<p>當我還是個稚嫩的高中生時，我非常討厭電腦課教的程式語言（C++／VB），認為這輩子都跟程式絕緣。殊不知在日新月異的前端領域中，我找到了比設計、文案更巨大的成就感。下定決心轉職的幾個月後，我已經找到一份前端工程師的工作了。</p>","more":"<hr>\n<h2 id=\"一切都始於一個小小的契機\"><a href=\"#一切都始於一個小小的契機\" class=\"headerlink\" title=\"一切都始於一個小小的契機\"></a>一切都始於一個小小的契機</h2><blockquote>\n<p>在成為前端工程師的路上，用微小而堅定的步伐，努力邁進。</p>\n</blockquote>\n<p>說到為什麼會想要轉職成前端工程師，原因其實還滿單純的：因為寫程式很有成就感。</p>\n<p>2018 &#x2F; 6 月前後，我當時的工作是文案企劃，做著做著就也想順便弄一下自己的部落格（當時比較各家之後選用 WordPress.org），買了網域、找了厲害的工程師朋友幫忙處理後台，勉勉強強也是讓部落格上線了。無奈的是，想要自訂點畫面，卻連 CSS 都看不懂，只能一直加裝 plugin，網站就一直增肥，幾個月後只好放棄。</p>\n<p>大概就是從那個時候開始，覺得 CSS 很有趣。設定點東西，畫面就會改變，這件事帶來相當巨大的成就感。</p>\n<p>從那之後就會時不時地看一下 <a class=\"link\"   href=\"https://www.w3schools.com/\" >W3Schools<i class=\"fas fa-external-link-alt\"></i></a>，想要多了解一點程式語言，從此一腳踏進前端的世界，回不了頭了。</p>\n<hr>\n<h2 id=\"莫名其妙開始的自學之路\"><a href=\"#莫名其妙開始的自學之路\" class=\"headerlink\" title=\"莫名其妙開始的自學之路\"></a>莫名其妙開始的自學之路</h2><blockquote>\n<p>你真的知道自己在做什麼嗎？</p>\n</blockquote>\n<p>不過當時我連前端／後端具體是什麼都還不清楚，一下就看 W3School，對初學者的我而言難度太高。於是，我決定先研究一下大方向，了解一下這產業的環境。</p>\n<h3 id=\"學習路徑\"><a href=\"#學習路徑\" class=\"headerlink\" title=\"學習路徑\"></a>學習路徑</h3><blockquote>\n<p>摸黑如何前進？</p>\n</blockquote>\n<p>我爬了不少文章跟網站，總算稍微分得清前／後端。但嚇人的是，程式語言的語言、框架、函式庫、專業術語就像床上的塵蟎一樣，想到就頭皮發麻。我一直不斷地搜尋、整理、調整，總算列出自己想要的學習路徑，之後才是去驗證這條路徑到底適不適合我（必須且戰且走才知道！）。</p>\n<p>下面列出一些滿值得參考的文件，沒方向的時候就上去看看自己在哪個階段、應該要去學什麼：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://docs.google.com/document/d/13nK_XY9u5uIleTpSCw88lMupzgCSwXd6j6je44eLhMQ/edit\" >前端資源懶人包<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8https://www.yuque.com/fe9/basic?fbclid=IwAR1nXfWqA4CQeD-4R1tH2h8jtwtAFDB4pSKQmhichLeFrHA3csIxvRH-Zv8\" >前端九部 - 入門者手冊2019<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://github.com/aszx87410/frontend-intermediate-course\" >胡立 - 前端循序漸進學習路程<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>網路上許多大大的轉職心得文</li>\n</ul>\n<p>東看看西看看之後，我得到的結論是，前端的一切其實都是從這三個東西延伸出來的：</p>\n<ul>\n<li>HTML</li>\n<li>CSS</li>\n<li>JavaScript</li>\n</ul>\n<p>你知道，我知道，獨眼龍也知道，這些都是基本中的基本。基本，很枯燥乏味，但不論學什麼，打好地基都是幫助之後快速成長最快的途徑，這是我的信念。正因如此，在學會使用框架、函式庫之前，必須學會使用原生的方式寫出任何想要呈現的效果，才夠格說自己會前端。很多問題其實在網路上都有解答，真的要用的時候剪貼過來就好了，問題是我看不看得懂人家在寫什麼。如果只是要會用，那難度其實不會太高，但是我絕不要做一個只會 Ctrl+C &#x2F; Ctrl+V 的工程師。</p>\n<p>我要能夠自己變出來啊！</p>\n<p>這是我對自己的要求，所以前面好幾個月，我把時間全部投注在打基礎上。</p>\n<blockquote>\n<p>在這個階段，很適合去看一些基礎的教學影片，或跟著免費課程一步一步學習，例如：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.youtube.com/user/padalab/playlists?view=50&sort=dd&shelf_id=4\" >澎澎的 JavaScript 前端工程<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/user/TechGuyWeb\" >Traversy Media<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.freecodecamp.org/\" >Free Code Camp<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.codecademy.com/\" >CodeCademy<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n</blockquote>\n<h3 id=\"自學最重要的事\"><a href=\"#自學最重要的事\" class=\"headerlink\" title=\"自學最重要的事\"></a>自學最重要的事</h3><blockquote>\n<p>如果你都不放過自己，還有誰會放過你？</p>\n</blockquote>\n<p>我認為自學最重要的事情，就是要認知到下面兩點：</p>\n<ol>\n<li>沒有人會逼你，所以你得逼自己</li>\n<li>何時該放自己一馬</li>\n</ol>\n<p>第一點人人都明白，但假如你沒辦法讓自己適當地休息，掌控自己的節奏，那很容易會把自己逼到盡頭，如果你是喜歡挑戰極限的人，這樣做當然挺好的，但如果你像我一樣是個凡人，那逼到極限就意味著離放棄不遠了。</p>\n<p>要時常回想，當時為什麼要開始學程式？回想起那些富有成就感的時刻，想想初衷，好好放鬆一下身心，然後繼續再戰。</p>\n<p>這樣，才能走得長遠。</p>\n<h3 id=\"支撐我繼續走下去的成就感來源：進入心流\"><a href=\"#支撐我繼續走下去的成就感來源：進入心流\" class=\"headerlink\" title=\"支撐我繼續走下去的成就感來源：進入心流\"></a>支撐我繼續走下去的成就感來源：進入心流</h3><blockquote>\n<p>支撐你繼續堅持下去的，又是什麼呢？</p>\n</blockquote>\n<p>學習前端好一陣子，終於能夠開始寫點小作品了的時候，我有時會體驗到進入心流的感覺。那是一種專心致志、全神貫注、腦子非常清楚、全然投入的感覺，有好幾天 coding 到晚上 11、12 點，睡覺夢到某個問題的解法，清晨 4、5 點就清醒，然後再也睡不著，只想繼續寫。</p>\n<p>最近在開發一個案子，也有滿高的機率開啟心流。那種感覺，真的只有一個爽字能形容！</p>\n<p>但我逐漸認知到，這種時刻通常都是出現在「產出」，而非「吸收」的時候，也因此要避免自己只想寫不想學，這樣只會把自己榨乾而已。該累積養分的時候還是得乖乖學習的唷。</p>\n<hr>\n<h2 id=\"確定要來真的了嗎？轉職的轉捩點\"><a href=\"#確定要來真的了嗎？轉職的轉捩點\" class=\"headerlink\" title=\"確定要來真的了嗎？轉職的轉捩點\"></a>確定要來真的了嗎？轉職的轉捩點</h2><blockquote>\n<p>你是何時開始認真看待自己要轉職到一個完全陌生的領域這件事呢？</p>\n</blockquote>\n<p>大約是在 2019 &#x2F; 4 月左右，當時覺得對於 HTML &#x2F; CSS 已經有基礎的了解， CodeCademy、FreeCodeCamp 上的免費教程也已經做到有點索然無味了，想要來認真加深 JavaScript 能力，一方面也想著：「是不是該來認真考慮轉職的事了？」</p>\n<h3 id=\"果斷辭職\"><a href=\"#果斷辭職\" class=\"headerlink\" title=\"果斷辭職\"></a>果斷辭職</h3><blockquote>\n<p>有時候，純粹是一股衝動。</p>\n</blockquote>\n<p>搜尋了一陣子 JS 課程後，我報了台大資訊系統的一門實體課，叫做「網頁前端實務 JavaScript」，教的內容完全符合我的需求，既超出我的程度，又不會到完全不懂，但需要很努力才能跟上腳步的那種。</p>\n<p>我原本一直是用業餘的時間來學程式，但漸漸地發現，這樣下去我的學習成果不會好。既然已經決定要轉職了，那就必須投入 100% 努力才行。因此在 2019 &#x2F; 5 月中，我果斷離開原本的工作，專心在學習程式、準備轉職上。</p>\n<h3 id=\"久到令人心慌的空窗期\"><a href=\"#久到令人心慌的空窗期\" class=\"headerlink\" title=\"久到令人心慌的空窗期\"></a>久到令人心慌的空窗期</h3><blockquote>\n<p>前途一片迷茫。何時才能結束？</p>\n</blockquote>\n<p>前前後後空窗了 4 個半月，是我人生中目前為止空窗最久的一段時間了。</p>\n<p>這段期間，每天大部分的時間都花在學習程式上。當然，「假如失敗」的念頭，三不五時就會冒出來。每當這種時候，轉移注意力、貨回憶初衷，都是很有效的辦法，能將自己拉回正軌。</p>\n<p>當你專注在一件事情上的時候，全宇宙都會來推你一把！就是在這個時期，我參加了幾個前端 Facebook 社團，而剛好看到了 Luka 大大創立的 <a class=\"link\"   href=\"https://www.facebook.com/CodeShiba/\" >程式柴 Codeshiba<i class=\"fas fa-external-link-alt\"></i></a> 專頁，當時正準備開啟一連串的職涯領航計畫，衝著免費我就報名了。</p>\n<p>發現有一群人跟自己在同樣的道路上掙扎前進，那種感覺是無可比擬的，就好像原本是獨自一人在跑馬拉松，突然發現其實身邊全是夥伴的感覺。而且有個 mentor 領跑，更能夠幫助自己看清方向，去除掉不必要的、浪費時間的事，更有效率地專注在達成目標上。</p>\n<p>CodeShiba 社團真的給予我很大的助力，跪拜 Luka 大大。</p>\n<blockquote>\n<p>想加入需要通過審核，請自行私訊程式柴粉絲頁</p>\n<ul>\n<li>粉絲頁： <a class=\"link\"   href=\"https://www.facebook.com/CodeShiba/\" >程式柴 Codeshiba<i class=\"fas fa-external-link-alt\"></i></a> </li>\n<li>社團： <a class=\"link\"   href=\"https://www.facebook.com/groups/1723508807794929/\" >CodeShiba 學員專區<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"跌跌撞撞的面試\"><a href=\"#跌跌撞撞的面試\" class=\"headerlink\" title=\"跌跌撞撞的面試\"></a>跌跌撞撞的面試</h2><h3 id=\"面試才知道自己哪裡不足\"><a href=\"#面試才知道自己哪裡不足\" class=\"headerlink\" title=\"面試才知道自己哪裡不足\"></a>面試才知道自己哪裡不足</h3><blockquote>\n<p>你以為公司為什麼過這麼久都不通知你？</p>\n</blockquote>\n<p>這幾個月都是在 Udemy &#x2F; Youtube 上找課程、影片學習，偶爾有靈感的時候，就會自己寫個小作品（寫的時候很有成就感，寫完回頭看才覺得怎麼那麼醜，哈哈哈）。</p>\n<p>差不多七月中，開始有公司會發面試邀請過來，但面試完幾乎都沒有下文。我心裡很清楚是因為程度不足被刷掉，所以每一次的面試，我都會盡量去記被問到答不出來、或答得卡卡的部分，那些就是我該補強的地方（結果多到數不清…）。</p>\n<p>以下是每次面試都會被問到的部分：</p>\n<ul>\n<li>git 能力</li>\n<li>CSS 切版（Float、Flexbox、Grid）</li>\n<li>CSS 權重觀念</li>\n<li>JS DOM／陣列 操作</li>\n<li>JS 串接 API、Ajax、ES6</li>\n</ul>\n<p>除了自己去面試，也可以多多參考他人的履歷，Luka 相當熟知怎樣的履歷看起來會吸引人而且程度很高，被他調整履歷了之後不久，我就找到目前的工作了（當然，還是有一些運氣成份，幸好面試主管實際問到的問題我答得出來）。實在是可喜可賀！</p>\n<blockquote>\n<p><a class=\"link\"   href=\"https://www.cakeresume.com/s--nFb6N436eKp-1VNtf_cmSg--/gk-wang\" >GK 的履歷，看看笑笑就好<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<hr>\n<h2 id=\"Road-to-Front-End-Developer-Never-Ends\"><a href=\"#Road-to-Front-End-Developer-Never-Ends\" class=\"headerlink\" title=\"Road to Front End Developer Never Ends\"></a>Road to Front End Developer Never Ends</h2><blockquote>\n<p>這是一條沒有盡頭的路。</p>\n</blockquote>\n<p>我畢竟還是個全然的跨領域轉職者，雖然已經有一些基礎了，但比起原本就在這一行裡打滾的前輩們，根本完全不夠。接下來我為自己設定的方向如下：</p>\n<ul>\n<li>在公司裡能學到的<ul>\n<li>業界協作流程（git）</li>\n<li>與 server 互動（串資料）</li>\n<li>JS 框架（Angular）</li>\n</ul>\n</li>\n<li>自行練習<ul>\n<li>CSS（Materialize、Bulma、BootStrap 等套件）</li>\n<li>jQuery（沒錯！我還不會 jQuery，通通都是寫原生）</li>\n<li>補足瀏覽器、http 協定等相關知識</li>\n<li>加深 JavaScript 觀念</li>\n<li>學習 Node.js</li>\n</ul>\n</li>\n</ul>\n<p>原本的目標是兩年內要能夠自己寫含前後端的部落格，不過我現在期望自己能夠盡快學會跟 App 有關的能力，因為我有一些有趣的遊戲跟應用的點子，卻寫不出來，很痛苦啊。</p>\n<p>對我來說，轉職只是個中繼點，通過這個 check point，不代表已經到終點了，還是必須繼續朝目標前進。終極目標是什麼？其實我也不曉得，就且戰且走吧。</p>\n<p>總而言之，祝各位在轉職的路上，穩定踏實地邁進！</p>"},{"title":"自我管理心法（一）：為什麼要自我管理？","draft":true,"date":"2020-01-26T10:27:41.000Z","_content":"\n你有沒有問過自己，活這輩子，你的目標是什麼呢？你想活出怎樣的生活？想得到什麼樣的成就？你是否足夠了解自己，並且妥善管理自己的生活，讓生活的一切都在自己的掌控中？\n\n<!--more-->\n\n## 1. 為什麼要做自我管理？\n\n> 這輩子，你想怎麼活？\n\n我是覺得，人活在世上一輩子，其實沒什麼特別的目的，死掉之後也不會有任何意義，重要的是在自我的意識能感知到的這段期間內，如何活著。\n\n然而，正在看這篇文章的你，與我對於「怎麼活」的解讀是不可能完全一樣的，這世界上也不會有兩個人對於怎麼活有一模一樣的答案。但是，這並不代表就不需要去思考這件事。相反地，我認為人生前半段，主要是在尋找自己「想要怎麼活？」這問題的解答。\n\n如果你還不曉得自己想要怎麼活，那我會建議你先找到答案。當然，隨著歷練增長，這個答案可能會變動，這是很正常的。\n\n對我來說，要能活得盡興，需要達到以下幾個目標：\n* 找到能樂在其中的工作\n* 擁有健康的身體\n* 需要金錢的時候不會覺得拮据\n\n達成了這些目標之後，基本上就算活得很盡興了，至於有沒有衍生出其他的目標，我覺得都可以。畢竟，本來就沒人規定這輩子一定要達成什麼大成就，對吧？\n\n---\n\n## 2. 需要管理的項目\n\n這是我的目標：\n* 找到能樂在其中的工作\n* 擁有健康的身體\n* 需要金錢的時候不會覺得拮据\n\n簡化一下，就變成：\n* 工作\n* 運動\n* 金錢\n\n那麼，接下來就來看看，這三個項目要如何管理吧。\n\n### 2.1 如何管理工作\n\n一講到工作，有人充滿熱情，有人卻意興闌珊。我認為其實每個人都有機會找到最適合自己、能讓自己充滿激情的工作。為了尋找這樣的工作，你對每一份工作，都應該要設定目標，例如：這份工作的目標是「學習資料搜集與分析的能力」、或為了「累積 30 萬資金」，達成目標後，其實就可以朝下個階段邁進，很快地就能累積在工作上的成就。\n\n每一份工作都有值得吸收、學習的地方，若你對於現在的工作感到痛苦，分析看看是什麼原因？如果會造成你偏離目標，就想辦法調整；如果已經沒東西可以學了，就趕緊離開那份工作！\n\n管理自己的工作是很重要的。如果可以，用架構化的方式來管理，能更有效率。以下提供幾個我目前在使用的方法給你參考。\n\n|方法|內容|\n|-|-|\n|事先規劃|這方法又分為每日、每週、每月、每季。在時段開始時（例如一天的開頭，花個一小時做這件事），列出每個時段預計完成的事項，在時段結束時檢視，以有效掌握自己的工作能力。才不會每天工作都像無頭蒼蠅撞來撞去，覺得還有很多事沒做。|\n|待辦清單|這是最基本的方法，用條列式清單列出需要完成的任務。可以搭配事先規劃來使用。|\n|工時追蹤|基本上就是工作日誌。藉由詳細列出自己一天花了多少時間在做哪些事，來掌握自己的 loading。|\n\n對於管理工作，因為太多可以學，我不打算在這裡深談。之後再開其他篇文章來分享關於這塊的心得吧。\n\n### 2.2 如何管理運動\n\n擁有健康的身體、充足（或有效）的睡眠，才不會每天都病厭厭、全身無力或沒精神，也更能好好地面對一天的挑戰。\n\n因為運動就是興趣，所以我沒有太去想如何管理運動，~~基本上多運動就對了~~。還是稍微分享一下「如何開始運動」好了。\n\n首先想想，你為什麼會覺得很懶，不想運動？我認為這是因為一般人對於運動的標準愈來愈高，搞得好像不做一些很 hardcore 的運動就會被笑怎麼那麼弱，會覺得運動是很累人的事，上班就已經耗掉一整天的精力了，下班哪還有體力去運動，只想耍廢。\n\n但是，真的要很累、很喘才叫有運動到嗎？回頭想想，運動的本質是什麼？是促進血液循環、新陳代謝、消耗卡路里吧。走路能不能做到這些事？一樣可以啊！\n\n每天下班多繞一條巷子才回到家，算不算有運動到？以我的觀點來看，是有的哦！千萬別一下子把門檻定得太高，這樣只會害自己想打消念頭。所謂千里之行始於足下，一次一點點、一次一點點，當你發現的時候，可能就已經離不開運動的習慣了。\n\n~~講一大堆，還是沒說我如何管理運動，阿就真的沒有啊。~~\n\n\n### 2.3 如何管理金錢\n\n這是每個人的課題，錢真的不好賺，但非常容易花掉。如何有效管理金錢？我認為還是腳踏實地最實在。\n\n|方法|內容|\n|-|-|\n|預算控制|列出每個月基本開銷，並在月底檢視是否有超支的狀況，並做調整。|\n|儲蓄|每月一拿到薪資，就先撥一部分存進儲蓄戶頭。這真的很重要！絕大部分的金錢都來自儲蓄，千萬別想著一蹴可幾的錢財，那通常都會讓你血本無歸。|\n|投資自己|每個月撥一些花費用在買課程、學習技能、取得新體驗上。讓自己的內在愈來愈豐富。|\n|控制慾望|想吃好吃的嗎？想買新衣服？給自己設定一個目標，達成了就可以獲得獎勵，讓身體習慣這件事。|\n\n\n> 這邊推薦一個很棒的 youtube 頻道：[艾爾文](https://www.youtube.com/user/17richfriend)，談了許多自我管理相關的話題，也有很多閱讀心得分享，相當實用！\n\n---\n\n## 3. 總結\n\n為了活得盡興，我想對自己的生活做妥善地管理，分配金錢的使用、分配體力的使用、為了達到目標而學習技能，等等。在管理自己生活的過程中，也不斷產生成就感，成就感帶來的是自信與自尊，讓我能夠活得更盡興。\n\n如果你也對自我管理感興趣，歡迎來跟我聊聊！","source":"_posts/self-manage.md","raw":"---\ntitle: 自我管理心法（一）：為什麼要自我管理？\ndraft: true\ndate: 2020-01-26 18:27:41\ntags: [自我管理]\n---\n\n你有沒有問過自己，活這輩子，你的目標是什麼呢？你想活出怎樣的生活？想得到什麼樣的成就？你是否足夠了解自己，並且妥善管理自己的生活，讓生活的一切都在自己的掌控中？\n\n<!--more-->\n\n## 1. 為什麼要做自我管理？\n\n> 這輩子，你想怎麼活？\n\n我是覺得，人活在世上一輩子，其實沒什麼特別的目的，死掉之後也不會有任何意義，重要的是在自我的意識能感知到的這段期間內，如何活著。\n\n然而，正在看這篇文章的你，與我對於「怎麼活」的解讀是不可能完全一樣的，這世界上也不會有兩個人對於怎麼活有一模一樣的答案。但是，這並不代表就不需要去思考這件事。相反地，我認為人生前半段，主要是在尋找自己「想要怎麼活？」這問題的解答。\n\n如果你還不曉得自己想要怎麼活，那我會建議你先找到答案。當然，隨著歷練增長，這個答案可能會變動，這是很正常的。\n\n對我來說，要能活得盡興，需要達到以下幾個目標：\n* 找到能樂在其中的工作\n* 擁有健康的身體\n* 需要金錢的時候不會覺得拮据\n\n達成了這些目標之後，基本上就算活得很盡興了，至於有沒有衍生出其他的目標，我覺得都可以。畢竟，本來就沒人規定這輩子一定要達成什麼大成就，對吧？\n\n---\n\n## 2. 需要管理的項目\n\n這是我的目標：\n* 找到能樂在其中的工作\n* 擁有健康的身體\n* 需要金錢的時候不會覺得拮据\n\n簡化一下，就變成：\n* 工作\n* 運動\n* 金錢\n\n那麼，接下來就來看看，這三個項目要如何管理吧。\n\n### 2.1 如何管理工作\n\n一講到工作，有人充滿熱情，有人卻意興闌珊。我認為其實每個人都有機會找到最適合自己、能讓自己充滿激情的工作。為了尋找這樣的工作，你對每一份工作，都應該要設定目標，例如：這份工作的目標是「學習資料搜集與分析的能力」、或為了「累積 30 萬資金」，達成目標後，其實就可以朝下個階段邁進，很快地就能累積在工作上的成就。\n\n每一份工作都有值得吸收、學習的地方，若你對於現在的工作感到痛苦，分析看看是什麼原因？如果會造成你偏離目標，就想辦法調整；如果已經沒東西可以學了，就趕緊離開那份工作！\n\n管理自己的工作是很重要的。如果可以，用架構化的方式來管理，能更有效率。以下提供幾個我目前在使用的方法給你參考。\n\n|方法|內容|\n|-|-|\n|事先規劃|這方法又分為每日、每週、每月、每季。在時段開始時（例如一天的開頭，花個一小時做這件事），列出每個時段預計完成的事項，在時段結束時檢視，以有效掌握自己的工作能力。才不會每天工作都像無頭蒼蠅撞來撞去，覺得還有很多事沒做。|\n|待辦清單|這是最基本的方法，用條列式清單列出需要完成的任務。可以搭配事先規劃來使用。|\n|工時追蹤|基本上就是工作日誌。藉由詳細列出自己一天花了多少時間在做哪些事，來掌握自己的 loading。|\n\n對於管理工作，因為太多可以學，我不打算在這裡深談。之後再開其他篇文章來分享關於這塊的心得吧。\n\n### 2.2 如何管理運動\n\n擁有健康的身體、充足（或有效）的睡眠，才不會每天都病厭厭、全身無力或沒精神，也更能好好地面對一天的挑戰。\n\n因為運動就是興趣，所以我沒有太去想如何管理運動，~~基本上多運動就對了~~。還是稍微分享一下「如何開始運動」好了。\n\n首先想想，你為什麼會覺得很懶，不想運動？我認為這是因為一般人對於運動的標準愈來愈高，搞得好像不做一些很 hardcore 的運動就會被笑怎麼那麼弱，會覺得運動是很累人的事，上班就已經耗掉一整天的精力了，下班哪還有體力去運動，只想耍廢。\n\n但是，真的要很累、很喘才叫有運動到嗎？回頭想想，運動的本質是什麼？是促進血液循環、新陳代謝、消耗卡路里吧。走路能不能做到這些事？一樣可以啊！\n\n每天下班多繞一條巷子才回到家，算不算有運動到？以我的觀點來看，是有的哦！千萬別一下子把門檻定得太高，這樣只會害自己想打消念頭。所謂千里之行始於足下，一次一點點、一次一點點，當你發現的時候，可能就已經離不開運動的習慣了。\n\n~~講一大堆，還是沒說我如何管理運動，阿就真的沒有啊。~~\n\n\n### 2.3 如何管理金錢\n\n這是每個人的課題，錢真的不好賺，但非常容易花掉。如何有效管理金錢？我認為還是腳踏實地最實在。\n\n|方法|內容|\n|-|-|\n|預算控制|列出每個月基本開銷，並在月底檢視是否有超支的狀況，並做調整。|\n|儲蓄|每月一拿到薪資，就先撥一部分存進儲蓄戶頭。這真的很重要！絕大部分的金錢都來自儲蓄，千萬別想著一蹴可幾的錢財，那通常都會讓你血本無歸。|\n|投資自己|每個月撥一些花費用在買課程、學習技能、取得新體驗上。讓自己的內在愈來愈豐富。|\n|控制慾望|想吃好吃的嗎？想買新衣服？給自己設定一個目標，達成了就可以獲得獎勵，讓身體習慣這件事。|\n\n\n> 這邊推薦一個很棒的 youtube 頻道：[艾爾文](https://www.youtube.com/user/17richfriend)，談了許多自我管理相關的話題，也有很多閱讀心得分享，相當實用！\n\n---\n\n## 3. 總結\n\n為了活得盡興，我想對自己的生活做妥善地管理，分配金錢的使用、分配體力的使用、為了達到目標而學習技能，等等。在管理自己生活的過程中，也不斷產生成就感，成就感帶來的是自信與自尊，讓我能夠活得更盡興。\n\n如果你也對自我管理感興趣，歡迎來跟我聊聊！","slug":"self-manage","published":1,"updated":"2022-03-12T12:58:21.578Z","_id":"cl0nusu0m002hz6usham694e4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>你有沒有問過自己，活這輩子，你的目標是什麼呢？你想活出怎樣的生活？想得到什麼樣的成就？你是否足夠了解自己，並且妥善管理自己的生活，讓生活的一切都在自己的掌控中？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1-為什麼要做自我管理？\"><a href=\"#1-為什麼要做自我管理？\" class=\"headerlink\" title=\"1. 為什麼要做自我管理？\"></a>1. 為什麼要做自我管理？</h2><blockquote>\n<p>這輩子，你想怎麼活？</p>\n</blockquote>\n<p>我是覺得，人活在世上一輩子，其實沒什麼特別的目的，死掉之後也不會有任何意義，重要的是在自我的意識能感知到的這段期間內，如何活著。</p>\n<p>然而，正在看這篇文章的你，與我對於「怎麼活」的解讀是不可能完全一樣的，這世界上也不會有兩個人對於怎麼活有一模一樣的答案。但是，這並不代表就不需要去思考這件事。相反地，我認為人生前半段，主要是在尋找自己「想要怎麼活？」這問題的解答。</p>\n<p>如果你還不曉得自己想要怎麼活，那我會建議你先找到答案。當然，隨著歷練增長，這個答案可能會變動，這是很正常的。</p>\n<p>對我來說，要能活得盡興，需要達到以下幾個目標：</p>\n<ul>\n<li>找到能樂在其中的工作</li>\n<li>擁有健康的身體</li>\n<li>需要金錢的時候不會覺得拮据</li>\n</ul>\n<p>達成了這些目標之後，基本上就算活得很盡興了，至於有沒有衍生出其他的目標，我覺得都可以。畢竟，本來就沒人規定這輩子一定要達成什麼大成就，對吧？</p>\n<hr>\n<h2 id=\"2-需要管理的項目\"><a href=\"#2-需要管理的項目\" class=\"headerlink\" title=\"2. 需要管理的項目\"></a>2. 需要管理的項目</h2><p>這是我的目標：</p>\n<ul>\n<li>找到能樂在其中的工作</li>\n<li>擁有健康的身體</li>\n<li>需要金錢的時候不會覺得拮据</li>\n</ul>\n<p>簡化一下，就變成：</p>\n<ul>\n<li>工作</li>\n<li>運動</li>\n<li>金錢</li>\n</ul>\n<p>那麼，接下來就來看看，這三個項目要如何管理吧。</p>\n<h3 id=\"2-1-如何管理工作\"><a href=\"#2-1-如何管理工作\" class=\"headerlink\" title=\"2.1 如何管理工作\"></a>2.1 如何管理工作</h3><p>一講到工作，有人充滿熱情，有人卻意興闌珊。我認為其實每個人都有機會找到最適合自己、能讓自己充滿激情的工作。為了尋找這樣的工作，你對每一份工作，都應該要設定目標，例如：這份工作的目標是「學習資料搜集與分析的能力」、或為了「累積 30 萬資金」，達成目標後，其實就可以朝下個階段邁進，很快地就能累積在工作上的成就。</p>\n<p>每一份工作都有值得吸收、學習的地方，若你對於現在的工作感到痛苦，分析看看是什麼原因？如果會造成你偏離目標，就想辦法調整；如果已經沒東西可以學了，就趕緊離開那份工作！</p>\n<p>管理自己的工作是很重要的。如果可以，用架構化的方式來管理，能更有效率。以下提供幾個我目前在使用的方法給你參考。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>內容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事先規劃</td>\n<td>這方法又分為每日、每週、每月、每季。在時段開始時（例如一天的開頭，花個一小時做這件事），列出每個時段預計完成的事項，在時段結束時檢視，以有效掌握自己的工作能力。才不會每天工作都像無頭蒼蠅撞來撞去，覺得還有很多事沒做。</td>\n</tr>\n<tr>\n<td>待辦清單</td>\n<td>這是最基本的方法，用條列式清單列出需要完成的任務。可以搭配事先規劃來使用。</td>\n</tr>\n<tr>\n<td>工時追蹤</td>\n<td>基本上就是工作日誌。藉由詳細列出自己一天花了多少時間在做哪些事，來掌握自己的 loading。</td>\n</tr>\n</tbody></table>\n<p>對於管理工作，因為太多可以學，我不打算在這裡深談。之後再開其他篇文章來分享關於這塊的心得吧。</p>\n<h3 id=\"2-2-如何管理運動\"><a href=\"#2-2-如何管理運動\" class=\"headerlink\" title=\"2.2 如何管理運動\"></a>2.2 如何管理運動</h3><p>擁有健康的身體、充足（或有效）的睡眠，才不會每天都病厭厭、全身無力或沒精神，也更能好好地面對一天的挑戰。</p>\n<p>因為運動就是興趣，所以我沒有太去想如何管理運動，<del>基本上多運動就對了</del>。還是稍微分享一下「如何開始運動」好了。</p>\n<p>首先想想，你為什麼會覺得很懶，不想運動？我認為這是因為一般人對於運動的標準愈來愈高，搞得好像不做一些很 hardcore 的運動就會被笑怎麼那麼弱，會覺得運動是很累人的事，上班就已經耗掉一整天的精力了，下班哪還有體力去運動，只想耍廢。</p>\n<p>但是，真的要很累、很喘才叫有運動到嗎？回頭想想，運動的本質是什麼？是促進血液循環、新陳代謝、消耗卡路里吧。走路能不能做到這些事？一樣可以啊！</p>\n<p>每天下班多繞一條巷子才回到家，算不算有運動到？以我的觀點來看，是有的哦！千萬別一下子把門檻定得太高，這樣只會害自己想打消念頭。所謂千里之行始於足下，一次一點點、一次一點點，當你發現的時候，可能就已經離不開運動的習慣了。</p>\n<p><del>講一大堆，還是沒說我如何管理運動，阿就真的沒有啊。</del></p>\n<h3 id=\"2-3-如何管理金錢\"><a href=\"#2-3-如何管理金錢\" class=\"headerlink\" title=\"2.3 如何管理金錢\"></a>2.3 如何管理金錢</h3><p>這是每個人的課題，錢真的不好賺，但非常容易花掉。如何有效管理金錢？我認為還是腳踏實地最實在。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>內容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>預算控制</td>\n<td>列出每個月基本開銷，並在月底檢視是否有超支的狀況，並做調整。</td>\n</tr>\n<tr>\n<td>儲蓄</td>\n<td>每月一拿到薪資，就先撥一部分存進儲蓄戶頭。這真的很重要！絕大部分的金錢都來自儲蓄，千萬別想著一蹴可幾的錢財，那通常都會讓你血本無歸。</td>\n</tr>\n<tr>\n<td>投資自己</td>\n<td>每個月撥一些花費用在買課程、學習技能、取得新體驗上。讓自己的內在愈來愈豐富。</td>\n</tr>\n<tr>\n<td>控制慾望</td>\n<td>想吃好吃的嗎？想買新衣服？給自己設定一個目標，達成了就可以獲得獎勵，讓身體習慣這件事。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>這邊推薦一個很棒的 youtube 頻道：<a class=\"link\"   href=\"https://www.youtube.com/user/17richfriend\" >艾爾文<i class=\"fas fa-external-link-alt\"></i></a>，談了許多自我管理相關的話題，也有很多閱讀心得分享，相當實用！</p>\n</blockquote>\n<hr>\n<h2 id=\"3-總結\"><a href=\"#3-總結\" class=\"headerlink\" title=\"3. 總結\"></a>3. 總結</h2><p>為了活得盡興，我想對自己的生活做妥善地管理，分配金錢的使用、分配體力的使用、為了達到目標而學習技能，等等。在管理自己生活的過程中，也不斷產生成就感，成就感帶來的是自信與自尊，讓我能夠活得更盡興。</p>\n<p>如果你也對自我管理感興趣，歡迎來跟我聊聊！</p>\n","site":{"data":{}},"excerpt":"<p>你有沒有問過自己，活這輩子，你的目標是什麼呢？你想活出怎樣的生活？想得到什麼樣的成就？你是否足夠了解自己，並且妥善管理自己的生活，讓生活的一切都在自己的掌控中？</p>","more":"<h2 id=\"1-為什麼要做自我管理？\"><a href=\"#1-為什麼要做自我管理？\" class=\"headerlink\" title=\"1. 為什麼要做自我管理？\"></a>1. 為什麼要做自我管理？</h2><blockquote>\n<p>這輩子，你想怎麼活？</p>\n</blockquote>\n<p>我是覺得，人活在世上一輩子，其實沒什麼特別的目的，死掉之後也不會有任何意義，重要的是在自我的意識能感知到的這段期間內，如何活著。</p>\n<p>然而，正在看這篇文章的你，與我對於「怎麼活」的解讀是不可能完全一樣的，這世界上也不會有兩個人對於怎麼活有一模一樣的答案。但是，這並不代表就不需要去思考這件事。相反地，我認為人生前半段，主要是在尋找自己「想要怎麼活？」這問題的解答。</p>\n<p>如果你還不曉得自己想要怎麼活，那我會建議你先找到答案。當然，隨著歷練增長，這個答案可能會變動，這是很正常的。</p>\n<p>對我來說，要能活得盡興，需要達到以下幾個目標：</p>\n<ul>\n<li>找到能樂在其中的工作</li>\n<li>擁有健康的身體</li>\n<li>需要金錢的時候不會覺得拮据</li>\n</ul>\n<p>達成了這些目標之後，基本上就算活得很盡興了，至於有沒有衍生出其他的目標，我覺得都可以。畢竟，本來就沒人規定這輩子一定要達成什麼大成就，對吧？</p>\n<hr>\n<h2 id=\"2-需要管理的項目\"><a href=\"#2-需要管理的項目\" class=\"headerlink\" title=\"2. 需要管理的項目\"></a>2. 需要管理的項目</h2><p>這是我的目標：</p>\n<ul>\n<li>找到能樂在其中的工作</li>\n<li>擁有健康的身體</li>\n<li>需要金錢的時候不會覺得拮据</li>\n</ul>\n<p>簡化一下，就變成：</p>\n<ul>\n<li>工作</li>\n<li>運動</li>\n<li>金錢</li>\n</ul>\n<p>那麼，接下來就來看看，這三個項目要如何管理吧。</p>\n<h3 id=\"2-1-如何管理工作\"><a href=\"#2-1-如何管理工作\" class=\"headerlink\" title=\"2.1 如何管理工作\"></a>2.1 如何管理工作</h3><p>一講到工作，有人充滿熱情，有人卻意興闌珊。我認為其實每個人都有機會找到最適合自己、能讓自己充滿激情的工作。為了尋找這樣的工作，你對每一份工作，都應該要設定目標，例如：這份工作的目標是「學習資料搜集與分析的能力」、或為了「累積 30 萬資金」，達成目標後，其實就可以朝下個階段邁進，很快地就能累積在工作上的成就。</p>\n<p>每一份工作都有值得吸收、學習的地方，若你對於現在的工作感到痛苦，分析看看是什麼原因？如果會造成你偏離目標，就想辦法調整；如果已經沒東西可以學了，就趕緊離開那份工作！</p>\n<p>管理自己的工作是很重要的。如果可以，用架構化的方式來管理，能更有效率。以下提供幾個我目前在使用的方法給你參考。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>內容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>事先規劃</td>\n<td>這方法又分為每日、每週、每月、每季。在時段開始時（例如一天的開頭，花個一小時做這件事），列出每個時段預計完成的事項，在時段結束時檢視，以有效掌握自己的工作能力。才不會每天工作都像無頭蒼蠅撞來撞去，覺得還有很多事沒做。</td>\n</tr>\n<tr>\n<td>待辦清單</td>\n<td>這是最基本的方法，用條列式清單列出需要完成的任務。可以搭配事先規劃來使用。</td>\n</tr>\n<tr>\n<td>工時追蹤</td>\n<td>基本上就是工作日誌。藉由詳細列出自己一天花了多少時間在做哪些事，來掌握自己的 loading。</td>\n</tr>\n</tbody></table>\n<p>對於管理工作，因為太多可以學，我不打算在這裡深談。之後再開其他篇文章來分享關於這塊的心得吧。</p>\n<h3 id=\"2-2-如何管理運動\"><a href=\"#2-2-如何管理運動\" class=\"headerlink\" title=\"2.2 如何管理運動\"></a>2.2 如何管理運動</h3><p>擁有健康的身體、充足（或有效）的睡眠，才不會每天都病厭厭、全身無力或沒精神，也更能好好地面對一天的挑戰。</p>\n<p>因為運動就是興趣，所以我沒有太去想如何管理運動，<del>基本上多運動就對了</del>。還是稍微分享一下「如何開始運動」好了。</p>\n<p>首先想想，你為什麼會覺得很懶，不想運動？我認為這是因為一般人對於運動的標準愈來愈高，搞得好像不做一些很 hardcore 的運動就會被笑怎麼那麼弱，會覺得運動是很累人的事，上班就已經耗掉一整天的精力了，下班哪還有體力去運動，只想耍廢。</p>\n<p>但是，真的要很累、很喘才叫有運動到嗎？回頭想想，運動的本質是什麼？是促進血液循環、新陳代謝、消耗卡路里吧。走路能不能做到這些事？一樣可以啊！</p>\n<p>每天下班多繞一條巷子才回到家，算不算有運動到？以我的觀點來看，是有的哦！千萬別一下子把門檻定得太高，這樣只會害自己想打消念頭。所謂千里之行始於足下，一次一點點、一次一點點，當你發現的時候，可能就已經離不開運動的習慣了。</p>\n<p><del>講一大堆，還是沒說我如何管理運動，阿就真的沒有啊。</del></p>\n<h3 id=\"2-3-如何管理金錢\"><a href=\"#2-3-如何管理金錢\" class=\"headerlink\" title=\"2.3 如何管理金錢\"></a>2.3 如何管理金錢</h3><p>這是每個人的課題，錢真的不好賺，但非常容易花掉。如何有效管理金錢？我認為還是腳踏實地最實在。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>內容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>預算控制</td>\n<td>列出每個月基本開銷，並在月底檢視是否有超支的狀況，並做調整。</td>\n</tr>\n<tr>\n<td>儲蓄</td>\n<td>每月一拿到薪資，就先撥一部分存進儲蓄戶頭。這真的很重要！絕大部分的金錢都來自儲蓄，千萬別想著一蹴可幾的錢財，那通常都會讓你血本無歸。</td>\n</tr>\n<tr>\n<td>投資自己</td>\n<td>每個月撥一些花費用在買課程、學習技能、取得新體驗上。讓自己的內在愈來愈豐富。</td>\n</tr>\n<tr>\n<td>控制慾望</td>\n<td>想吃好吃的嗎？想買新衣服？給自己設定一個目標，達成了就可以獲得獎勵，讓身體習慣這件事。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>這邊推薦一個很棒的 youtube 頻道：<a class=\"link\"   href=\"https://www.youtube.com/user/17richfriend\" >艾爾文<i class=\"fas fa-external-link-alt\"></i></a>，談了許多自我管理相關的話題，也有很多閱讀心得分享，相當實用！</p>\n</blockquote>\n<hr>\n<h2 id=\"3-總結\"><a href=\"#3-總結\" class=\"headerlink\" title=\"3. 總結\"></a>3. 總結</h2><p>為了活得盡興，我想對自己的生活做妥善地管理，分配金錢的使用、分配體力的使用、為了達到目標而學習技能，等等。在管理自己生活的過程中，也不斷產生成就感，成就感帶來的是自信與自尊，讓我能夠活得更盡興。</p>\n<p>如果你也對自我管理感興趣，歡迎來跟我聊聊！</p>"},{"title":"前後端＆資料庫系統建置心得","date":"2021-03-19T14:00:35.000Z","_content":"\n機緣巧合下，我接到了個任務，需要把一套系統在一個新建的 Server 上架起來。盤點手上資源，是幾套程式碼，還有前人遺留在各 Server 的設定檔。我是剛轉職一年的前端工程師，對前端領域可說是才剛有一些心得，現在就來了這個任務...好吧！解就解，誰怕誰（~~反正有 Stack Overflow~~）！\n\n<!--more-->\n\n---\n## 系統架構\n要從無到有將系統建起來，首先需要了解系統的架構。廢話不多說，先上圖。\n\n![](https://i.imgur.com/0RqkfVN.png)\n\n這個系統是長成這個鬼樣子的，至於為什麼要用這麼多種語言設計，不要問我，去問前人。總之這系統上的各套服務，原本是架在不同 Server 的，而我這次要做的事情就是將它們全部搬到同個 Server 運行。\n\n經過一陣子的研究後，要達成目標，需要下列技術：\n1. Linux 基本操作\n1. 資料庫安裝（MariaDB & MongoDB）\n2. Node.js build & deploy\n3. Golang build & deploy\n4. Angular build & deploy\n5. Service config（systemd）\n6. Web Server config（httpd）\n\n> 補充一下困難程度，在開始做這件事前，我會的只有 5 而已...\n\n---\n## 資料庫建置\n好！那麼首先要嘗試的，就是資料庫的安裝。\n\n由於對這兩套資料庫完全不了解，我先在本機（Mac）試著用 `homebrew` 安裝了幾次。現在回過頭看覺得挺好笑的，因為後來才知道在 Mac 安裝跟在 `Linux` 安裝，完全是兩回事...\n\n### MariaDB\n* MacOS 安裝：https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/\n* Linux 安裝：https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/\n\n\n### MongoDB\n* MacOS 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\n* Linux 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n\n> 目標伺服器是 `Linux CentOS 7`，也是因此契機才稍微去瞭解了下 `Linux` 作業系統，才知道原來有非常多版本。有興趣知道更多可參考這篇：[黑暗執行緒 - 我的 Linux 作業系統考察](https://blog.darkthread.net/blog/linux-server-os-survey/)\n\n安裝了資料庫後才是真正的開始，會遇到 root 密碼無法登入問題、安全性設定問題等怪事，這部分就不細說了，總之 Stack Overflow 是你我的好朋友。\n\n---\n## Node.js 專案部署\n完成資料庫的安裝後，接著是 `Form Service`，因為這套要先運行起來，`Main Service` 才能運行。由於在前端打滾了一年，多少還是懂一點 NPM，因此只要稍微讀一下 `Package.json`，就大概知道操作指令有哪些了。\n\n接著，做下面這些事情：\n* 將專案資料夾複製到伺服器的專案路徑下\n* 建立服務的設定檔（/lib/systemd/system/<service_name>.service）\n* 在專案路徑執行 `npm install` 以下載依賴套件\n* 啟動服務：`systemctl start <service_name>.service`\n* 檢查服務：`systemctl status <service_name>.service`\n* 開放 tcp 連線 port：`firewall-cmd --add-port=<port_number>/tcp`\n\n> 在服務設定檔中會指定專案路徑，以及在這個路徑底下要 `Linux` 執行什麼指令，因此熟悉的 `npm run start` 就會寫在這裡。\n\n---\n## Golang 專案部署\n在測試過 `Form Service` 正常運行後，就可以來接著架 `Main Service` 了。由於我完全不會 `Golang`，因此花了一些時間從頭學習，也整理出幾個 `Go` 常用的套件，找了一些 tutorial 來做。\n\n`Golang` 常用套件：\n* `Gin`：http server\n* `Gorm`：MariaDB 操作\n* `Mongo`：MongoDB 操作\n* `Cron`：排程設定\n* `Cobra`：指令處理\n* `Jwt`：認證處理\n\n熟悉了基本的結構後，就可以試著來 Build Project 了。在打包 `Golang` 成應用程式時，必須要注意要運行的環境規格（`GOOS`、`GOARCH`）。\n\n接著，做下面這些事情：\n* 將專案資料夾複製到伺服器的專案路徑下\n* 建立服務的設定檔（/lib/systemd/system/<service_name>.service）\n* 啟動服務：`systemctl start <service_name>.service`\n* 檢查服務：`systemctl status <service_name>.service`\n* 開放 tcp 連線 port：`firewall-cmd --add-port=<port_number>/tcp`\n\n> 因為 `Main Service` 需要接收 http request，因此 tcp 一定要確認好。\n\n---\n## Angular 專案部署\n資料庫跟前面兩套系統 run 起來之後，終於來到熟悉的 `Angular` 專案部署。因為很常做，這裡就不廢話，按照 `Package.json` 裡的說明 Build，然後複製到伺服器的專案路徑資料夾即可。\n\n有一點可以延伸討論，前人有為這個專案留下 `Shell Script` 部署檔，讓打包部署流程變得方便許多，這次在仔細研讀後，也對整個流程到底是做了哪些事情有進一步的認識。或許之後也可以寫一些 `Shell Script` 小工具。\n\n---\n## Linux 設定\n在部署上面前後端程式及資料庫的過程中，一直有碰到陌生的未知領域，在查找了好一陣子之後，整理出下面三塊 `Linux` 設定。\n\n### Service\n通常後端服務都會作為 Service 運行，而在 `Linux` 想要運行服務，很常會用到的一些基本指令（也是我在這次架站過程中反覆用到的指令），整理如下：\n* `Lsof`：\n  * 查詢目前使用中的 port 及 process id：`lsof -n -i`\n  * 查詢特定 port 的服務：`lsof -n -i:<port_number>`\n  * 清除 PID：`kill <PID>`\n* `Systemctl`：\n  * 查看所有服務狀態：`systemctl --type=service`\n  * 查看特定服務狀態：`systemctl status <service name>`\n  * 啟動服務：`systemctl start <service name>`\n  * 停止服務：`systemctl stop <service name>`\n  * 重啟服務：`systemctl restart <service name>`\n  * 查看服務的設定檔：`systemctl cat <service name>`\n\n### Firewall\n後端服務 run 起來時我也稍微卡了一下，因為從 local 明明就可以打到 API，不知為何換個 ip 就一直失敗。後來查到原來是防火牆沒設定好，真相往往就這麼簡單。\n\n常用指令：\n  * 列出使用中的 port：`firewall-cmd --list-ports`\n  * 打開 port：`firewall-cmd --add-port=<port_number>/tcp`\n  * 永久打開 port：`firewall-cmd --permanent --add-port=<port_number>/tcp`\n  * 重啟：`firewall-cmd --reload`\n  * 關閉 port：`firewall-cmd --remove-port=<port_number>/tcp`\n\n> 其實除了預設的 80 Port 外，應盡量少讓其他人可以透過 tcp 直接連進伺服器會比較好，這部分的知識我尚未具備，還需要深入精進。\n\n### Web Server\n這裡也是卡很久，但其實若對 `httpd` 有些了解，應該是很簡單的事，因為就是`Directory` 跟 `Proxy Reverse` 兩件事而已。\n\n> 其實應該還缺 SSL 憑證相關的東西，但因為這次沒有接觸到設定網域名稱，之後有碰到再說吧！目前遇到的都還不是非常難的問題，一樣是那句話，凡事問 Stack Overflow 就有解了XD（例如說 Apache config 檔案在哪...[Where is the Apache configuration in CentOS](https://www.liquidweb.com/kb/apache-configuration-centos/)）\n\n---\n## 結論\n從研究各套 code 到嘗試建置的過程，前後加起來共 2 週，對一個 Senior 來說可能嫌太久（或許 Senior 只需要 3 天？），但我給自己一個正面的肯定。經過這次的磨練，補強知識的同時也在訓練自學能力，覺得能解這次任務實在是太好了！\n","source":"_posts/system-deploying.md","raw":"---\ntitle: 前後端＆資料庫系統建置心得\ndate: 2021-03-19 22:00:35\ntags: [fullStack]\n---\n\n機緣巧合下，我接到了個任務，需要把一套系統在一個新建的 Server 上架起來。盤點手上資源，是幾套程式碼，還有前人遺留在各 Server 的設定檔。我是剛轉職一年的前端工程師，對前端領域可說是才剛有一些心得，現在就來了這個任務...好吧！解就解，誰怕誰（~~反正有 Stack Overflow~~）！\n\n<!--more-->\n\n---\n## 系統架構\n要從無到有將系統建起來，首先需要了解系統的架構。廢話不多說，先上圖。\n\n![](https://i.imgur.com/0RqkfVN.png)\n\n這個系統是長成這個鬼樣子的，至於為什麼要用這麼多種語言設計，不要問我，去問前人。總之這系統上的各套服務，原本是架在不同 Server 的，而我這次要做的事情就是將它們全部搬到同個 Server 運行。\n\n經過一陣子的研究後，要達成目標，需要下列技術：\n1. Linux 基本操作\n1. 資料庫安裝（MariaDB & MongoDB）\n2. Node.js build & deploy\n3. Golang build & deploy\n4. Angular build & deploy\n5. Service config（systemd）\n6. Web Server config（httpd）\n\n> 補充一下困難程度，在開始做這件事前，我會的只有 5 而已...\n\n---\n## 資料庫建置\n好！那麼首先要嘗試的，就是資料庫的安裝。\n\n由於對這兩套資料庫完全不了解，我先在本機（Mac）試著用 `homebrew` 安裝了幾次。現在回過頭看覺得挺好笑的，因為後來才知道在 Mac 安裝跟在 `Linux` 安裝，完全是兩回事...\n\n### MariaDB\n* MacOS 安裝：https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/\n* Linux 安裝：https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/\n\n\n### MongoDB\n* MacOS 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\n* Linux 安裝：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\n\n> 目標伺服器是 `Linux CentOS 7`，也是因此契機才稍微去瞭解了下 `Linux` 作業系統，才知道原來有非常多版本。有興趣知道更多可參考這篇：[黑暗執行緒 - 我的 Linux 作業系統考察](https://blog.darkthread.net/blog/linux-server-os-survey/)\n\n安裝了資料庫後才是真正的開始，會遇到 root 密碼無法登入問題、安全性設定問題等怪事，這部分就不細說了，總之 Stack Overflow 是你我的好朋友。\n\n---\n## Node.js 專案部署\n完成資料庫的安裝後，接著是 `Form Service`，因為這套要先運行起來，`Main Service` 才能運行。由於在前端打滾了一年，多少還是懂一點 NPM，因此只要稍微讀一下 `Package.json`，就大概知道操作指令有哪些了。\n\n接著，做下面這些事情：\n* 將專案資料夾複製到伺服器的專案路徑下\n* 建立服務的設定檔（/lib/systemd/system/<service_name>.service）\n* 在專案路徑執行 `npm install` 以下載依賴套件\n* 啟動服務：`systemctl start <service_name>.service`\n* 檢查服務：`systemctl status <service_name>.service`\n* 開放 tcp 連線 port：`firewall-cmd --add-port=<port_number>/tcp`\n\n> 在服務設定檔中會指定專案路徑，以及在這個路徑底下要 `Linux` 執行什麼指令，因此熟悉的 `npm run start` 就會寫在這裡。\n\n---\n## Golang 專案部署\n在測試過 `Form Service` 正常運行後，就可以來接著架 `Main Service` 了。由於我完全不會 `Golang`，因此花了一些時間從頭學習，也整理出幾個 `Go` 常用的套件，找了一些 tutorial 來做。\n\n`Golang` 常用套件：\n* `Gin`：http server\n* `Gorm`：MariaDB 操作\n* `Mongo`：MongoDB 操作\n* `Cron`：排程設定\n* `Cobra`：指令處理\n* `Jwt`：認證處理\n\n熟悉了基本的結構後，就可以試著來 Build Project 了。在打包 `Golang` 成應用程式時，必須要注意要運行的環境規格（`GOOS`、`GOARCH`）。\n\n接著，做下面這些事情：\n* 將專案資料夾複製到伺服器的專案路徑下\n* 建立服務的設定檔（/lib/systemd/system/<service_name>.service）\n* 啟動服務：`systemctl start <service_name>.service`\n* 檢查服務：`systemctl status <service_name>.service`\n* 開放 tcp 連線 port：`firewall-cmd --add-port=<port_number>/tcp`\n\n> 因為 `Main Service` 需要接收 http request，因此 tcp 一定要確認好。\n\n---\n## Angular 專案部署\n資料庫跟前面兩套系統 run 起來之後，終於來到熟悉的 `Angular` 專案部署。因為很常做，這裡就不廢話，按照 `Package.json` 裡的說明 Build，然後複製到伺服器的專案路徑資料夾即可。\n\n有一點可以延伸討論，前人有為這個專案留下 `Shell Script` 部署檔，讓打包部署流程變得方便許多，這次在仔細研讀後，也對整個流程到底是做了哪些事情有進一步的認識。或許之後也可以寫一些 `Shell Script` 小工具。\n\n---\n## Linux 設定\n在部署上面前後端程式及資料庫的過程中，一直有碰到陌生的未知領域，在查找了好一陣子之後，整理出下面三塊 `Linux` 設定。\n\n### Service\n通常後端服務都會作為 Service 運行，而在 `Linux` 想要運行服務，很常會用到的一些基本指令（也是我在這次架站過程中反覆用到的指令），整理如下：\n* `Lsof`：\n  * 查詢目前使用中的 port 及 process id：`lsof -n -i`\n  * 查詢特定 port 的服務：`lsof -n -i:<port_number>`\n  * 清除 PID：`kill <PID>`\n* `Systemctl`：\n  * 查看所有服務狀態：`systemctl --type=service`\n  * 查看特定服務狀態：`systemctl status <service name>`\n  * 啟動服務：`systemctl start <service name>`\n  * 停止服務：`systemctl stop <service name>`\n  * 重啟服務：`systemctl restart <service name>`\n  * 查看服務的設定檔：`systemctl cat <service name>`\n\n### Firewall\n後端服務 run 起來時我也稍微卡了一下，因為從 local 明明就可以打到 API，不知為何換個 ip 就一直失敗。後來查到原來是防火牆沒設定好，真相往往就這麼簡單。\n\n常用指令：\n  * 列出使用中的 port：`firewall-cmd --list-ports`\n  * 打開 port：`firewall-cmd --add-port=<port_number>/tcp`\n  * 永久打開 port：`firewall-cmd --permanent --add-port=<port_number>/tcp`\n  * 重啟：`firewall-cmd --reload`\n  * 關閉 port：`firewall-cmd --remove-port=<port_number>/tcp`\n\n> 其實除了預設的 80 Port 外，應盡量少讓其他人可以透過 tcp 直接連進伺服器會比較好，這部分的知識我尚未具備，還需要深入精進。\n\n### Web Server\n這裡也是卡很久，但其實若對 `httpd` 有些了解，應該是很簡單的事，因為就是`Directory` 跟 `Proxy Reverse` 兩件事而已。\n\n> 其實應該還缺 SSL 憑證相關的東西，但因為這次沒有接觸到設定網域名稱，之後有碰到再說吧！目前遇到的都還不是非常難的問題，一樣是那句話，凡事問 Stack Overflow 就有解了XD（例如說 Apache config 檔案在哪...[Where is the Apache configuration in CentOS](https://www.liquidweb.com/kb/apache-configuration-centos/)）\n\n---\n## 結論\n從研究各套 code 到嘗試建置的過程，前後加起來共 2 週，對一個 Senior 來說可能嫌太久（或許 Senior 只需要 3 天？），但我給自己一個正面的肯定。經過這次的磨練，補強知識的同時也在訓練自學能力，覺得能解這次任務實在是太好了！\n","slug":"system-deploying","published":1,"updated":"2022-03-12T12:58:21.630Z","_id":"cl0nusu3e002kz6us1c75habg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>機緣巧合下，我接到了個任務，需要把一套系統在一個新建的 Server 上架起來。盤點手上資源，是幾套程式碼，還有前人遺留在各 Server 的設定檔。我是剛轉職一年的前端工程師，對前端領域可說是才剛有一些心得，現在就來了這個任務…好吧！解就解，誰怕誰（<del>反正有 Stack Overflow</del>）！</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"系統架構\"><a href=\"#系統架構\" class=\"headerlink\" title=\"系統架構\"></a>系統架構</h2><p>要從無到有將系統建起來，首先需要了解系統的架構。廢話不多說，先上圖。</p>\n<p><img src=\"https://i.imgur.com/0RqkfVN.png\"></p>\n<p>這個系統是長成這個鬼樣子的，至於為什麼要用這麼多種語言設計，不要問我，去問前人。總之這系統上的各套服務，原本是架在不同 Server 的，而我這次要做的事情就是將它們全部搬到同個 Server 運行。</p>\n<p>經過一陣子的研究後，要達成目標，需要下列技術：</p>\n<ol>\n<li>Linux 基本操作</li>\n<li>資料庫安裝（MariaDB &amp; MongoDB）</li>\n<li>Node.js build &amp; deploy</li>\n<li>Golang build &amp; deploy</li>\n<li>Angular build &amp; deploy</li>\n<li>Service config（systemd）</li>\n<li>Web Server config（httpd）</li>\n</ol>\n<blockquote>\n<p>補充一下困難程度，在開始做這件事前，我會的只有 5 而已…</p>\n</blockquote>\n<hr>\n<h2 id=\"資料庫建置\"><a href=\"#資料庫建置\" class=\"headerlink\" title=\"資料庫建置\"></a>資料庫建置</h2><p>好！那麼首先要嘗試的，就是資料庫的安裝。</p>\n<p>由於對這兩套資料庫完全不了解，我先在本機（Mac）試著用 <code>homebrew</code> 安裝了幾次。現在回過頭看覺得挺好笑的，因為後來才知道在 Mac 安裝跟在 <code>Linux</code> 安裝，完全是兩回事…</p>\n<h3 id=\"MariaDB\"><a href=\"#MariaDB\" class=\"headerlink\" title=\"MariaDB\"></a>MariaDB</h3><ul>\n<li>MacOS 安裝：<a class=\"link\"   href=\"https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/\" >https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>Linux 安裝：<a class=\"link\"   href=\"https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/\" >https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li>MacOS 安裝：<a class=\"link\"   href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\" >https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>Linux 安裝：<a class=\"link\"   href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\" >https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<blockquote>\n<p>目標伺服器是 <code>Linux CentOS 7</code>，也是因此契機才稍微去瞭解了下 <code>Linux</code> 作業系統，才知道原來有非常多版本。有興趣知道更多可參考這篇：<a class=\"link\"   href=\"https://blog.darkthread.net/blog/linux-server-os-survey/\" >黑暗執行緒 - 我的 Linux 作業系統考察<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>安裝了資料庫後才是真正的開始，會遇到 root 密碼無法登入問題、安全性設定問題等怪事，這部分就不細說了，總之 Stack Overflow 是你我的好朋友。</p>\n<hr>\n<h2 id=\"Node-js-專案部署\"><a href=\"#Node-js-專案部署\" class=\"headerlink\" title=\"Node.js 專案部署\"></a>Node.js 專案部署</h2><p>完成資料庫的安裝後，接著是 <code>Form Service</code>，因為這套要先運行起來，<code>Main Service</code> 才能運行。由於在前端打滾了一年，多少還是懂一點 NPM，因此只要稍微讀一下 <code>Package.json</code>，就大概知道操作指令有哪些了。</p>\n<p>接著，做下面這些事情：</p>\n<ul>\n<li>將專案資料夾複製到伺服器的專案路徑下</li>\n<li>建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<service_name>.service）</li>\n<li>在專案路徑執行 <code>npm install</code> 以下載依賴套件</li>\n<li>啟動服務：<code>systemctl start &lt;service_name&gt;.service</code></li>\n<li>檢查服務：<code>systemctl status &lt;service_name&gt;.service</code></li>\n<li>開放 tcp 連線 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>在服務設定檔中會指定專案路徑，以及在這個路徑底下要 <code>Linux</code> 執行什麼指令，因此熟悉的 <code>npm run start</code> 就會寫在這裡。</p>\n</blockquote>\n<hr>\n<h2 id=\"Golang-專案部署\"><a href=\"#Golang-專案部署\" class=\"headerlink\" title=\"Golang 專案部署\"></a>Golang 專案部署</h2><p>在測試過 <code>Form Service</code> 正常運行後，就可以來接著架 <code>Main Service</code> 了。由於我完全不會 <code>Golang</code>，因此花了一些時間從頭學習，也整理出幾個 <code>Go</code> 常用的套件，找了一些 tutorial 來做。</p>\n<p><code>Golang</code> 常用套件：</p>\n<ul>\n<li><code>Gin</code>：http server</li>\n<li><code>Gorm</code>：MariaDB 操作</li>\n<li><code>Mongo</code>：MongoDB 操作</li>\n<li><code>Cron</code>：排程設定</li>\n<li><code>Cobra</code>：指令處理</li>\n<li><code>Jwt</code>：認證處理</li>\n</ul>\n<p>熟悉了基本的結構後，就可以試著來 Build Project 了。在打包 <code>Golang</code> 成應用程式時，必須要注意要運行的環境規格（<code>GOOS</code>、<code>GOARCH</code>）。</p>\n<p>接著，做下面這些事情：</p>\n<ul>\n<li>將專案資料夾複製到伺服器的專案路徑下</li>\n<li>建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<service_name>.service）</li>\n<li>啟動服務：<code>systemctl start &lt;service_name&gt;.service</code></li>\n<li>檢查服務：<code>systemctl status &lt;service_name&gt;.service</code></li>\n<li>開放 tcp 連線 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>因為 <code>Main Service</code> 需要接收 http request，因此 tcp 一定要確認好。</p>\n</blockquote>\n<hr>\n<h2 id=\"Angular-專案部署\"><a href=\"#Angular-專案部署\" class=\"headerlink\" title=\"Angular 專案部署\"></a>Angular 專案部署</h2><p>資料庫跟前面兩套系統 run 起來之後，終於來到熟悉的 <code>Angular</code> 專案部署。因為很常做，這裡就不廢話，按照 <code>Package.json</code> 裡的說明 Build，然後複製到伺服器的專案路徑資料夾即可。</p>\n<p>有一點可以延伸討論，前人有為這個專案留下 <code>Shell Script</code> 部署檔，讓打包部署流程變得方便許多，這次在仔細研讀後，也對整個流程到底是做了哪些事情有進一步的認識。或許之後也可以寫一些 <code>Shell Script</code> 小工具。</p>\n<hr>\n<h2 id=\"Linux-設定\"><a href=\"#Linux-設定\" class=\"headerlink\" title=\"Linux 設定\"></a>Linux 設定</h2><p>在部署上面前後端程式及資料庫的過程中，一直有碰到陌生的未知領域，在查找了好一陣子之後，整理出下面三塊 <code>Linux</code> 設定。</p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>通常後端服務都會作為 Service 運行，而在 <code>Linux</code> 想要運行服務，很常會用到的一些基本指令（也是我在這次架站過程中反覆用到的指令），整理如下：</p>\n<ul>\n<li><code>Lsof</code>：<ul>\n<li>查詢目前使用中的 port 及 process id：<code>lsof -n -i</code></li>\n<li>查詢特定 port 的服務：<code>lsof -n -i:&lt;port_number&gt;</code></li>\n<li>清除 PID：<code>kill &lt;PID&gt;</code></li>\n</ul>\n</li>\n<li><code>Systemctl</code>：<ul>\n<li>查看所有服務狀態：<code>systemctl --type=service</code></li>\n<li>查看特定服務狀態：<code>systemctl status &lt;service name&gt;</code></li>\n<li>啟動服務：<code>systemctl start &lt;service name&gt;</code></li>\n<li>停止服務：<code>systemctl stop &lt;service name&gt;</code></li>\n<li>重啟服務：<code>systemctl restart &lt;service name&gt;</code></li>\n<li>查看服務的設定檔：<code>systemctl cat &lt;service name&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Firewall\"><a href=\"#Firewall\" class=\"headerlink\" title=\"Firewall\"></a>Firewall</h3><p>後端服務 run 起來時我也稍微卡了一下，因為從 local 明明就可以打到 API，不知為何換個 ip 就一直失敗。後來查到原來是防火牆沒設定好，真相往往就這麼簡單。</p>\n<p>常用指令：</p>\n<ul>\n<li>列出使用中的 port：<code>firewall-cmd --list-ports</code></li>\n<li>打開 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n<li>永久打開 port：<code>firewall-cmd --permanent --add-port=&lt;port_number&gt;/tcp</code></li>\n<li>重啟：<code>firewall-cmd --reload</code></li>\n<li>關閉 port：<code>firewall-cmd --remove-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>其實除了預設的 80 Port 外，應盡量少讓其他人可以透過 tcp 直接連進伺服器會比較好，這部分的知識我尚未具備，還需要深入精進。</p>\n</blockquote>\n<h3 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h3><p>這裡也是卡很久，但其實若對 <code>httpd</code> 有些了解，應該是很簡單的事，因為就是<code>Directory</code> 跟 <code>Proxy Reverse</code> 兩件事而已。</p>\n<blockquote>\n<p>其實應該還缺 SSL 憑證相關的東西，但因為這次沒有接觸到設定網域名稱，之後有碰到再說吧！目前遇到的都還不是非常難的問題，一樣是那句話，凡事問 Stack Overflow 就有解了XD（例如說 Apache config 檔案在哪…<a class=\"link\"   href=\"https://www.liquidweb.com/kb/apache-configuration-centos/\" >Where is the Apache configuration in CentOS<i class=\"fas fa-external-link-alt\"></i></a>）</p>\n</blockquote>\n<hr>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>從研究各套 code 到嘗試建置的過程，前後加起來共 2 週，對一個 Senior 來說可能嫌太久（或許 Senior 只需要 3 天？），但我給自己一個正面的肯定。經過這次的磨練，補強知識的同時也在訓練自學能力，覺得能解這次任務實在是太好了！</p>\n","site":{"data":{}},"excerpt":"<p>機緣巧合下，我接到了個任務，需要把一套系統在一個新建的 Server 上架起來。盤點手上資源，是幾套程式碼，還有前人遺留在各 Server 的設定檔。我是剛轉職一年的前端工程師，對前端領域可說是才剛有一些心得，現在就來了這個任務…好吧！解就解，誰怕誰（<del>反正有 Stack Overflow</del>）！</p>","more":"<hr>\n<h2 id=\"系統架構\"><a href=\"#系統架構\" class=\"headerlink\" title=\"系統架構\"></a>系統架構</h2><p>要從無到有將系統建起來，首先需要了解系統的架構。廢話不多說，先上圖。</p>\n<p><img src=\"https://i.imgur.com/0RqkfVN.png\"></p>\n<p>這個系統是長成這個鬼樣子的，至於為什麼要用這麼多種語言設計，不要問我，去問前人。總之這系統上的各套服務，原本是架在不同 Server 的，而我這次要做的事情就是將它們全部搬到同個 Server 運行。</p>\n<p>經過一陣子的研究後，要達成目標，需要下列技術：</p>\n<ol>\n<li>Linux 基本操作</li>\n<li>資料庫安裝（MariaDB &amp; MongoDB）</li>\n<li>Node.js build &amp; deploy</li>\n<li>Golang build &amp; deploy</li>\n<li>Angular build &amp; deploy</li>\n<li>Service config（systemd）</li>\n<li>Web Server config（httpd）</li>\n</ol>\n<blockquote>\n<p>補充一下困難程度，在開始做這件事前，我會的只有 5 而已…</p>\n</blockquote>\n<hr>\n<h2 id=\"資料庫建置\"><a href=\"#資料庫建置\" class=\"headerlink\" title=\"資料庫建置\"></a>資料庫建置</h2><p>好！那麼首先要嘗試的，就是資料庫的安裝。</p>\n<p>由於對這兩套資料庫完全不了解，我先在本機（Mac）試著用 <code>homebrew</code> 安裝了幾次。現在回過頭看覺得挺好笑的，因為後來才知道在 Mac 安裝跟在 <code>Linux</code> 安裝，完全是兩回事…</p>\n<h3 id=\"MariaDB\"><a href=\"#MariaDB\" class=\"headerlink\" title=\"MariaDB\"></a>MariaDB</h3><ul>\n<li>MacOS 安裝：<a class=\"link\"   href=\"https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/\" >https://mariadb.com/kb/en/installing-mariadb-on-macos-using-homebrew/<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>Linux 安裝：<a class=\"link\"   href=\"https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/\" >https://blog.gtwang.org/linux/centos-7-install-mariadb-mysql-server-tutorial/<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li>MacOS 安裝：<a class=\"link\"   href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\" >https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>Linux 安裝：<a class=\"link\"   href=\"https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/\" >https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n<blockquote>\n<p>目標伺服器是 <code>Linux CentOS 7</code>，也是因此契機才稍微去瞭解了下 <code>Linux</code> 作業系統，才知道原來有非常多版本。有興趣知道更多可參考這篇：<a class=\"link\"   href=\"https://blog.darkthread.net/blog/linux-server-os-survey/\" >黑暗執行緒 - 我的 Linux 作業系統考察<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n<p>安裝了資料庫後才是真正的開始，會遇到 root 密碼無法登入問題、安全性設定問題等怪事，這部分就不細說了，總之 Stack Overflow 是你我的好朋友。</p>\n<hr>\n<h2 id=\"Node-js-專案部署\"><a href=\"#Node-js-專案部署\" class=\"headerlink\" title=\"Node.js 專案部署\"></a>Node.js 專案部署</h2><p>完成資料庫的安裝後，接著是 <code>Form Service</code>，因為這套要先運行起來，<code>Main Service</code> 才能運行。由於在前端打滾了一年，多少還是懂一點 NPM，因此只要稍微讀一下 <code>Package.json</code>，就大概知道操作指令有哪些了。</p>\n<p>接著，做下面這些事情：</p>\n<ul>\n<li>將專案資料夾複製到伺服器的專案路徑下</li>\n<li>建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<service_name>.service）</li>\n<li>在專案路徑執行 <code>npm install</code> 以下載依賴套件</li>\n<li>啟動服務：<code>systemctl start &lt;service_name&gt;.service</code></li>\n<li>檢查服務：<code>systemctl status &lt;service_name&gt;.service</code></li>\n<li>開放 tcp 連線 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>在服務設定檔中會指定專案路徑，以及在這個路徑底下要 <code>Linux</code> 執行什麼指令，因此熟悉的 <code>npm run start</code> 就會寫在這裡。</p>\n</blockquote>\n<hr>\n<h2 id=\"Golang-專案部署\"><a href=\"#Golang-專案部署\" class=\"headerlink\" title=\"Golang 專案部署\"></a>Golang 專案部署</h2><p>在測試過 <code>Form Service</code> 正常運行後，就可以來接著架 <code>Main Service</code> 了。由於我完全不會 <code>Golang</code>，因此花了一些時間從頭學習，也整理出幾個 <code>Go</code> 常用的套件，找了一些 tutorial 來做。</p>\n<p><code>Golang</code> 常用套件：</p>\n<ul>\n<li><code>Gin</code>：http server</li>\n<li><code>Gorm</code>：MariaDB 操作</li>\n<li><code>Mongo</code>：MongoDB 操作</li>\n<li><code>Cron</code>：排程設定</li>\n<li><code>Cobra</code>：指令處理</li>\n<li><code>Jwt</code>：認證處理</li>\n</ul>\n<p>熟悉了基本的結構後，就可以試著來 Build Project 了。在打包 <code>Golang</code> 成應用程式時，必須要注意要運行的環境規格（<code>GOOS</code>、<code>GOARCH</code>）。</p>\n<p>接著，做下面這些事情：</p>\n<ul>\n<li>將專案資料夾複製到伺服器的專案路徑下</li>\n<li>建立服務的設定檔（&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<service_name>.service）</li>\n<li>啟動服務：<code>systemctl start &lt;service_name&gt;.service</code></li>\n<li>檢查服務：<code>systemctl status &lt;service_name&gt;.service</code></li>\n<li>開放 tcp 連線 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>因為 <code>Main Service</code> 需要接收 http request，因此 tcp 一定要確認好。</p>\n</blockquote>\n<hr>\n<h2 id=\"Angular-專案部署\"><a href=\"#Angular-專案部署\" class=\"headerlink\" title=\"Angular 專案部署\"></a>Angular 專案部署</h2><p>資料庫跟前面兩套系統 run 起來之後，終於來到熟悉的 <code>Angular</code> 專案部署。因為很常做，這裡就不廢話，按照 <code>Package.json</code> 裡的說明 Build，然後複製到伺服器的專案路徑資料夾即可。</p>\n<p>有一點可以延伸討論，前人有為這個專案留下 <code>Shell Script</code> 部署檔，讓打包部署流程變得方便許多，這次在仔細研讀後，也對整個流程到底是做了哪些事情有進一步的認識。或許之後也可以寫一些 <code>Shell Script</code> 小工具。</p>\n<hr>\n<h2 id=\"Linux-設定\"><a href=\"#Linux-設定\" class=\"headerlink\" title=\"Linux 設定\"></a>Linux 設定</h2><p>在部署上面前後端程式及資料庫的過程中，一直有碰到陌生的未知領域，在查找了好一陣子之後，整理出下面三塊 <code>Linux</code> 設定。</p>\n<h3 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h3><p>通常後端服務都會作為 Service 運行，而在 <code>Linux</code> 想要運行服務，很常會用到的一些基本指令（也是我在這次架站過程中反覆用到的指令），整理如下：</p>\n<ul>\n<li><code>Lsof</code>：<ul>\n<li>查詢目前使用中的 port 及 process id：<code>lsof -n -i</code></li>\n<li>查詢特定 port 的服務：<code>lsof -n -i:&lt;port_number&gt;</code></li>\n<li>清除 PID：<code>kill &lt;PID&gt;</code></li>\n</ul>\n</li>\n<li><code>Systemctl</code>：<ul>\n<li>查看所有服務狀態：<code>systemctl --type=service</code></li>\n<li>查看特定服務狀態：<code>systemctl status &lt;service name&gt;</code></li>\n<li>啟動服務：<code>systemctl start &lt;service name&gt;</code></li>\n<li>停止服務：<code>systemctl stop &lt;service name&gt;</code></li>\n<li>重啟服務：<code>systemctl restart &lt;service name&gt;</code></li>\n<li>查看服務的設定檔：<code>systemctl cat &lt;service name&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Firewall\"><a href=\"#Firewall\" class=\"headerlink\" title=\"Firewall\"></a>Firewall</h3><p>後端服務 run 起來時我也稍微卡了一下，因為從 local 明明就可以打到 API，不知為何換個 ip 就一直失敗。後來查到原來是防火牆沒設定好，真相往往就這麼簡單。</p>\n<p>常用指令：</p>\n<ul>\n<li>列出使用中的 port：<code>firewall-cmd --list-ports</code></li>\n<li>打開 port：<code>firewall-cmd --add-port=&lt;port_number&gt;/tcp</code></li>\n<li>永久打開 port：<code>firewall-cmd --permanent --add-port=&lt;port_number&gt;/tcp</code></li>\n<li>重啟：<code>firewall-cmd --reload</code></li>\n<li>關閉 port：<code>firewall-cmd --remove-port=&lt;port_number&gt;/tcp</code></li>\n</ul>\n<blockquote>\n<p>其實除了預設的 80 Port 外，應盡量少讓其他人可以透過 tcp 直接連進伺服器會比較好，這部分的知識我尚未具備，還需要深入精進。</p>\n</blockquote>\n<h3 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h3><p>這裡也是卡很久，但其實若對 <code>httpd</code> 有些了解，應該是很簡單的事，因為就是<code>Directory</code> 跟 <code>Proxy Reverse</code> 兩件事而已。</p>\n<blockquote>\n<p>其實應該還缺 SSL 憑證相關的東西，但因為這次沒有接觸到設定網域名稱，之後有碰到再說吧！目前遇到的都還不是非常難的問題，一樣是那句話，凡事問 Stack Overflow 就有解了XD（例如說 Apache config 檔案在哪…<a class=\"link\"   href=\"https://www.liquidweb.com/kb/apache-configuration-centos/\" >Where is the Apache configuration in CentOS<i class=\"fas fa-external-link-alt\"></i></a>）</p>\n</blockquote>\n<hr>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>從研究各套 code 到嘗試建置的過程，前後加起來共 2 週，對一個 Senior 來說可能嫌太久（或許 Senior 只需要 3 天？），但我給自己一個正面的肯定。經過這次的磨練，補強知識的同時也在訓練自學能力，覺得能解這次任務實在是太好了！</p>"},{"title":"Vue.js 學習筆記（一）","date":"2019-06-26T13:24:41.000Z","_content":"從頭開始學習 Vue.js，這真的是個很方便的東西。因為是記錄給自己看的，比較不會太詳細或有系統，也不知道會有幾篇XD。如果你想更進一步學習 Vue，建議你上網找課程，或閱讀 Vue 的官方文件。\n\n<!--more-->\n\n*導入 Vue.js 的方法*\n---\n在 `<head></head>` 內新增下列這一行程式碼，即可透過 CDN 引入 Vue.js。\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n```\n\n至於如何透過 `npm` 來安裝，以及官方所謂的腳手架工具，目前還不是很了解。\n\n---\n\n*Vue 的基本環境創建*\n---\n需先在 `<html>` 內創建一個掛載點，簡單的寫法如下：\n```javascript\n<body>\n    <div id=\"app\"></div>\n</body>\n```\n這個 `<div>` 就是 Vue 透過 id 抓到的的掛載點（也可以透過 class 來綁定，但沒辦法用同個 class 建立兩個 Vue，只會出現一個），接下來在`<script></script>` 內新增一個 Vue 如下：\n```javascript\n<script>\n    var app = new Vue({\n      el: \"#app\"  //透過id抓取此掛載點\n      //此處撰寫 Vue\n    });\n</script>\n```\n\n這樣一個基本的 Vue 環境就建置完成了。\n\n另外補充一個點，在 `Vue();` 的內部，是用物件來撰寫資料的，這也是為什麼會需要用大括號包起來。\n\n---\n\n*Vue 基本功能*\n---\n\n### 一、條件判定渲染\n\n`v-if` `v-else-if` `v-else` 使用條件來判定是否要渲染內容。若只依單一情況判定是否渲染，那可以用 `v-show` 就好。\n\n可以單獨使用如下：\n```javascript\n<p v-if=\"isAwake\">我醒著</p>  //isAwake=true 則渲染這塊內容\n```\n也可以搭配使用如下：\n```javascript\n<p v-if=\"isAwake\">我醒著</p>  //isAwake=true 則渲染這塊內容\n<p v-else>我睡死了</p> //isAwake=false 則渲染這塊內容\n```\n三者同時混用如下：\n```javascript\n<p v-if=\"num===1\">This is 1</p>\n<p v-else-if=\"num===2\">This is 2</p>\n<p v-else-if=\"num===3\">This is 3</p>\n<p v-else>This is not 1/2/3</p>\n```\n\n### 二、列表渲染\n\n`v-for` 可以達到節省重複撰寫 `<li>` 的效果。\n\n舉例 `<html>` 中要重複渲染的區塊如下：\n\n```javascript\n<ul id=\"app1\">\n  <li v-for=\"item in items\">  //或 item of items\n    {{ item.content }}\n  </li>\n</ul>\n```\n\n在 `Vue` 的 `data.items` 中列出所有內容，就可以做到重複渲染，如此一來相當方便管理。\n\n### 三、事件監聽\n\n`v-on` 可以方便地監聽 DOM 的各種事件，`v-on` 亦可以用 `@` 取代。簡單舉例如下：\n\n```javascript\n<button v-on:click=\"myFunction\">按鈕</button>\n<button @click=\"myFunction\">按鈕</button>  //偷懶的縮寫\n```\n\n### 四、屬性綁定\n\n`v-bind` 將 DOM 元素綁定一個 class。\n\n```javascript\n<div v-bind:class=\"myClass\"></div>\n<div :class=\"myClass\"></div>  //偷懶的縮寫\n```\n或綁定 src，讓你能更動態地改變這個 DOM 元素的來源。\n```javascript\n<img v-bind:src=\"imageSrc\" />\n<img :src=\"imageSrc\" />  //偷懶的縮寫\n```\n\n屬性綁定還能夠更方便地操作 DOM，之後再來探討。\n\n### 五、修飾符\n\nVue 的修飾符分為兩種：\n* 事件修飾符\n* 按鍵修飾符\n\n接下來就簡短記錄一下。\n\n#### （一） 事件修飾符\n\n有時為了預防假按鈕 `<a>` 點擊事件時，觸發到 `<href=\"#\">` 的跳轉或冒泡，我們會使用 `preventDefault()` `stopPropagation()` 來處理。在 Vue 中其實也差不多意思。\n\n* `.stop`\n* `.prevent`\n* `.capture`\n* `.self`\n* `.once`\n* `.passive`\n\n隨便舉個例子，可以這樣寫：\n```javascript\n<a href=\"#\" v-on:click.stop=\"myFunction\">假按鈕</a>\n```\n\n#### （二） 按鍵修飾符\n\n我們常為了監聽按鍵的行為而寫下許多 `addEventListener`，按鍵修飾符可以說就是簡化這件事的幫手。而且 Vue 還貼心地將按鍵對應的 keycode 轉變成直覺式的命名：\n\n* `.enter`\n* `.tab`\n* `.delete`\n* `.esc`\n* `.space`\n* `.up`\n* `.down`\n* `.left`\n* `.right`\n\n舉個例子，這樣用：\n```javascript\n<input v-on:keyup.enter=\"submit\">\n```\n\nVue 真的是很方便呢！\n\n---\n\n*Vue 觀念*\n---\n\n### 綁定的觀念\n\n在 Vue 中很重要的一個觀念就是綁定。透過綁定，讓 DOM 的操作變得容易。\n\n而透過 `v-model` 的雙向綁定，讓使用者輸入的內容，能夠同步修改 Vue 中的數據，如此一來能應用的範圍就很廣了。\n\n舉個例子，我有下列這段 `<html>`：\n```javascript\n<div id=\"app\">\n    勇者名稱： {{ name }}\n    <input type=\"text\" v-model=\"message\" />\n    <button v-on:click=\"enterName\">點我來輸入勇者名稱</button>\n</div>\n```\n在這個範例中，我希望使用者在 `<input>` 中輸入名稱，並點擊按鈕後，觸發 `enterName()` 將名稱傳入 `message`。如果是用純 js，我需要創建一個新的 `html` 標籤，並抓取 `<input>` 的 value 傳入，這期間又會需要做一些宣告變數來抓取各個標籤的動作，相當繁瑣。但在 Vue 中我只需要這樣寫：\n\n```javascript\nvar app = new Vue({\n    el: \"#app\",\n    data: {\n        message: \"請輸入勇者姓名\", //直接當作 input placeholder\n        name: \"\"  //宣告空的 name\n    },\n    methods: {\n        enterName: function(){\n            //直接將 messgae 傳入 name\n            this.name = this.message;\n        }\n    }\n});\n```\n就完成了！非常方便。這就是 Vue 偉大的綁定概念。\n\n---\n\n需進一步了解的部分\n---\n\n* App.vue：template + script + style\n* component\n* Vue 腳手架","source":"_posts/vue-note-1.md","raw":"---\ntitle: Vue.js 學習筆記（一）\ndate: 2019-06-26 21:24:41\ntags: vue.js\n---\n從頭開始學習 Vue.js，這真的是個很方便的東西。因為是記錄給自己看的，比較不會太詳細或有系統，也不知道會有幾篇XD。如果你想更進一步學習 Vue，建議你上網找課程，或閱讀 Vue 的官方文件。\n\n<!--more-->\n\n*導入 Vue.js 的方法*\n---\n在 `<head></head>` 內新增下列這一行程式碼，即可透過 CDN 引入 Vue.js。\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n```\n\n至於如何透過 `npm` 來安裝，以及官方所謂的腳手架工具，目前還不是很了解。\n\n---\n\n*Vue 的基本環境創建*\n---\n需先在 `<html>` 內創建一個掛載點，簡單的寫法如下：\n```javascript\n<body>\n    <div id=\"app\"></div>\n</body>\n```\n這個 `<div>` 就是 Vue 透過 id 抓到的的掛載點（也可以透過 class 來綁定，但沒辦法用同個 class 建立兩個 Vue，只會出現一個），接下來在`<script></script>` 內新增一個 Vue 如下：\n```javascript\n<script>\n    var app = new Vue({\n      el: \"#app\"  //透過id抓取此掛載點\n      //此處撰寫 Vue\n    });\n</script>\n```\n\n這樣一個基本的 Vue 環境就建置完成了。\n\n另外補充一個點，在 `Vue();` 的內部，是用物件來撰寫資料的，這也是為什麼會需要用大括號包起來。\n\n---\n\n*Vue 基本功能*\n---\n\n### 一、條件判定渲染\n\n`v-if` `v-else-if` `v-else` 使用條件來判定是否要渲染內容。若只依單一情況判定是否渲染，那可以用 `v-show` 就好。\n\n可以單獨使用如下：\n```javascript\n<p v-if=\"isAwake\">我醒著</p>  //isAwake=true 則渲染這塊內容\n```\n也可以搭配使用如下：\n```javascript\n<p v-if=\"isAwake\">我醒著</p>  //isAwake=true 則渲染這塊內容\n<p v-else>我睡死了</p> //isAwake=false 則渲染這塊內容\n```\n三者同時混用如下：\n```javascript\n<p v-if=\"num===1\">This is 1</p>\n<p v-else-if=\"num===2\">This is 2</p>\n<p v-else-if=\"num===3\">This is 3</p>\n<p v-else>This is not 1/2/3</p>\n```\n\n### 二、列表渲染\n\n`v-for` 可以達到節省重複撰寫 `<li>` 的效果。\n\n舉例 `<html>` 中要重複渲染的區塊如下：\n\n```javascript\n<ul id=\"app1\">\n  <li v-for=\"item in items\">  //或 item of items\n    {{ item.content }}\n  </li>\n</ul>\n```\n\n在 `Vue` 的 `data.items` 中列出所有內容，就可以做到重複渲染，如此一來相當方便管理。\n\n### 三、事件監聽\n\n`v-on` 可以方便地監聽 DOM 的各種事件，`v-on` 亦可以用 `@` 取代。簡單舉例如下：\n\n```javascript\n<button v-on:click=\"myFunction\">按鈕</button>\n<button @click=\"myFunction\">按鈕</button>  //偷懶的縮寫\n```\n\n### 四、屬性綁定\n\n`v-bind` 將 DOM 元素綁定一個 class。\n\n```javascript\n<div v-bind:class=\"myClass\"></div>\n<div :class=\"myClass\"></div>  //偷懶的縮寫\n```\n或綁定 src，讓你能更動態地改變這個 DOM 元素的來源。\n```javascript\n<img v-bind:src=\"imageSrc\" />\n<img :src=\"imageSrc\" />  //偷懶的縮寫\n```\n\n屬性綁定還能夠更方便地操作 DOM，之後再來探討。\n\n### 五、修飾符\n\nVue 的修飾符分為兩種：\n* 事件修飾符\n* 按鍵修飾符\n\n接下來就簡短記錄一下。\n\n#### （一） 事件修飾符\n\n有時為了預防假按鈕 `<a>` 點擊事件時，觸發到 `<href=\"#\">` 的跳轉或冒泡，我們會使用 `preventDefault()` `stopPropagation()` 來處理。在 Vue 中其實也差不多意思。\n\n* `.stop`\n* `.prevent`\n* `.capture`\n* `.self`\n* `.once`\n* `.passive`\n\n隨便舉個例子，可以這樣寫：\n```javascript\n<a href=\"#\" v-on:click.stop=\"myFunction\">假按鈕</a>\n```\n\n#### （二） 按鍵修飾符\n\n我們常為了監聽按鍵的行為而寫下許多 `addEventListener`，按鍵修飾符可以說就是簡化這件事的幫手。而且 Vue 還貼心地將按鍵對應的 keycode 轉變成直覺式的命名：\n\n* `.enter`\n* `.tab`\n* `.delete`\n* `.esc`\n* `.space`\n* `.up`\n* `.down`\n* `.left`\n* `.right`\n\n舉個例子，這樣用：\n```javascript\n<input v-on:keyup.enter=\"submit\">\n```\n\nVue 真的是很方便呢！\n\n---\n\n*Vue 觀念*\n---\n\n### 綁定的觀念\n\n在 Vue 中很重要的一個觀念就是綁定。透過綁定，讓 DOM 的操作變得容易。\n\n而透過 `v-model` 的雙向綁定，讓使用者輸入的內容，能夠同步修改 Vue 中的數據，如此一來能應用的範圍就很廣了。\n\n舉個例子，我有下列這段 `<html>`：\n```javascript\n<div id=\"app\">\n    勇者名稱： {{ name }}\n    <input type=\"text\" v-model=\"message\" />\n    <button v-on:click=\"enterName\">點我來輸入勇者名稱</button>\n</div>\n```\n在這個範例中，我希望使用者在 `<input>` 中輸入名稱，並點擊按鈕後，觸發 `enterName()` 將名稱傳入 `message`。如果是用純 js，我需要創建一個新的 `html` 標籤，並抓取 `<input>` 的 value 傳入，這期間又會需要做一些宣告變數來抓取各個標籤的動作，相當繁瑣。但在 Vue 中我只需要這樣寫：\n\n```javascript\nvar app = new Vue({\n    el: \"#app\",\n    data: {\n        message: \"請輸入勇者姓名\", //直接當作 input placeholder\n        name: \"\"  //宣告空的 name\n    },\n    methods: {\n        enterName: function(){\n            //直接將 messgae 傳入 name\n            this.name = this.message;\n        }\n    }\n});\n```\n就完成了！非常方便。這就是 Vue 偉大的綁定概念。\n\n---\n\n需進一步了解的部分\n---\n\n* App.vue：template + script + style\n* component\n* Vue 腳手架","slug":"vue-note-1","published":1,"updated":"2022-03-12T12:58:21.698Z","_id":"cl0nusu60002nz6usdcoe2hus","comments":1,"layout":"post","photos":[],"link":"","content":"<p>從頭開始學習 Vue.js，這真的是個很方便的東西。因為是記錄給自己看的，比較不會太詳細或有系統，也不知道會有幾篇XD。如果你想更進一步學習 Vue，建議你上網找課程，或閱讀 Vue 的官方文件。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"導入-Vue-js-的方法\"><a href=\"#導入-Vue-js-的方法\" class=\"headerlink\" title=\"導入 Vue.js 的方法\"></a><em>導入 Vue.js 的方法</em></h2><p>在 <code>&lt;head&gt;&lt;/head&gt;</code> 內新增下列這一行程式碼，即可透過 CDN 引入 Vue.js。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>至於如何透過 <code>npm</code> 來安裝，以及官方所謂的腳手架工具，目前還不是很了解。</p>\n<hr>\n<h2 id=\"Vue-的基本環境創建\"><a href=\"#Vue-的基本環境創建\" class=\"headerlink\" title=\"Vue 的基本環境創建\"></a><em>Vue 的基本環境創建</em></h2><p>需先在 <code>&lt;html&gt;</code> 內創建一個掛載點，簡單的寫法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>這個 <code>&lt;div&gt;</code> 就是 Vue 透過 id 抓到的的掛載點（也可以透過 class 來綁定，但沒辦法用同個 class 建立兩個 Vue，只會出現一個），接下來在<code>&lt;script&gt;&lt;/script&gt;</code> 內新增一個 Vue 如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>  <span class=\"comment\">//透過id抓取此掛載點</span></span><br><span class=\"line\">      <span class=\"comment\">//此處撰寫 Vue</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>這樣一個基本的 Vue 環境就建置完成了。</p>\n<p>另外補充一個點，在 <code>Vue();</code> 的內部，是用物件來撰寫資料的，這也是為什麼會需要用大括號包起來。</p>\n<hr>\n<h2 id=\"Vue-基本功能\"><a href=\"#Vue-基本功能\" class=\"headerlink\" title=\"Vue 基本功能\"></a><em>Vue 基本功能</em></h2><h3 id=\"一、條件判定渲染\"><a href=\"#一、條件判定渲染\" class=\"headerlink\" title=\"一、條件判定渲染\"></a>一、條件判定渲染</h3><p><code>v-if</code> <code>v-else-if</code> <code>v-else</code> 使用條件來判定是否要渲染內容。若只依單一情況判定是否渲染，那可以用 <code>v-show</code> 就好。</p>\n<p>可以單獨使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;isAwake&quot;</span>&gt;我醒著&lt;<span class=\"regexp\">/p&gt;  /</span><span class=\"regexp\">/isAwake=true 則渲染這塊內容</span></span><br></pre></td></tr></table></figure>\n<p>也可以搭配使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;isAwake&quot;</span>&gt;我醒著&lt;<span class=\"regexp\">/p&gt;  /</span><span class=\"regexp\">/isAwake=true 則渲染這塊內容</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p v-else&gt;我睡死了&lt;/</span>p&gt; <span class=\"comment\">//isAwake=false 則渲染這塊內容</span></span><br></pre></td></tr></table></figure>\n<p>三者同時混用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;num===1&quot;</span>&gt;<span class=\"title class_\">This</span> is <span class=\"number\">1</span>&lt;/p&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">&quot;num===2&quot;</span>&gt;</span>This is 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">&quot;num===3&quot;</span>&gt;</span>This is 3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>This is not 1/2/3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、列表渲染\"><a href=\"#二、列表渲染\" class=\"headerlink\" title=\"二、列表渲染\"></a>二、列表渲染</h3><p><code>v-for</code> 可以達到節省重複撰寫 <code>&lt;li&gt;</code> 的效果。</p>\n<p>舉例 <code>&lt;html&gt;</code> 中要重複渲染的區塊如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=<span class=\"string\">&quot;app1&quot;</span>&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>  //或 item of items</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; item.content &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Vue</code> 的 <code>data.items</code> 中列出所有內容，就可以做到重複渲染，如此一來相當方便管理。</p>\n<h3 id=\"三、事件監聽\"><a href=\"#三、事件監聽\" class=\"headerlink\" title=\"三、事件監聽\"></a>三、事件監聽</h3><p><code>v-on</code> 可以方便地監聽 DOM 的各種事件，<code>v-on</code> 亦可以用 <code>@</code> 取代。簡單舉例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button v-<span class=\"attr\">on</span>:click=<span class=\"string\">&quot;myFunction&quot;</span>&gt;按鈕&lt;/button&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;myFunction&quot;</span>&gt;</span>按鈕<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、屬性綁定\"><a href=\"#四、屬性綁定\" class=\"headerlink\" title=\"四、屬性綁定\"></a>四、屬性綁定</h3><p><code>v-bind</code> 將 DOM 元素綁定一個 class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-<span class=\"attr\">bind</span>:<span class=\"keyword\">class</span>=<span class=\"string\">&quot;myClass&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;myClass&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n<p>或綁定 src，讓你能更動態地改變這個 DOM 元素的來源。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img v-<span class=\"attr\">bind</span>:src=<span class=\"string\">&quot;imageSrc&quot;</span> /&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">&quot;imageSrc&quot;</span> /&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n\n<p>屬性綁定還能夠更方便地操作 DOM，之後再來探討。</p>\n<h3 id=\"五、修飾符\"><a href=\"#五、修飾符\" class=\"headerlink\" title=\"五、修飾符\"></a>五、修飾符</h3><p>Vue 的修飾符分為兩種：</p>\n<ul>\n<li>事件修飾符</li>\n<li>按鍵修飾符</li>\n</ul>\n<p>接下來就簡短記錄一下。</p>\n<h4 id=\"（一）-事件修飾符\"><a href=\"#（一）-事件修飾符\" class=\"headerlink\" title=\"（一） 事件修飾符\"></a>（一） 事件修飾符</h4><p>有時為了預防假按鈕 <code>&lt;a&gt;</code> 點擊事件時，觸發到 <code>&lt;href=&quot;#&quot;&gt;</code> 的跳轉或冒泡，我們會使用 <code>preventDefault()</code> <code>stopPropagation()</code> 來處理。在 Vue 中其實也差不多意思。</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<p>隨便舉個例子，可以這樣寫：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;#&quot;</span> v-<span class=\"attr\">on</span>:click.<span class=\"property\">stop</span>=<span class=\"string\">&quot;myFunction&quot;</span>&gt;假按鈕&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（二）-按鍵修飾符\"><a href=\"#（二）-按鍵修飾符\" class=\"headerlink\" title=\"（二） 按鍵修飾符\"></a>（二） 按鍵修飾符</h4><p>我們常為了監聽按鍵的行為而寫下許多 <code>addEventListener</code>，按鍵修飾符可以說就是簡化這件事的幫手。而且 Vue 還貼心地將按鍵對應的 keycode 轉變成直覺式的命名：</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code></li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>舉個例子，這樣用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-<span class=\"attr\">on</span>:keyup.<span class=\"property\">enter</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Vue 真的是很方便呢！</p>\n<hr>\n<h2 id=\"Vue-觀念\"><a href=\"#Vue-觀念\" class=\"headerlink\" title=\"Vue 觀念\"></a><em>Vue 觀念</em></h2><h3 id=\"綁定的觀念\"><a href=\"#綁定的觀念\" class=\"headerlink\" title=\"綁定的觀念\"></a>綁定的觀念</h3><p>在 Vue 中很重要的一個觀念就是綁定。透過綁定，讓 DOM 的操作變得容易。</p>\n<p>而透過 <code>v-model</code> 的雙向綁定，讓使用者輸入的內容，能夠同步修改 Vue 中的數據，如此一來能應用的範圍就很廣了。</p>\n<p>舉個例子，我有下列這段 <code>&lt;html&gt;</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;app&quot;</span>&gt;</span><br><span class=\"line\">    勇者名稱： &#123;&#123; name &#125;&#125;</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">&quot;text&quot;</span> v-model=<span class=\"string\">&quot;message&quot;</span> /&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;enterName&quot;</span>&gt;</span>點我來輸入勇者名稱<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>在這個範例中，我希望使用者在 <code>&lt;input&gt;</code> 中輸入名稱，並點擊按鈕後，觸發 <code>enterName()</code> 將名稱傳入 <code>message</code>。如果是用純 js，我需要創建一個新的 <code>html</code> 標籤，並抓取 <code>&lt;input&gt;</code> 的 value 傳入，這期間又會需要做一些宣告變數來抓取各個標籤的動作，相當繁瑣。但在 Vue 中我只需要這樣寫：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">message</span>: <span class=\"string\">&quot;請輸入勇者姓名&quot;</span>, <span class=\"comment\">//直接當作 input placeholder</span></span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span>  <span class=\"comment\">//宣告空的 name</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">enterName</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//直接將 messgae 傳入 name</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就完成了！非常方便。這就是 Vue 偉大的綁定概念。</p>\n<hr>\n<h2 id=\"需進一步了解的部分\"><a href=\"#需進一步了解的部分\" class=\"headerlink\" title=\"需進一步了解的部分\"></a>需進一步了解的部分</h2><ul>\n<li>App.vue：template + script + style</li>\n<li>component</li>\n<li>Vue 腳手架</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>從頭開始學習 Vue.js，這真的是個很方便的東西。因為是記錄給自己看的，比較不會太詳細或有系統，也不知道會有幾篇XD。如果你想更進一步學習 Vue，建議你上網找課程，或閱讀 Vue 的官方文件。</p>","more":"<h2 id=\"導入-Vue-js-的方法\"><a href=\"#導入-Vue-js-的方法\" class=\"headerlink\" title=\"導入 Vue.js 的方法\"></a><em>導入 Vue.js 的方法</em></h2><p>在 <code>&lt;head&gt;&lt;/head&gt;</code> 內新增下列這一行程式碼，即可透過 CDN 引入 Vue.js。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>至於如何透過 <code>npm</code> 來安裝，以及官方所謂的腳手架工具，目前還不是很了解。</p>\n<hr>\n<h2 id=\"Vue-的基本環境創建\"><a href=\"#Vue-的基本環境創建\" class=\"headerlink\" title=\"Vue 的基本環境創建\"></a><em>Vue 的基本環境創建</em></h2><p>需先在 <code>&lt;html&gt;</code> 內創建一個掛載點，簡單的寫法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>這個 <code>&lt;div&gt;</code> 就是 Vue 透過 id 抓到的的掛載點（也可以透過 class 來綁定，但沒辦法用同個 class 建立兩個 Vue，只會出現一個），接下來在<code>&lt;script&gt;&lt;/script&gt;</code> 內新增一個 Vue 如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>  <span class=\"comment\">//透過id抓取此掛載點</span></span><br><span class=\"line\">      <span class=\"comment\">//此處撰寫 Vue</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>這樣一個基本的 Vue 環境就建置完成了。</p>\n<p>另外補充一個點，在 <code>Vue();</code> 的內部，是用物件來撰寫資料的，這也是為什麼會需要用大括號包起來。</p>\n<hr>\n<h2 id=\"Vue-基本功能\"><a href=\"#Vue-基本功能\" class=\"headerlink\" title=\"Vue 基本功能\"></a><em>Vue 基本功能</em></h2><h3 id=\"一、條件判定渲染\"><a href=\"#一、條件判定渲染\" class=\"headerlink\" title=\"一、條件判定渲染\"></a>一、條件判定渲染</h3><p><code>v-if</code> <code>v-else-if</code> <code>v-else</code> 使用條件來判定是否要渲染內容。若只依單一情況判定是否渲染，那可以用 <code>v-show</code> 就好。</p>\n<p>可以單獨使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;isAwake&quot;</span>&gt;我醒著&lt;<span class=\"regexp\">/p&gt;  /</span><span class=\"regexp\">/isAwake=true 則渲染這塊內容</span></span><br></pre></td></tr></table></figure>\n<p>也可以搭配使用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;isAwake&quot;</span>&gt;我醒著&lt;<span class=\"regexp\">/p&gt;  /</span><span class=\"regexp\">/isAwake=true 則渲染這塊內容</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;p v-else&gt;我睡死了&lt;/</span>p&gt; <span class=\"comment\">//isAwake=false 則渲染這塊內容</span></span><br></pre></td></tr></table></figure>\n<p>三者同時混用如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p v-<span class=\"keyword\">if</span>=<span class=\"string\">&quot;num===1&quot;</span>&gt;<span class=\"title class_\">This</span> is <span class=\"number\">1</span>&lt;/p&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">&quot;num===2&quot;</span>&gt;</span>This is 2<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else-if</span>=<span class=\"string\">&quot;num===3&quot;</span>&gt;</span>This is 3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>This is not 1/2/3<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、列表渲染\"><a href=\"#二、列表渲染\" class=\"headerlink\" title=\"二、列表渲染\"></a>二、列表渲染</h3><p><code>v-for</code> 可以達到節省重複撰寫 <code>&lt;li&gt;</code> 的效果。</p>\n<p>舉例 <code>&lt;html&gt;</code> 中要重複渲染的區塊如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul id=<span class=\"string\">&quot;app1&quot;</span>&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>  //或 item of items</span></span><br><span class=\"line\"><span class=\"language-xml\">    &#123;&#123; item.content &#125;&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Vue</code> 的 <code>data.items</code> 中列出所有內容，就可以做到重複渲染，如此一來相當方便管理。</p>\n<h3 id=\"三、事件監聽\"><a href=\"#三、事件監聽\" class=\"headerlink\" title=\"三、事件監聽\"></a>三、事件監聽</h3><p><code>v-on</code> 可以方便地監聽 DOM 的各種事件，<code>v-on</code> 亦可以用 <code>@</code> 取代。簡單舉例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button v-<span class=\"attr\">on</span>:click=<span class=\"string\">&quot;myFunction&quot;</span>&gt;按鈕&lt;/button&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;myFunction&quot;</span>&gt;</span>按鈕<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"四、屬性綁定\"><a href=\"#四、屬性綁定\" class=\"headerlink\" title=\"四、屬性綁定\"></a>四、屬性綁定</h3><p><code>v-bind</code> 將 DOM 元素綁定一個 class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-<span class=\"attr\">bind</span>:<span class=\"keyword\">class</span>=<span class=\"string\">&quot;myClass&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;myClass&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n<p>或綁定 src，讓你能更動態地改變這個 DOM 元素的來源。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img v-<span class=\"attr\">bind</span>:src=<span class=\"string\">&quot;imageSrc&quot;</span> /&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">:src</span>=<span class=\"string\">&quot;imageSrc&quot;</span> /&gt;</span></span>  <span class=\"comment\">//偷懶的縮寫</span></span><br></pre></td></tr></table></figure>\n\n<p>屬性綁定還能夠更方便地操作 DOM，之後再來探討。</p>\n<h3 id=\"五、修飾符\"><a href=\"#五、修飾符\" class=\"headerlink\" title=\"五、修飾符\"></a>五、修飾符</h3><p>Vue 的修飾符分為兩種：</p>\n<ul>\n<li>事件修飾符</li>\n<li>按鍵修飾符</li>\n</ul>\n<p>接下來就簡短記錄一下。</p>\n<h4 id=\"（一）-事件修飾符\"><a href=\"#（一）-事件修飾符\" class=\"headerlink\" title=\"（一） 事件修飾符\"></a>（一） 事件修飾符</h4><p>有時為了預防假按鈕 <code>&lt;a&gt;</code> 點擊事件時，觸發到 <code>&lt;href=&quot;#&quot;&gt;</code> 的跳轉或冒泡，我們會使用 <code>preventDefault()</code> <code>stopPropagation()</code> 來處理。在 Vue 中其實也差不多意思。</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<p>隨便舉個例子，可以這樣寫：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;#&quot;</span> v-<span class=\"attr\">on</span>:click.<span class=\"property\">stop</span>=<span class=\"string\">&quot;myFunction&quot;</span>&gt;假按鈕&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"（二）-按鍵修飾符\"><a href=\"#（二）-按鍵修飾符\" class=\"headerlink\" title=\"（二） 按鍵修飾符\"></a>（二） 按鍵修飾符</h4><p>我們常為了監聽按鍵的行為而寫下許多 <code>addEventListener</code>，按鍵修飾符可以說就是簡化這件事的幫手。而且 Vue 還貼心地將按鍵對應的 keycode 轉變成直覺式的命名：</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code></li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p>舉個例子，這樣用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-<span class=\"attr\">on</span>:keyup.<span class=\"property\">enter</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>Vue 真的是很方便呢！</p>\n<hr>\n<h2 id=\"Vue-觀念\"><a href=\"#Vue-觀念\" class=\"headerlink\" title=\"Vue 觀念\"></a><em>Vue 觀念</em></h2><h3 id=\"綁定的觀念\"><a href=\"#綁定的觀念\" class=\"headerlink\" title=\"綁定的觀念\"></a>綁定的觀念</h3><p>在 Vue 中很重要的一個觀念就是綁定。透過綁定，讓 DOM 的操作變得容易。</p>\n<p>而透過 <code>v-model</code> 的雙向綁定，讓使用者輸入的內容，能夠同步修改 Vue 中的數據，如此一來能應用的範圍就很廣了。</p>\n<p>舉個例子，我有下列這段 <code>&lt;html&gt;</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;app&quot;</span>&gt;</span><br><span class=\"line\">    勇者名稱： &#123;&#123; name &#125;&#125;</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">&quot;text&quot;</span> v-model=<span class=\"string\">&quot;message&quot;</span> /&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;enterName&quot;</span>&gt;</span>點我來輸入勇者名稱<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>在這個範例中，我希望使用者在 <code>&lt;input&gt;</code> 中輸入名稱，並點擊按鈕後，觸發 <code>enterName()</code> 將名稱傳入 <code>message</code>。如果是用純 js，我需要創建一個新的 <code>html</code> 標籤，並抓取 <code>&lt;input&gt;</code> 的 value 傳入，這期間又會需要做一些宣告變數來抓取各個標籤的動作，相當繁瑣。但在 Vue 中我只需要這樣寫：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">message</span>: <span class=\"string\">&quot;請輸入勇者姓名&quot;</span>, <span class=\"comment\">//直接當作 input placeholder</span></span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">&quot;&quot;</span>  <span class=\"comment\">//宣告空的 name</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">enterName</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//直接將 messgae 傳入 name</span></span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就完成了！非常方便。這就是 Vue 偉大的綁定概念。</p>\n<hr>\n<h2 id=\"需進一步了解的部分\"><a href=\"#需進一步了解的部分\" class=\"headerlink\" title=\"需進一步了解的部分\"></a>需進一步了解的部分</h2><ul>\n<li>App.vue：template + script + style</li>\n<li>component</li>\n<li>Vue 腳手架</li>\n</ul>"},{"title":"Web 學習筆記 - localStorage / sessionStorage / cookie / session 比較","date":"2019-09-12T09:36:01.000Z","_content":"\n這幾個東西有什麼不同？這是面試很常出現的基礎題，也是前端新手（*例如我）很容易霧煞煞的部分。為了加深印象，我決定來整理一篇筆記。\n<!--more-->\n在找資料的過程中，發現一個叫做 `session` 的東西，與 `cookie` 放在一起討論。這解釋了我其中一場面試的疑惑，當我在討論`localStorage` 與 `sessionStorage` 時，面試官卻說「`session` 應該是存在伺服器端的才對」，並且提到了 `cookie`。\n\n原因在這裡，我們講的是不同東西啊！面試官嘴裡說的是 `sessionStorage`，心裡想的卻是 `session`。\n\n真抱歉，我又不會通靈。\n\n---\n\n`localStorage` 與 `sessionStorage`\n---\n### 相同特徵\n* 儲存大小限制皆為 5MB 左右\n* 都有同源策略（CORS）限制\n* 僅在客戶端瀏覽器中存在\n\n### 相異特徵\n||localStorage|sessionStorage|\n|-|-|-|\n|生命週期|永久儲存在瀏覽器中，除非人為刪除|瀏覽器或標籤頁關閉時自動刪除|\n|作用域|在同一個瀏覽器内，同源文件間共享，可互相讀取、覆蓋|因生命週期關係，僅在同個瀏覽器、同個標籤頁內的同源文件間才可共享|\n\n### 操作方法\n```javascript\n//sessionStorage用法相同\nlocalStorage.setItem();     // 儲存一個物件\nlocalStorage.getItem();     // 獲取物件內容\nlocalStorage.key();         // 獲取第i個物件\nlocalStorage.removeItem();  // 刪除一個物件\nlocalStorage.clear();       // 全部删除\n```\n透過上述的方法，就能夠將使用者的一些資料（例如搜尋字串等）儲存在該使用者的瀏覽器中，當下次再訪問這個網站時，就能夠使用這些資料來提升使用者體驗。\n\n---\n\n`cookie` 與 `session`\n---\n### `cookie`\n* 大小限制只有 4KB 左右\n* 通常會帶有使用者的 `sessionID` 供伺服器辨識\n* 由伺服器產生後保存在客戶端，可以設定多久失效\n* 每次都攜帶在 HTTP header 中\n\n### `session`\n* 保存在伺服器端\n* 存有使用者的敏感資料\n\n### `cookie` 與 `session` 的溝通\n當使用者訪問網站、通過身份認證後，伺服器端會送出一個 `cookie` 到客戶端，並建立一個 `sessionID` 存在 `cookie` 中。之後使用者只要通過該網站的身份認證，就能夠透過存在 `cookie` 中的 `sessionID` 查找到存在伺服器的 `session` 資料。\n\n---\n\n參考資料\n\n* [细说localStorage, sessionStorage, Cookie, Session](https://juejin.im/entry/5ac4d661f265da23a049c92a)\n* [介紹 Session 及 Cookie 兩者的差別說明](https://blog.hellojcc.tw/2016/01/12/introduce-session-and-cookie/)","source":"_posts/web-cookie-session.md","raw":"---\ntitle: Web 學習筆記 - localStorage / sessionStorage / cookie / session 比較\ndate: 2019-09-12 17:36:01\ntags: [web,localStorage,sessionStorage,cookie,session]\n---\n\n這幾個東西有什麼不同？這是面試很常出現的基礎題，也是前端新手（*例如我）很容易霧煞煞的部分。為了加深印象，我決定來整理一篇筆記。\n<!--more-->\n在找資料的過程中，發現一個叫做 `session` 的東西，與 `cookie` 放在一起討論。這解釋了我其中一場面試的疑惑，當我在討論`localStorage` 與 `sessionStorage` 時，面試官卻說「`session` 應該是存在伺服器端的才對」，並且提到了 `cookie`。\n\n原因在這裡，我們講的是不同東西啊！面試官嘴裡說的是 `sessionStorage`，心裡想的卻是 `session`。\n\n真抱歉，我又不會通靈。\n\n---\n\n`localStorage` 與 `sessionStorage`\n---\n### 相同特徵\n* 儲存大小限制皆為 5MB 左右\n* 都有同源策略（CORS）限制\n* 僅在客戶端瀏覽器中存在\n\n### 相異特徵\n||localStorage|sessionStorage|\n|-|-|-|\n|生命週期|永久儲存在瀏覽器中，除非人為刪除|瀏覽器或標籤頁關閉時自動刪除|\n|作用域|在同一個瀏覽器内，同源文件間共享，可互相讀取、覆蓋|因生命週期關係，僅在同個瀏覽器、同個標籤頁內的同源文件間才可共享|\n\n### 操作方法\n```javascript\n//sessionStorage用法相同\nlocalStorage.setItem();     // 儲存一個物件\nlocalStorage.getItem();     // 獲取物件內容\nlocalStorage.key();         // 獲取第i個物件\nlocalStorage.removeItem();  // 刪除一個物件\nlocalStorage.clear();       // 全部删除\n```\n透過上述的方法，就能夠將使用者的一些資料（例如搜尋字串等）儲存在該使用者的瀏覽器中，當下次再訪問這個網站時，就能夠使用這些資料來提升使用者體驗。\n\n---\n\n`cookie` 與 `session`\n---\n### `cookie`\n* 大小限制只有 4KB 左右\n* 通常會帶有使用者的 `sessionID` 供伺服器辨識\n* 由伺服器產生後保存在客戶端，可以設定多久失效\n* 每次都攜帶在 HTTP header 中\n\n### `session`\n* 保存在伺服器端\n* 存有使用者的敏感資料\n\n### `cookie` 與 `session` 的溝通\n當使用者訪問網站、通過身份認證後，伺服器端會送出一個 `cookie` 到客戶端，並建立一個 `sessionID` 存在 `cookie` 中。之後使用者只要通過該網站的身份認證，就能夠透過存在 `cookie` 中的 `sessionID` 查找到存在伺服器的 `session` 資料。\n\n---\n\n參考資料\n\n* [细说localStorage, sessionStorage, Cookie, Session](https://juejin.im/entry/5ac4d661f265da23a049c92a)\n* [介紹 Session 及 Cookie 兩者的差別說明](https://blog.hellojcc.tw/2016/01/12/introduce-session-and-cookie/)","slug":"web-cookie-session","published":1,"updated":"2022-03-12T12:58:21.767Z","_id":"cl0nusu61002oz6us4p0chls7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>這幾個東西有什麼不同？這是面試很常出現的基礎題，也是前端新手（*例如我）很容易霧煞煞的部分。為了加深印象，我決定來整理一篇筆記。</p>\n<span id=\"more\"></span>\n<p>在找資料的過程中，發現一個叫做 <code>session</code> 的東西，與 <code>cookie</code> 放在一起討論。這解釋了我其中一場面試的疑惑，當我在討論<code>localStorage</code> 與 <code>sessionStorage</code> 時，面試官卻說「<code>session</code> 應該是存在伺服器端的才對」，並且提到了 <code>cookie</code>。</p>\n<p>原因在這裡，我們講的是不同東西啊！面試官嘴裡說的是 <code>sessionStorage</code>，心裡想的卻是 <code>session</code>。</p>\n<p>真抱歉，我又不會通靈。</p>\n<hr>\n<h2 id=\"localStorage-與-sessionStorage\"><a href=\"#localStorage-與-sessionStorage\" class=\"headerlink\" title=\"localStorage 與 sessionStorage\"></a><code>localStorage</code> 與 <code>sessionStorage</code></h2><h3 id=\"相同特徵\"><a href=\"#相同特徵\" class=\"headerlink\" title=\"相同特徵\"></a>相同特徵</h3><ul>\n<li>儲存大小限制皆為 5MB 左右</li>\n<li>都有同源策略（CORS）限制</li>\n<li>僅在客戶端瀏覽器中存在</li>\n</ul>\n<h3 id=\"相異特徵\"><a href=\"#相異特徵\" class=\"headerlink\" title=\"相異特徵\"></a>相異特徵</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>生命週期</td>\n<td>永久儲存在瀏覽器中，除非人為刪除</td>\n<td>瀏覽器或標籤頁關閉時自動刪除</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>在同一個瀏覽器内，同源文件間共享，可互相讀取、覆蓋</td>\n<td>因生命週期關係，僅在同個瀏覽器、同個標籤頁內的同源文件間才可共享</td>\n</tr>\n</tbody></table>\n<h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sessionStorage用法相同</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>();     <span class=\"comment\">// 儲存一個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>();     <span class=\"comment\">// 獲取物件內容</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">key</span>();         <span class=\"comment\">// 獲取第i個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">removeItem</span>();  <span class=\"comment\">// 刪除一個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">clear</span>();       <span class=\"comment\">// 全部删除</span></span><br></pre></td></tr></table></figure>\n<p>透過上述的方法，就能夠將使用者的一些資料（例如搜尋字串等）儲存在該使用者的瀏覽器中，當下次再訪問這個網站時，就能夠使用這些資料來提升使用者體驗。</p>\n<hr>\n<h2 id=\"cookie-與-session\"><a href=\"#cookie-與-session\" class=\"headerlink\" title=\"cookie 與 session\"></a><code>cookie</code> 與 <code>session</code></h2><h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a><code>cookie</code></h3><ul>\n<li>大小限制只有 4KB 左右</li>\n<li>通常會帶有使用者的 <code>sessionID</code> 供伺服器辨識</li>\n<li>由伺服器產生後保存在客戶端，可以設定多久失效</li>\n<li>每次都攜帶在 HTTP header 中</li>\n</ul>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a><code>session</code></h3><ul>\n<li>保存在伺服器端</li>\n<li>存有使用者的敏感資料</li>\n</ul>\n<h3 id=\"cookie-與-session-的溝通\"><a href=\"#cookie-與-session-的溝通\" class=\"headerlink\" title=\"cookie 與 session 的溝通\"></a><code>cookie</code> 與 <code>session</code> 的溝通</h3><p>當使用者訪問網站、通過身份認證後，伺服器端會送出一個 <code>cookie</code> 到客戶端，並建立一個 <code>sessionID</code> 存在 <code>cookie</code> 中。之後使用者只要通過該網站的身份認證，就能夠透過存在 <code>cookie</code> 中的 <code>sessionID</code> 查找到存在伺服器的 <code>session</code> 資料。</p>\n<hr>\n<p>參考資料</p>\n<ul>\n<li><a class=\"link\"   href=\"https://juejin.im/entry/5ac4d661f265da23a049c92a\" >细说localStorage, sessionStorage, Cookie, Session<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.hellojcc.tw/2016/01/12/introduce-session-and-cookie/\" >介紹 Session 及 Cookie 兩者的差別說明<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>這幾個東西有什麼不同？這是面試很常出現的基礎題，也是前端新手（*例如我）很容易霧煞煞的部分。為了加深印象，我決定來整理一篇筆記。</p>","more":"<p>在找資料的過程中，發現一個叫做 <code>session</code> 的東西，與 <code>cookie</code> 放在一起討論。這解釋了我其中一場面試的疑惑，當我在討論<code>localStorage</code> 與 <code>sessionStorage</code> 時，面試官卻說「<code>session</code> 應該是存在伺服器端的才對」，並且提到了 <code>cookie</code>。</p>\n<p>原因在這裡，我們講的是不同東西啊！面試官嘴裡說的是 <code>sessionStorage</code>，心裡想的卻是 <code>session</code>。</p>\n<p>真抱歉，我又不會通靈。</p>\n<hr>\n<h2 id=\"localStorage-與-sessionStorage\"><a href=\"#localStorage-與-sessionStorage\" class=\"headerlink\" title=\"localStorage 與 sessionStorage\"></a><code>localStorage</code> 與 <code>sessionStorage</code></h2><h3 id=\"相同特徵\"><a href=\"#相同特徵\" class=\"headerlink\" title=\"相同特徵\"></a>相同特徵</h3><ul>\n<li>儲存大小限制皆為 5MB 左右</li>\n<li>都有同源策略（CORS）限制</li>\n<li>僅在客戶端瀏覽器中存在</li>\n</ul>\n<h3 id=\"相異特徵\"><a href=\"#相異特徵\" class=\"headerlink\" title=\"相異特徵\"></a>相異特徵</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>localStorage</th>\n<th>sessionStorage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>生命週期</td>\n<td>永久儲存在瀏覽器中，除非人為刪除</td>\n<td>瀏覽器或標籤頁關閉時自動刪除</td>\n</tr>\n<tr>\n<td>作用域</td>\n<td>在同一個瀏覽器内，同源文件間共享，可互相讀取、覆蓋</td>\n<td>因生命週期關係，僅在同個瀏覽器、同個標籤頁內的同源文件間才可共享</td>\n</tr>\n</tbody></table>\n<h3 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sessionStorage用法相同</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>();     <span class=\"comment\">// 儲存一個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>();     <span class=\"comment\">// 獲取物件內容</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">key</span>();         <span class=\"comment\">// 獲取第i個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">removeItem</span>();  <span class=\"comment\">// 刪除一個物件</span></span><br><span class=\"line\"><span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">clear</span>();       <span class=\"comment\">// 全部删除</span></span><br></pre></td></tr></table></figure>\n<p>透過上述的方法，就能夠將使用者的一些資料（例如搜尋字串等）儲存在該使用者的瀏覽器中，當下次再訪問這個網站時，就能夠使用這些資料來提升使用者體驗。</p>\n<hr>\n<h2 id=\"cookie-與-session\"><a href=\"#cookie-與-session\" class=\"headerlink\" title=\"cookie 與 session\"></a><code>cookie</code> 與 <code>session</code></h2><h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a><code>cookie</code></h3><ul>\n<li>大小限制只有 4KB 左右</li>\n<li>通常會帶有使用者的 <code>sessionID</code> 供伺服器辨識</li>\n<li>由伺服器產生後保存在客戶端，可以設定多久失效</li>\n<li>每次都攜帶在 HTTP header 中</li>\n</ul>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a><code>session</code></h3><ul>\n<li>保存在伺服器端</li>\n<li>存有使用者的敏感資料</li>\n</ul>\n<h3 id=\"cookie-與-session-的溝通\"><a href=\"#cookie-與-session-的溝通\" class=\"headerlink\" title=\"cookie 與 session 的溝通\"></a><code>cookie</code> 與 <code>session</code> 的溝通</h3><p>當使用者訪問網站、通過身份認證後，伺服器端會送出一個 <code>cookie</code> 到客戶端，並建立一個 <code>sessionID</code> 存在 <code>cookie</code> 中。之後使用者只要通過該網站的身份認證，就能夠透過存在 <code>cookie</code> 中的 <code>sessionID</code> 查找到存在伺服器的 <code>session</code> 資料。</p>\n<hr>\n<p>參考資料</p>\n<ul>\n<li><a class=\"link\"   href=\"https://juejin.im/entry/5ac4d661f265da23a049c92a\" >细说localStorage, sessionStorage, Cookie, Session<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.hellojcc.tw/2016/01/12/introduce-session-and-cookie/\" >介紹 Session 及 Cookie 兩者的差別說明<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Web 學習筆記 - HTTP","date":"2019-12-22T08:30:14.000Z","_content":"\nHTTP（`HyperText Transfer Protocol`）可說是學習 Web 知識的基本，不僅如此，他還是基本中的基本。因為接著要接觸到 `WebSocket`，必須先加深網路基礎知識，才能一步步攻破。\n\n<!--more-->\n\n---\n## `HTTP` 是什麼？\n\n首先要了解的是 `HTTP` 究竟是什麼碗糕？\n\n> HTTP（超文本傳輸協定）是一個用戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用 TCP 協定。\n\n也就是說，這是一種溝通標準，用來實現用戶與伺服器間的連接。只要依循這個標準，就能夠實現與伺服器間的互動。\n\n實際的流程會像這樣：\n* 用戶端發出一個請求\n* 與伺服器指定埠建立 TCP 連接\n* 伺服器收到請求，會返回狀態（例如 `200 ok`）及資源（請求的檔案..etc）\n* 用戶端收到狀態與資源\n\n### `HTTP` 請求方法\n\n`HTTP` 協定中定義了數種請求的方法，而程式新手（e.g. Me）最常使用到的就是以下四種：\n\n|方法|用途|\n|-|-|\n|`GET`|向伺服器送出「讀取資料」的請求|\n|`POST`|向伺服器送出「提交資料」的請求|\n|`PUT`|向指定的資源上傳「最新資料內容」|\n|`DELETE`|請求伺服器刪除指定的資源|\n\n### 伺服器返回狀態碼\n\n伺服器返回的狀態碼依據開頭的數字不同，代表著不同的狀態。以下是一個共通的類別，至於細項可以參考：[Http 狀態碼](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)\n\n|狀態碼|代表狀態|\n|-|-|\n|`1xx` 訊息|請求已被伺服器接收，繼續處理|\n|`2xx` 成功|請求已成功被伺服器接收、理解、並接受|\n|`3xx` 重新導向|需要後續操作才能完成這一請求|\n|`4xx` 請求錯誤|請求含有詞法錯誤或者無法被執行|\n|`5xx` 伺服器錯誤|伺服器在處理某個正確請求時發生錯誤|\n\n一般前端要操作 `Ajax`，會用 `if` 來判斷回傳的狀態是否為 `200`，是的話再做其他操作。\n\n```javascript\nif ( xhr.status === 200 ) {\n    //確定伺服器收到請求並處理了，繼續在本地做一些操作\n} else {\n    console.log(\"錯誤發生啦！狀態碼為: \", xhr.status)\n}\n```\n\n### `HTTP Request Header`\n\n`HTTP Request Header` 能夠在送出 `HTTP` 請求時，向伺服器明確闡述請求的類型。有些時候是必要的，例如向伺服器進行使用者的身份認證（`Authorization`），或設定跨來源資源共用（`CORS`）等等。 \n\n設定 `Header` 的方法：\n```javascript\nxhr.setRequestHeader(<header>, <value>);\n```\n\n### 跨來源資源共用（`Cross-Origin Resource Sharing`）\n\n對像我這樣的前端入門者而言，這是一個令人頭痛的問題。簡單來說，如果你今天向不同網域提供的 API 送出請求，此時就會產生一個跨來源 HTTP 請求（`cross-origin HTTP request`）。\n\n這代表什麼呢？除非提供資源的那一方，在回傳的回應裡有帶到寫著 `Access-Control-Allow-Origin` 或 `*` 的 `response header`，否則這會被瀏覽器判斷為一個跨來源的請求，而被擋下。\n\n關於 `CORS`，是個前端工程師必須面對的經典議題。但由於（不是魷魚）小弟我對 `CORS` 的認識也僅限於上述那麼淺白的程度，還沒辦法做個很好的解釋，因此就請各位自行參考網上大大們寫的文章了。\n\n\n---\n參考資料：\n* [MDN - HTTP](https://developer.mozilla.org/zh-TW/docs/Web/HTTP)\n* [Wiki - 超文本傳輸協定](https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n* [HTTP狀態碼](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)\n* [跨來源資源共用（CORS）](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS)\n* [原來 CORS 沒有我想像中的簡單](https://blog.techbridge.cc/2018/08/18/cors-issue/)\n* [輕鬆理解 Ajax 與跨來源請求](https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/)","source":"_posts/web-http.md","raw":"---\ntitle: Web 學習筆記 - HTTP\ndate: 2019-12-22 16:30:14\ntags: [http]\n---\n\nHTTP（`HyperText Transfer Protocol`）可說是學習 Web 知識的基本，不僅如此，他還是基本中的基本。因為接著要接觸到 `WebSocket`，必須先加深網路基礎知識，才能一步步攻破。\n\n<!--more-->\n\n---\n## `HTTP` 是什麼？\n\n首先要了解的是 `HTTP` 究竟是什麼碗糕？\n\n> HTTP（超文本傳輸協定）是一個用戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用 TCP 協定。\n\n也就是說，這是一種溝通標準，用來實現用戶與伺服器間的連接。只要依循這個標準，就能夠實現與伺服器間的互動。\n\n實際的流程會像這樣：\n* 用戶端發出一個請求\n* 與伺服器指定埠建立 TCP 連接\n* 伺服器收到請求，會返回狀態（例如 `200 ok`）及資源（請求的檔案..etc）\n* 用戶端收到狀態與資源\n\n### `HTTP` 請求方法\n\n`HTTP` 協定中定義了數種請求的方法，而程式新手（e.g. Me）最常使用到的就是以下四種：\n\n|方法|用途|\n|-|-|\n|`GET`|向伺服器送出「讀取資料」的請求|\n|`POST`|向伺服器送出「提交資料」的請求|\n|`PUT`|向指定的資源上傳「最新資料內容」|\n|`DELETE`|請求伺服器刪除指定的資源|\n\n### 伺服器返回狀態碼\n\n伺服器返回的狀態碼依據開頭的數字不同，代表著不同的狀態。以下是一個共通的類別，至於細項可以參考：[Http 狀態碼](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)\n\n|狀態碼|代表狀態|\n|-|-|\n|`1xx` 訊息|請求已被伺服器接收，繼續處理|\n|`2xx` 成功|請求已成功被伺服器接收、理解、並接受|\n|`3xx` 重新導向|需要後續操作才能完成這一請求|\n|`4xx` 請求錯誤|請求含有詞法錯誤或者無法被執行|\n|`5xx` 伺服器錯誤|伺服器在處理某個正確請求時發生錯誤|\n\n一般前端要操作 `Ajax`，會用 `if` 來判斷回傳的狀態是否為 `200`，是的話再做其他操作。\n\n```javascript\nif ( xhr.status === 200 ) {\n    //確定伺服器收到請求並處理了，繼續在本地做一些操作\n} else {\n    console.log(\"錯誤發生啦！狀態碼為: \", xhr.status)\n}\n```\n\n### `HTTP Request Header`\n\n`HTTP Request Header` 能夠在送出 `HTTP` 請求時，向伺服器明確闡述請求的類型。有些時候是必要的，例如向伺服器進行使用者的身份認證（`Authorization`），或設定跨來源資源共用（`CORS`）等等。 \n\n設定 `Header` 的方法：\n```javascript\nxhr.setRequestHeader(<header>, <value>);\n```\n\n### 跨來源資源共用（`Cross-Origin Resource Sharing`）\n\n對像我這樣的前端入門者而言，這是一個令人頭痛的問題。簡單來說，如果你今天向不同網域提供的 API 送出請求，此時就會產生一個跨來源 HTTP 請求（`cross-origin HTTP request`）。\n\n這代表什麼呢？除非提供資源的那一方，在回傳的回應裡有帶到寫著 `Access-Control-Allow-Origin` 或 `*` 的 `response header`，否則這會被瀏覽器判斷為一個跨來源的請求，而被擋下。\n\n關於 `CORS`，是個前端工程師必須面對的經典議題。但由於（不是魷魚）小弟我對 `CORS` 的認識也僅限於上述那麼淺白的程度，還沒辦法做個很好的解釋，因此就請各位自行參考網上大大們寫的文章了。\n\n\n---\n參考資料：\n* [MDN - HTTP](https://developer.mozilla.org/zh-TW/docs/Web/HTTP)\n* [Wiki - 超文本傳輸協定](https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE)\n* [HTTP狀態碼](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF)\n* [跨來源資源共用（CORS）](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS)\n* [原來 CORS 沒有我想像中的簡單](https://blog.techbridge.cc/2018/08/18/cors-issue/)\n* [輕鬆理解 Ajax 與跨來源請求](https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/)","slug":"web-http","published":1,"updated":"2022-03-12T12:58:21.823Z","_id":"cl0nusud60031z6us2iyw2ijb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>HTTP（<code>HyperText Transfer Protocol</code>）可說是學習 Web 知識的基本，不僅如此，他還是基本中的基本。因為接著要接觸到 <code>WebSocket</code>，必須先加深網路基礎知識，才能一步步攻破。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"HTTP-是什麼？\"><a href=\"#HTTP-是什麼？\" class=\"headerlink\" title=\"HTTP 是什麼？\"></a><code>HTTP</code> 是什麼？</h2><p>首先要了解的是 <code>HTTP</code> 究竟是什麼碗糕？</p>\n<blockquote>\n<p>HTTP（超文本傳輸協定）是一個用戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用 TCP 協定。</p>\n</blockquote>\n<p>也就是說，這是一種溝通標準，用來實現用戶與伺服器間的連接。只要依循這個標準，就能夠實現與伺服器間的互動。</p>\n<p>實際的流程會像這樣：</p>\n<ul>\n<li>用戶端發出一個請求</li>\n<li>與伺服器指定埠建立 TCP 連接</li>\n<li>伺服器收到請求，會返回狀態（例如 <code>200 ok</code>）及資源（請求的檔案..etc）</li>\n<li>用戶端收到狀態與資源</li>\n</ul>\n<h3 id=\"HTTP-請求方法\"><a href=\"#HTTP-請求方法\" class=\"headerlink\" title=\"HTTP 請求方法\"></a><code>HTTP</code> 請求方法</h3><p><code>HTTP</code> 協定中定義了數種請求的方法，而程式新手（e.g. Me）最常使用到的就是以下四種：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GET</code></td>\n<td>向伺服器送出「讀取資料」的請求</td>\n</tr>\n<tr>\n<td><code>POST</code></td>\n<td>向伺服器送出「提交資料」的請求</td>\n</tr>\n<tr>\n<td><code>PUT</code></td>\n<td>向指定的資源上傳「最新資料內容」</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>請求伺服器刪除指定的資源</td>\n</tr>\n</tbody></table>\n<h3 id=\"伺服器返回狀態碼\"><a href=\"#伺服器返回狀態碼\" class=\"headerlink\" title=\"伺服器返回狀態碼\"></a>伺服器返回狀態碼</h3><p>伺服器返回的狀態碼依據開頭的數字不同，代表著不同的狀態。以下是一個共通的類別，至於細項可以參考：<a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" >Http 狀態碼<i class=\"fas fa-external-link-alt\"></i></a></p>\n<table>\n<thead>\n<tr>\n<th>狀態碼</th>\n<th>代表狀態</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>1xx</code> 訊息</td>\n<td>請求已被伺服器接收，繼續處理</td>\n</tr>\n<tr>\n<td><code>2xx</code> 成功</td>\n<td>請求已成功被伺服器接收、理解、並接受</td>\n</tr>\n<tr>\n<td><code>3xx</code> 重新導向</td>\n<td>需要後續操作才能完成這一請求</td>\n</tr>\n<tr>\n<td><code>4xx</code> 請求錯誤</td>\n<td>請求含有詞法錯誤或者無法被執行</td>\n</tr>\n<tr>\n<td><code>5xx</code> 伺服器錯誤</td>\n<td>伺服器在處理某個正確請求時發生錯誤</td>\n</tr>\n</tbody></table>\n<p>一般前端要操作 <code>Ajax</code>，會用 <code>if</code> 來判斷回傳的狀態是否為 <code>200</code>，是的話再做其他操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( xhr.<span class=\"property\">status</span> === <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//確定伺服器收到請求並處理了，繼續在本地做一些操作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;錯誤發生啦！狀態碼為: &quot;</span>, xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-Request-Header\"><a href=\"#HTTP-Request-Header\" class=\"headerlink\" title=\"HTTP Request Header\"></a><code>HTTP Request Header</code></h3><p><code>HTTP Request Header</code> 能夠在送出 <code>HTTP</code> 請求時，向伺服器明確闡述請求的類型。有些時候是必要的，例如向伺服器進行使用者的身份認證（<code>Authorization</code>），或設定跨來源資源共用（<code>CORS</code>）等等。 </p>\n<p>設定 <code>Header</code> 的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">setRequestHeader</span>(&lt;header&gt;, &lt;value&gt;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨來源資源共用（Cross-Origin-Resource-Sharing）\"><a href=\"#跨來源資源共用（Cross-Origin-Resource-Sharing）\" class=\"headerlink\" title=\"跨來源資源共用（Cross-Origin Resource Sharing）\"></a>跨來源資源共用（<code>Cross-Origin Resource Sharing</code>）</h3><p>對像我這樣的前端入門者而言，這是一個令人頭痛的問題。簡單來說，如果你今天向不同網域提供的 API 送出請求，此時就會產生一個跨來源 HTTP 請求（<code>cross-origin HTTP request</code>）。</p>\n<p>這代表什麼呢？除非提供資源的那一方，在回傳的回應裡有帶到寫著 <code>Access-Control-Allow-Origin</code> 或 <code>*</code> 的 <code>response header</code>，否則這會被瀏覽器判斷為一個跨來源的請求，而被擋下。</p>\n<p>關於 <code>CORS</code>，是個前端工程師必須面對的經典議題。但由於（不是魷魚）小弟我對 <code>CORS</code> 的認識也僅限於上述那麼淺白的程度，還沒辦法做個很好的解釋，因此就請各位自行參考網上大大們寫的文章了。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP\" >MDN - HTTP<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" >Wiki - 超文本傳輸協定<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" >HTTP狀態碼<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS\" >跨來源資源共用（CORS）<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/08/18/cors-issue/\" >原來 CORS 沒有我想像中的簡單<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/\" >輕鬆理解 Ajax 與跨來源請求<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>HTTP（<code>HyperText Transfer Protocol</code>）可說是學習 Web 知識的基本，不僅如此，他還是基本中的基本。因為接著要接觸到 <code>WebSocket</code>，必須先加深網路基礎知識，才能一步步攻破。</p>","more":"<hr>\n<h2 id=\"HTTP-是什麼？\"><a href=\"#HTTP-是什麼？\" class=\"headerlink\" title=\"HTTP 是什麼？\"></a><code>HTTP</code> 是什麼？</h2><p>首先要了解的是 <code>HTTP</code> 究竟是什麼碗糕？</p>\n<blockquote>\n<p>HTTP（超文本傳輸協定）是一個用戶端（用戶）和伺服器端（網站）之間請求和應答的標準，通常使用 TCP 協定。</p>\n</blockquote>\n<p>也就是說，這是一種溝通標準，用來實現用戶與伺服器間的連接。只要依循這個標準，就能夠實現與伺服器間的互動。</p>\n<p>實際的流程會像這樣：</p>\n<ul>\n<li>用戶端發出一個請求</li>\n<li>與伺服器指定埠建立 TCP 連接</li>\n<li>伺服器收到請求，會返回狀態（例如 <code>200 ok</code>）及資源（請求的檔案..etc）</li>\n<li>用戶端收到狀態與資源</li>\n</ul>\n<h3 id=\"HTTP-請求方法\"><a href=\"#HTTP-請求方法\" class=\"headerlink\" title=\"HTTP 請求方法\"></a><code>HTTP</code> 請求方法</h3><p><code>HTTP</code> 協定中定義了數種請求的方法，而程式新手（e.g. Me）最常使用到的就是以下四種：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GET</code></td>\n<td>向伺服器送出「讀取資料」的請求</td>\n</tr>\n<tr>\n<td><code>POST</code></td>\n<td>向伺服器送出「提交資料」的請求</td>\n</tr>\n<tr>\n<td><code>PUT</code></td>\n<td>向指定的資源上傳「最新資料內容」</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>請求伺服器刪除指定的資源</td>\n</tr>\n</tbody></table>\n<h3 id=\"伺服器返回狀態碼\"><a href=\"#伺服器返回狀態碼\" class=\"headerlink\" title=\"伺服器返回狀態碼\"></a>伺服器返回狀態碼</h3><p>伺服器返回的狀態碼依據開頭的數字不同，代表著不同的狀態。以下是一個共通的類別，至於細項可以參考：<a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" >Http 狀態碼<i class=\"fas fa-external-link-alt\"></i></a></p>\n<table>\n<thead>\n<tr>\n<th>狀態碼</th>\n<th>代表狀態</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>1xx</code> 訊息</td>\n<td>請求已被伺服器接收，繼續處理</td>\n</tr>\n<tr>\n<td><code>2xx</code> 成功</td>\n<td>請求已成功被伺服器接收、理解、並接受</td>\n</tr>\n<tr>\n<td><code>3xx</code> 重新導向</td>\n<td>需要後續操作才能完成這一請求</td>\n</tr>\n<tr>\n<td><code>4xx</code> 請求錯誤</td>\n<td>請求含有詞法錯誤或者無法被執行</td>\n</tr>\n<tr>\n<td><code>5xx</code> 伺服器錯誤</td>\n<td>伺服器在處理某個正確請求時發生錯誤</td>\n</tr>\n</tbody></table>\n<p>一般前端要操作 <code>Ajax</code>，會用 <code>if</code> 來判斷回傳的狀態是否為 <code>200</code>，是的話再做其他操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( xhr.<span class=\"property\">status</span> === <span class=\"number\">200</span> ) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//確定伺服器收到請求並處理了，繼續在本地做一些操作</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;錯誤發生啦！狀態碼為: &quot;</span>, xhr.<span class=\"property\">status</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTTP-Request-Header\"><a href=\"#HTTP-Request-Header\" class=\"headerlink\" title=\"HTTP Request Header\"></a><code>HTTP Request Header</code></h3><p><code>HTTP Request Header</code> 能夠在送出 <code>HTTP</code> 請求時，向伺服器明確闡述請求的類型。有些時候是必要的，例如向伺服器進行使用者的身份認證（<code>Authorization</code>），或設定跨來源資源共用（<code>CORS</code>）等等。 </p>\n<p>設定 <code>Header</code> 的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">setRequestHeader</span>(&lt;header&gt;, &lt;value&gt;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨來源資源共用（Cross-Origin-Resource-Sharing）\"><a href=\"#跨來源資源共用（Cross-Origin-Resource-Sharing）\" class=\"headerlink\" title=\"跨來源資源共用（Cross-Origin Resource Sharing）\"></a>跨來源資源共用（<code>Cross-Origin Resource Sharing</code>）</h3><p>對像我這樣的前端入門者而言，這是一個令人頭痛的問題。簡單來說，如果你今天向不同網域提供的 API 送出請求，此時就會產生一個跨來源 HTTP 請求（<code>cross-origin HTTP request</code>）。</p>\n<p>這代表什麼呢？除非提供資源的那一方，在回傳的回應裡有帶到寫著 <code>Access-Control-Allow-Origin</code> 或 <code>*</code> 的 <code>response header</code>，否則這會被瀏覽器判斷為一個跨來源的請求，而被擋下。</p>\n<p>關於 <code>CORS</code>，是個前端工程師必須面對的經典議題。但由於（不是魷魚）小弟我對 <code>CORS</code> 的認識也僅限於上述那麼淺白的程度，還沒辦法做個很好的解釋，因此就請各位自行參考網上大大們寫的文章了。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP\" >MDN - HTTP<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/zh-tw/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE\" >Wiki - 超文本傳輸協定<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF\" >HTTP狀態碼<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS\" >跨來源資源共用（CORS）<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2018/08/18/cors-issue/\" >原來 CORS 沒有我想像中的簡單<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/\" >輕鬆理解 Ajax 與跨來源請求<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"Angular 學習筆記 - RxJS","date":"2022-05-03T05:06:15.000Z","_content":"\n因為專案使用 `Angular` 開發，而 `Angular` 提供 `RxJS Library` 來做非同步請求的管理，身為一個前端工程師，為了讓程式碼更精簡好讀（~~也為了看起來更厲害~~），認真了解 `RxJS` 絕對是必要的。\n\n<!--more-->\n\n---\n## 什麼是 ReactiveX？\n\nReactiveX 在官網（[https://reactivex.io](https://reactivex.io）的首頁開宗明義寫道：\n> An API for asynchronous programming with observable streams.\n\n由此可知 `ReactiveX` 的出發點是「對可觀察的串流做非同步處理」，而`RxJS` 是可用 `JavaScript` 操作的 Library。\n\n另外，ReactiveX 對自己的定義則是：\n> ReactiveX is a combination of the best ideas from\nthe Observer pattern, the Iterator pattern, and functional programming.\n\n也就是說，這是一個集結了下列三種設計模式精華的好開發方式：\n* Observer Pattern\n* Iterator Pattern\n* Functional Programming\n\n了解 `RxJS` 後，再回來看這串定義，就比較能夠體會了。\n\n\n---\n## 如何使用 Angular RxJS Library？\n\n在 `Angular` 中要使用 `RxJS` 處理資料流，可以使用一個叫做 `pipe` 的 API 來將處理方式包起來：\n```javascript=\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError, tap, take } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n    take(1),\n    map((res: any) => {\n        // 使用 map 對資料流中每一個資料做一些操作\n        if ( !res.response ) {\n            throw new Error('Value expected!');\n        }\n        return res.response;\n    }),\n    catchError(err => {\n        // 當發現錯誤時，用 of 建立一個新的 Observable 並回傳\n        console.log(err);\n        return of([]);\n    }),\n    tap((data: any) => {\n        // 透過 tap 對資料做一些操作\n        console.log(data);\n    })\n);\n\n// 訂閱 Observable 物件來執行觀察\napiData.subscribe();\n```\n\n### API & Operators\n\n整理我自己常用的 API 與 operators：\n\n* `pipe`：將多個 operators 包裝起來\n* `tap`：將資料取出來做處理，沒有其他衍伸效果\n* `takeUntil`：訂閱此 Observable，直到觸及設定的條件\n* `of`：建立一個新的 Observable\n* `catchError`：捕捉錯誤\n* `debounceTime`：為了不過度頻繁地發出非同步請求，設定一個延遲時間\n* `take`：只取 N 筆資料\n* `map`：遍歷串流中的每一筆資料\n* `filter`：根據條件篩選出要的資料\n* `switchMap`：在串流中發出另一筆非同步請求，並回傳一個 Observable\n\n\n---\n## 總結\n\n目前我自己在 Angular 專案中所使用的 `RxJS`，全部都是用來處理 AJAX 請求的，在程式碼撰寫風格上逐漸建立起一定的習慣，也增加了易讀性與可擴充性。\n\n以上就是目前對 `RxJS` 粗淺的了解。\n\n\n---\n參考資料：\n* [TechBridge 技術共筆部落格 - 希望是最淺顯易懂的 RxJS 教學](https://blog.techbridge.cc/2017/12/08/rxjs/)\n* [Will 保哥 - RxJS6 新手入門](https://www.youtube.com/watch?v=BA1vSZwzkK8)\n* [iT邦幫忙 - 30 天精通 RxJS](https://ithelp.ithome.com.tw/users/20103367/ironman/1199)\n* [Angular RxJS 函式庫](https://angular.tw/guide/rx-library)\n","source":"_posts/Angular-RxJS.md","raw":"---\ntitle: Angular 學習筆記 - RxJS\ndate: 2022-05-03 13:06:15\ntags: [Angular, JavaScript, RxJS]\n---\n\n因為專案使用 `Angular` 開發，而 `Angular` 提供 `RxJS Library` 來做非同步請求的管理，身為一個前端工程師，為了讓程式碼更精簡好讀（~~也為了看起來更厲害~~），認真了解 `RxJS` 絕對是必要的。\n\n<!--more-->\n\n---\n## 什麼是 ReactiveX？\n\nReactiveX 在官網（[https://reactivex.io](https://reactivex.io）的首頁開宗明義寫道：\n> An API for asynchronous programming with observable streams.\n\n由此可知 `ReactiveX` 的出發點是「對可觀察的串流做非同步處理」，而`RxJS` 是可用 `JavaScript` 操作的 Library。\n\n另外，ReactiveX 對自己的定義則是：\n> ReactiveX is a combination of the best ideas from\nthe Observer pattern, the Iterator pattern, and functional programming.\n\n也就是說，這是一個集結了下列三種設計模式精華的好開發方式：\n* Observer Pattern\n* Iterator Pattern\n* Functional Programming\n\n了解 `RxJS` 後，再回來看這串定義，就比較能夠體會了。\n\n\n---\n## 如何使用 Angular RxJS Library？\n\n在 `Angular` 中要使用 `RxJS` 處理資料流，可以使用一個叫做 `pipe` 的 API 來將處理方式包起來：\n```javascript=\nimport { Observable, of } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError, tap, take } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n    take(1),\n    map((res: any) => {\n        // 使用 map 對資料流中每一個資料做一些操作\n        if ( !res.response ) {\n            throw new Error('Value expected!');\n        }\n        return res.response;\n    }),\n    catchError(err => {\n        // 當發現錯誤時，用 of 建立一個新的 Observable 並回傳\n        console.log(err);\n        return of([]);\n    }),\n    tap((data: any) => {\n        // 透過 tap 對資料做一些操作\n        console.log(data);\n    })\n);\n\n// 訂閱 Observable 物件來執行觀察\napiData.subscribe();\n```\n\n### API & Operators\n\n整理我自己常用的 API 與 operators：\n\n* `pipe`：將多個 operators 包裝起來\n* `tap`：將資料取出來做處理，沒有其他衍伸效果\n* `takeUntil`：訂閱此 Observable，直到觸及設定的條件\n* `of`：建立一個新的 Observable\n* `catchError`：捕捉錯誤\n* `debounceTime`：為了不過度頻繁地發出非同步請求，設定一個延遲時間\n* `take`：只取 N 筆資料\n* `map`：遍歷串流中的每一筆資料\n* `filter`：根據條件篩選出要的資料\n* `switchMap`：在串流中發出另一筆非同步請求，並回傳一個 Observable\n\n\n---\n## 總結\n\n目前我自己在 Angular 專案中所使用的 `RxJS`，全部都是用來處理 AJAX 請求的，在程式碼撰寫風格上逐漸建立起一定的習慣，也增加了易讀性與可擴充性。\n\n以上就是目前對 `RxJS` 粗淺的了解。\n\n\n---\n參考資料：\n* [TechBridge 技術共筆部落格 - 希望是最淺顯易懂的 RxJS 教學](https://blog.techbridge.cc/2017/12/08/rxjs/)\n* [Will 保哥 - RxJS6 新手入門](https://www.youtube.com/watch?v=BA1vSZwzkK8)\n* [iT邦幫忙 - 30 天精通 RxJS](https://ithelp.ithome.com.tw/users/20103367/ironman/1199)\n* [Angular RxJS 函式庫](https://angular.tw/guide/rx-library)\n","slug":"Angular-RxJS","published":1,"updated":"2022-05-03T05:25:35.497Z","_id":"cl2pp4ph20000uwar9lzy1ayk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因為專案使用 <code>Angular</code> 開發，而 <code>Angular</code> 提供 <code>RxJS Library</code> 來做非同步請求的管理，身為一個前端工程師，為了讓程式碼更精簡好讀（<del>也為了看起來更厲害</del>），認真了解 <code>RxJS</code> 絕對是必要的。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h2 id=\"什麼是-ReactiveX？\"><a href=\"#什麼是-ReactiveX？\" class=\"headerlink\" title=\"什麼是 ReactiveX？\"></a>什麼是 ReactiveX？</h2><p>ReactiveX 在官網（[<a href=\"https://reactivex.io]\">https://reactivex.io]</a>(<a href=\"https://reactivex.io）的首頁開宗明義寫道：\">https://reactivex.io）的首頁開宗明義寫道：</a></p>\n<blockquote>\n<p>An API for asynchronous programming with observable streams.</p>\n</blockquote>\n<p>由此可知 <code>ReactiveX</code> 的出發點是「對可觀察的串流做非同步處理」，而<code>RxJS</code> 是可用 <code>JavaScript</code> 操作的 Library。</p>\n<p>另外，ReactiveX 對自己的定義則是：</p>\n<blockquote>\n<p>ReactiveX is a combination of the best ideas from<br>the Observer pattern, the Iterator pattern, and functional programming.</p>\n</blockquote>\n<p>也就是說，這是一個集結了下列三種設計模式精華的好開發方式：</p>\n<ul>\n<li>Observer Pattern</li>\n<li>Iterator Pattern</li>\n<li>Functional Programming</li>\n</ul>\n<p>了解 <code>RxJS</code> 後，再回來看這串定義，就比較能夠體會了。</p>\n<hr>\n<h2 id=\"如何使用-Angular-RxJS-Library？\"><a href=\"#如何使用-Angular-RxJS-Library？\" class=\"headerlink\" title=\"如何使用 Angular RxJS Library？\"></a>如何使用 Angular RxJS Library？</h2><p>在 <code>Angular</code> 中要使用 <code>RxJS</code> 處理資料流，可以使用一個叫做 <code>pipe</code> 的 API 來將處理方式包起來：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span>, <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ajax &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/ajax&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; map, catchError, tap, take &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/operators&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiData = <span class=\"title function_\">ajax</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">    <span class=\"title function_\">take</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">    <span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">res: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 map 對資料流中每一個資料做一些操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !res.<span class=\"property\">response</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Value expected!&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.<span class=\"property\">response</span>;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"title function_\">catchError</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 當發現錯誤時，用 of 建立一個新的 Observable 並回傳</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>([]);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"title function_\">tap</span>(<span class=\"function\">(<span class=\"params\">data: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 透過 tap 對資料做一些操作</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 訂閱 Observable 物件來執行觀察</span></span><br><span class=\"line\">apiData.<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"API-amp-Operators\"><a href=\"#API-amp-Operators\" class=\"headerlink\" title=\"API &amp; Operators\"></a>API &amp; Operators</h3><p>整理我自己常用的 API 與 operators：</p>\n<ul>\n<li><code>pipe</code>：將多個 operators 包裝起來</li>\n<li><code>tap</code>：將資料取出來做處理，沒有其他衍伸效果</li>\n<li><code>takeUntil</code>：訂閱此 Observable，直到觸及設定的條件</li>\n<li><code>of</code>：建立一個新的 Observable</li>\n<li><code>catchError</code>：捕捉錯誤</li>\n<li><code>debounceTime</code>：為了不過度頻繁地發出非同步請求，設定一個延遲時間</li>\n<li><code>take</code>：只取 N 筆資料</li>\n<li><code>map</code>：遍歷串流中的每一筆資料</li>\n<li><code>filter</code>：根據條件篩選出要的資料</li>\n<li><code>switchMap</code>：在串流中發出另一筆非同步請求，並回傳一個 Observable</li>\n</ul>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>目前我自己在 Angular 專案中所使用的 <code>RxJS</code>，全部都是用來處理 AJAX 請求的，在程式碼撰寫風格上逐漸建立起一定的習慣，也增加了易讀性與可擴充性。</p>\n<p>以上就是目前對 <code>RxJS</code> 粗淺的了解。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/12/08/rxjs/\" >TechBridge 技術共筆部落格 - 希望是最淺顯易懂的 RxJS 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=BA1vSZwzkK8\" >Will 保哥 - RxJS6 新手入門<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/users/20103367/ironman/1199\" >iT邦幫忙 - 30 天精通 RxJS<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://angular.tw/guide/rx-library\" >Angular RxJS 函式庫<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>因為專案使用 <code>Angular</code> 開發，而 <code>Angular</code> 提供 <code>RxJS Library</code> 來做非同步請求的管理，身為一個前端工程師，為了讓程式碼更精簡好讀（<del>也為了看起來更厲害</del>），認真了解 <code>RxJS</code> 絕對是必要的。</p>","more":"<hr>\n<h2 id=\"什麼是-ReactiveX？\"><a href=\"#什麼是-ReactiveX？\" class=\"headerlink\" title=\"什麼是 ReactiveX？\"></a>什麼是 ReactiveX？</h2><p>ReactiveX 在官網（[<a href=\"https://reactivex.io]\">https://reactivex.io]</a>(<a href=\"https://reactivex.io）的首頁開宗明義寫道：\">https://reactivex.io）的首頁開宗明義寫道：</a></p>\n<blockquote>\n<p>An API for asynchronous programming with observable streams.</p>\n</blockquote>\n<p>由此可知 <code>ReactiveX</code> 的出發點是「對可觀察的串流做非同步處理」，而<code>RxJS</code> 是可用 <code>JavaScript</code> 操作的 Library。</p>\n<p>另外，ReactiveX 對自己的定義則是：</p>\n<blockquote>\n<p>ReactiveX is a combination of the best ideas from<br>the Observer pattern, the Iterator pattern, and functional programming.</p>\n</blockquote>\n<p>也就是說，這是一個集結了下列三種設計模式精華的好開發方式：</p>\n<ul>\n<li>Observer Pattern</li>\n<li>Iterator Pattern</li>\n<li>Functional Programming</li>\n</ul>\n<p>了解 <code>RxJS</code> 後，再回來看這串定義，就比較能夠體會了。</p>\n<hr>\n<h2 id=\"如何使用-Angular-RxJS-Library？\"><a href=\"#如何使用-Angular-RxJS-Library？\" class=\"headerlink\" title=\"如何使用 Angular RxJS Library？\"></a>如何使用 Angular RxJS Library？</h2><p>在 <code>Angular</code> 中要使用 <code>RxJS</code> 處理資料流，可以使用一個叫做 <code>pipe</code> 的 API 來將處理方式包起來：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Observable</span>, <span class=\"keyword\">of</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ajax &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/ajax&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; map, catchError, tap, take &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/operators&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiData = <span class=\"title function_\">ajax</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>).<span class=\"title function_\">pipe</span>(</span><br><span class=\"line\">    <span class=\"title function_\">take</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">    <span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">res: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 map 對資料流中每一個資料做一些操作</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !res.<span class=\"property\">response</span> ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;Value expected!&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.<span class=\"property\">response</span>;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"title function_\">catchError</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 當發現錯誤時，用 of 建立一個新的 Observable 並回傳</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">of</span>([]);</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    <span class=\"title function_\">tap</span>(<span class=\"function\">(<span class=\"params\">data: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 透過 tap 對資料做一些操作</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 訂閱 Observable 物件來執行觀察</span></span><br><span class=\"line\">apiData.<span class=\"title function_\">subscribe</span>();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"API-amp-Operators\"><a href=\"#API-amp-Operators\" class=\"headerlink\" title=\"API &amp; Operators\"></a>API &amp; Operators</h3><p>整理我自己常用的 API 與 operators：</p>\n<ul>\n<li><code>pipe</code>：將多個 operators 包裝起來</li>\n<li><code>tap</code>：將資料取出來做處理，沒有其他衍伸效果</li>\n<li><code>takeUntil</code>：訂閱此 Observable，直到觸及設定的條件</li>\n<li><code>of</code>：建立一個新的 Observable</li>\n<li><code>catchError</code>：捕捉錯誤</li>\n<li><code>debounceTime</code>：為了不過度頻繁地發出非同步請求，設定一個延遲時間</li>\n<li><code>take</code>：只取 N 筆資料</li>\n<li><code>map</code>：遍歷串流中的每一筆資料</li>\n<li><code>filter</code>：根據條件篩選出要的資料</li>\n<li><code>switchMap</code>：在串流中發出另一筆非同步請求，並回傳一個 Observable</li>\n</ul>\n<hr>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>目前我自己在 Angular 專案中所使用的 <code>RxJS</code>，全部都是用來處理 AJAX 請求的，在程式碼撰寫風格上逐漸建立起一定的習慣，也增加了易讀性與可擴充性。</p>\n<p>以上就是目前對 <code>RxJS</code> 粗淺的了解。</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://blog.techbridge.cc/2017/12/08/rxjs/\" >TechBridge 技術共筆部落格 - 希望是最淺顯易懂的 RxJS 教學<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.youtube.com/watch?v=BA1vSZwzkK8\" >Will 保哥 - RxJS6 新手入門<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://ithelp.ithome.com.tw/users/20103367/ironman/1199\" >iT邦幫忙 - 30 天精通 RxJS<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://angular.tw/guide/rx-library\" >Angular RxJS 函式庫<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"},{"title":"TypeScript 學習筆記 - 初探","date":"2023-02-09T04:38:12.000Z","_content":"\n因為專案使用 `Angular` 的關係，我在開發上逐漸習慣都使用 `TypeScript`，甚至連近期在練習使用 `Node.js` 寫後端專案，也會盡可能使用 `TypeScript`。用習慣了之後，再回去看原生的 `JavaScript`，總是會感到渾身不對勁。\n\n<!--more-->\n\n線上測試 `TypeScript`：https://www.typescriptlang.org/play\n\n---\n## 什麼是 TypeScript？\n\n> 一言以蔽之，就是「基於 JavaScript，但能夠定義型別」的程式語言。\n\n當一段程式碼在 `JavaScript` 長這樣：\n```javascript=\nlet whatIsThis;\n// 經過一串程式碼，塞入了不曉得什麼鬼東西...\nconsole.log(whatIsThis);\n// 可能是任何東西...\n```\n\n在 `TyepScript` 中就會長這樣：\n```typescript=\nlet whatIsThis: string[];\n// 經過一串程式碼，塞入了不曉得什麼鬼東西...\nconsole.log(whatIsThis);\n// 你知道他一定是個字串陣列\n```\n\n`TypeScript` 的好處就是能夠「清楚地定義型別」，大幅提升程式碼在閱讀與維護上的容易程度。\n\n剛開始使用 `TypeScript` 的時候，可能會覺得很麻煩，需要多寫一堆程式碼來定義明擺著的事實，但當專案變大、程式碼變長了之後，你會逐漸發覺很多錯誤都能提早避免，而不是等到要 run code 的時候才報錯。\n\n---\n## Enum & Interface & Class\n\n不僅在維護上，使用 `TypeScript` 也能讓開發更有效率。舉例來說：\n```typescript=\n// 定義一個 Book 介面\ninterface Book {\n    author: string;\n    pages: number;\n}\n\n// 定義一個 Library 類別\nclass Library {\n    private books: Book[] = [];\n    constructor(books: Book[]) {\n        this.books = books;\n    }\n\n    // 取得所有的 Book\n    public getBooks(): Book[] {\n        return this.books;\n    }\n\n    // 增加新的 Book\n    public addBook(newBook: Book): Book[] {\n        this.books.push(newBook);\n        return this.books;\n    }\n}\n\n// 定義 books 的型別為 Book[]，在建立內容時 TypeScript 就會檢查是否符合 Book 屬性\nconst books: Book[] = [\n    {author: 'John', pages: 20},\n    {author: 'Jane', pages: 50},\n    {author: 'Peter', pages: 100},\n    {name: 'Hello', pages: 10} // 會因為 Book 介面沒有 name 屬性而報錯，在開發期間就知道這裡會有錯誤\n]\nlet library = new Library(books);\nlibrary.getBooks();\n```\n\n或者可以更方便地使用繼承／擴充，讓程式碼更結構化：\n```typescript=\n// 使用 enum 直接依順序列舉\nenum LegsEnum {\n    noLeg,   // 0\n    twoLegs, // 1\n    fourLegs // 2\n}\n\ninterface Animal {\n    legsType: number;\n    canFly: boolean;\n    sound(): string; // Animal 天生就可以叫\n}\n\nclass Snake implements Animal {\n    legsType = LegsEnum.noLeg; // 可以直接指派 enum 的值，legsType === 0\n    canFly = false;\n    sound(): string {\n        return 'sss';\n    }\n}\n\nclass Dog implements Animal {\n    legsType = LegsEnum.twoLegs;\n    canFly = false;\n    sound(): string {\n        return 'bark bark';\n    }\n}\n\nclass Bird implements Animal {\n    legsType = LegsEnum.twoLegs;\n    canFly = true;\n    sound(): string {\n        return 'jo jo';\n    }\n}\n```\n\n如此一來，看著程式碼就可以很迅速地理解各種類別帶有的屬性及方法，光是這點就足以預防很多笨笨的錯誤了。\n\n在開發時，`TypeScript` 也會幫你列出正在使用的類別所帶有的屬性及方法，例如：\n```typescript=\nlet bird1 = new Bird();\nbird1. // 當程式碼寫到這裡時，會列出以下東西\n// bird1.legsType\n// bird1.canFly\n// bird1.sound\n```\n\n實在是相當便利。\n\n另外一個好處是，當程式碼需要改動時，`TypeScript` 會自動檢查出還有哪些地方是需要修正的，不會在程式碼上線時才 crash。\n\n`TypeScript` 真的是個好東西，尤其對於想把程式碼定義清楚的人而言，尤其推薦！\n\n---\n參考資料：\n* [What are the differences between TypeScript and JavaScript?](https://www.sanity.io/typescript-guide/typescript-vs-javascript)\n* [An Introduction to TypeScript Interfaces](https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238)","source":"_posts/typescript-basic.md","raw":"---\ntitle: TypeScript 學習筆記 - 初探\ndate: 2023-02-09 12:38:12\ntags: [TypeScript]\n---\n\n因為專案使用 `Angular` 的關係，我在開發上逐漸習慣都使用 `TypeScript`，甚至連近期在練習使用 `Node.js` 寫後端專案，也會盡可能使用 `TypeScript`。用習慣了之後，再回去看原生的 `JavaScript`，總是會感到渾身不對勁。\n\n<!--more-->\n\n線上測試 `TypeScript`：https://www.typescriptlang.org/play\n\n---\n## 什麼是 TypeScript？\n\n> 一言以蔽之，就是「基於 JavaScript，但能夠定義型別」的程式語言。\n\n當一段程式碼在 `JavaScript` 長這樣：\n```javascript=\nlet whatIsThis;\n// 經過一串程式碼，塞入了不曉得什麼鬼東西...\nconsole.log(whatIsThis);\n// 可能是任何東西...\n```\n\n在 `TyepScript` 中就會長這樣：\n```typescript=\nlet whatIsThis: string[];\n// 經過一串程式碼，塞入了不曉得什麼鬼東西...\nconsole.log(whatIsThis);\n// 你知道他一定是個字串陣列\n```\n\n`TypeScript` 的好處就是能夠「清楚地定義型別」，大幅提升程式碼在閱讀與維護上的容易程度。\n\n剛開始使用 `TypeScript` 的時候，可能會覺得很麻煩，需要多寫一堆程式碼來定義明擺著的事實，但當專案變大、程式碼變長了之後，你會逐漸發覺很多錯誤都能提早避免，而不是等到要 run code 的時候才報錯。\n\n---\n## Enum & Interface & Class\n\n不僅在維護上，使用 `TypeScript` 也能讓開發更有效率。舉例來說：\n```typescript=\n// 定義一個 Book 介面\ninterface Book {\n    author: string;\n    pages: number;\n}\n\n// 定義一個 Library 類別\nclass Library {\n    private books: Book[] = [];\n    constructor(books: Book[]) {\n        this.books = books;\n    }\n\n    // 取得所有的 Book\n    public getBooks(): Book[] {\n        return this.books;\n    }\n\n    // 增加新的 Book\n    public addBook(newBook: Book): Book[] {\n        this.books.push(newBook);\n        return this.books;\n    }\n}\n\n// 定義 books 的型別為 Book[]，在建立內容時 TypeScript 就會檢查是否符合 Book 屬性\nconst books: Book[] = [\n    {author: 'John', pages: 20},\n    {author: 'Jane', pages: 50},\n    {author: 'Peter', pages: 100},\n    {name: 'Hello', pages: 10} // 會因為 Book 介面沒有 name 屬性而報錯，在開發期間就知道這裡會有錯誤\n]\nlet library = new Library(books);\nlibrary.getBooks();\n```\n\n或者可以更方便地使用繼承／擴充，讓程式碼更結構化：\n```typescript=\n// 使用 enum 直接依順序列舉\nenum LegsEnum {\n    noLeg,   // 0\n    twoLegs, // 1\n    fourLegs // 2\n}\n\ninterface Animal {\n    legsType: number;\n    canFly: boolean;\n    sound(): string; // Animal 天生就可以叫\n}\n\nclass Snake implements Animal {\n    legsType = LegsEnum.noLeg; // 可以直接指派 enum 的值，legsType === 0\n    canFly = false;\n    sound(): string {\n        return 'sss';\n    }\n}\n\nclass Dog implements Animal {\n    legsType = LegsEnum.twoLegs;\n    canFly = false;\n    sound(): string {\n        return 'bark bark';\n    }\n}\n\nclass Bird implements Animal {\n    legsType = LegsEnum.twoLegs;\n    canFly = true;\n    sound(): string {\n        return 'jo jo';\n    }\n}\n```\n\n如此一來，看著程式碼就可以很迅速地理解各種類別帶有的屬性及方法，光是這點就足以預防很多笨笨的錯誤了。\n\n在開發時，`TypeScript` 也會幫你列出正在使用的類別所帶有的屬性及方法，例如：\n```typescript=\nlet bird1 = new Bird();\nbird1. // 當程式碼寫到這裡時，會列出以下東西\n// bird1.legsType\n// bird1.canFly\n// bird1.sound\n```\n\n實在是相當便利。\n\n另外一個好處是，當程式碼需要改動時，`TypeScript` 會自動檢查出還有哪些地方是需要修正的，不會在程式碼上線時才 crash。\n\n`TypeScript` 真的是個好東西，尤其對於想把程式碼定義清楚的人而言，尤其推薦！\n\n---\n參考資料：\n* [What are the differences between TypeScript and JavaScript?](https://www.sanity.io/typescript-guide/typescript-vs-javascript)\n* [An Introduction to TypeScript Interfaces](https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238)","slug":"typescript-basic","published":1,"updated":"2023-02-09T04:40:27.398Z","_id":"cldwm1cna00006nar9nzc9x9v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因為專案使用 <code>Angular</code> 的關係，我在開發上逐漸習慣都使用 <code>TypeScript</code>，甚至連近期在練習使用 <code>Node.js</code> 寫後端專案，也會盡可能使用 <code>TypeScript</code>。用習慣了之後，再回去看原生的 <code>JavaScript</code>，總是會感到渾身不對勁。</p>\n<span id=\"more\"></span>\n\n<p>線上測試 <code>TypeScript</code>：<a class=\"link\"   href=\"https://www.typescriptlang.org/play\" >https://www.typescriptlang.org/play<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h2 id=\"什麼是-TypeScript？\"><a href=\"#什麼是-TypeScript？\" class=\"headerlink\" title=\"什麼是 TypeScript？\"></a>什麼是 TypeScript？</h2><blockquote>\n<p>一言以蔽之，就是「基於 JavaScript，但能夠定義型別」的程式語言。</p>\n</blockquote>\n<p>當一段程式碼在 <code>JavaScript</code> 長這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> whatIsThis;</span><br><span class=\"line\"><span class=\"comment\">// 經過一串程式碼，塞入了不曉得什麼鬼東西...</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(whatIsThis);</span><br><span class=\"line\"><span class=\"comment\">// 可能是任何東西...</span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>TyepScript</code> 中就會長這樣：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">whatIsThis</span>: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\"><span class=\"comment\">// 經過一串程式碼，塞入了不曉得什麼鬼東西...</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(whatIsThis);</span><br><span class=\"line\"><span class=\"comment\">// 你知道他一定是個字串陣列</span></span><br></pre></td></tr></table></figure>\n\n<p><code>TypeScript</code> 的好處就是能夠「清楚地定義型別」，大幅提升程式碼在閱讀與維護上的容易程度。</p>\n<p>剛開始使用 <code>TypeScript</code> 的時候，可能會覺得很麻煩，需要多寫一堆程式碼來定義明擺著的事實，但當專案變大、程式碼變長了之後，你會逐漸發覺很多錯誤都能提早避免，而不是等到要 run code 的時候才報錯。</p>\n<hr>\n<h2 id=\"Enum-amp-Interface-amp-Class\"><a href=\"#Enum-amp-Interface-amp-Class\" class=\"headerlink\" title=\"Enum &amp; Interface &amp; Class\"></a>Enum &amp; Interface &amp; Class</h2><p>不僅在維護上，使用 <code>TypeScript</code> 也能讓開發更有效率。舉例來說：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義一個 Book 介面</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Book</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">author</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">pages</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個 Library 類別</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Library</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">books</span>: <span class=\"title class_\">Book</span>[] = [];</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">books: Book[]</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">books</span> = books;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 取得所有的 Book</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">getBooks</span>(): <span class=\"title class_\">Book</span>[] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加新的 Book</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">addBook</span>(<span class=\"attr\">newBook</span>: <span class=\"title class_\">Book</span>): <span class=\"title class_\">Book</span>[] &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>.<span class=\"title function_\">push</span>(newBook);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義 books 的型別為 Book[]，在建立內容時 TypeScript 就會檢查是否符合 Book 屬性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">books</span>: <span class=\"title class_\">Book</span>[] = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;Peter&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">10</span>&#125; <span class=\"comment\">// 會因為 Book 介面沒有 name 屬性而報錯，在開發期間就知道這裡會有錯誤</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> library = <span class=\"keyword\">new</span> <span class=\"title class_\">Library</span>(books);</span><br><span class=\"line\">library.<span class=\"title function_\">getBooks</span>();</span><br></pre></td></tr></table></figure>\n\n<p>或者可以更方便地使用繼承／擴充，讓程式碼更結構化：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 enum 直接依順序列舉</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LegsEnum</span> &#123;</span><br><span class=\"line\">    noLeg,   <span class=\"comment\">// 0</span></span><br><span class=\"line\">    twoLegs, <span class=\"comment\">// 1</span></span><br><span class=\"line\">    fourLegs <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">legsType</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">canFly</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span>; <span class=\"comment\">// Animal 天生就可以叫</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Snake</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">noLeg</span>; <span class=\"comment\">// 可以直接指派 enum 的值，legsType === 0</span></span><br><span class=\"line\">    canFly = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;sss&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">twoLegs</span>;</span><br><span class=\"line\">    canFly = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;bark bark&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bird</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">twoLegs</span>;</span><br><span class=\"line\">    canFly = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jo jo&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如此一來，看著程式碼就可以很迅速地理解各種類別帶有的屬性及方法，光是這點就足以預防很多笨笨的錯誤了。</p>\n<p>在開發時，<code>TypeScript</code> 也會幫你列出正在使用的類別所帶有的屬性及方法，例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bird1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Bird</span>();</span><br><span class=\"line\">bird1. <span class=\"comment\">// 當程式碼寫到這裡時，會列出以下東西</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.legsType</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.canFly</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.sound</span></span><br></pre></td></tr></table></figure>\n\n<p>實在是相當便利。</p>\n<p>另外一個好處是，當程式碼需要改動時，<code>TypeScript</code> 會自動檢查出還有哪些地方是需要修正的，不會在程式碼上線時才 crash。</p>\n<p><code>TypeScript</code> 真的是個好東西，尤其對於想把程式碼定義清楚的人而言，尤其推薦！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.sanity.io/typescript-guide/typescript-vs-javascript\" >What are the differences between TypeScript and JavaScript?<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238\" >An Introduction to TypeScript Interfaces<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>因為專案使用 <code>Angular</code> 的關係，我在開發上逐漸習慣都使用 <code>TypeScript</code>，甚至連近期在練習使用 <code>Node.js</code> 寫後端專案，也會盡可能使用 <code>TypeScript</code>。用習慣了之後，再回去看原生的 <code>JavaScript</code>，總是會感到渾身不對勁。</p>","more":"<p>線上測試 <code>TypeScript</code>：<a class=\"link\"   href=\"https://www.typescriptlang.org/play\" >https://www.typescriptlang.org/play<i class=\"fas fa-external-link-alt\"></i></a></p>\n<hr>\n<h2 id=\"什麼是-TypeScript？\"><a href=\"#什麼是-TypeScript？\" class=\"headerlink\" title=\"什麼是 TypeScript？\"></a>什麼是 TypeScript？</h2><blockquote>\n<p>一言以蔽之，就是「基於 JavaScript，但能夠定義型別」的程式語言。</p>\n</blockquote>\n<p>當一段程式碼在 <code>JavaScript</code> 長這樣：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> whatIsThis;</span><br><span class=\"line\"><span class=\"comment\">// 經過一串程式碼，塞入了不曉得什麼鬼東西...</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(whatIsThis);</span><br><span class=\"line\"><span class=\"comment\">// 可能是任何東西...</span></span><br></pre></td></tr></table></figure>\n\n<p>在 <code>TyepScript</code> 中就會長這樣：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">whatIsThis</span>: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\"><span class=\"comment\">// 經過一串程式碼，塞入了不曉得什麼鬼東西...</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(whatIsThis);</span><br><span class=\"line\"><span class=\"comment\">// 你知道他一定是個字串陣列</span></span><br></pre></td></tr></table></figure>\n\n<p><code>TypeScript</code> 的好處就是能夠「清楚地定義型別」，大幅提升程式碼在閱讀與維護上的容易程度。</p>\n<p>剛開始使用 <code>TypeScript</code> 的時候，可能會覺得很麻煩，需要多寫一堆程式碼來定義明擺著的事實，但當專案變大、程式碼變長了之後，你會逐漸發覺很多錯誤都能提早避免，而不是等到要 run code 的時候才報錯。</p>\n<hr>\n<h2 id=\"Enum-amp-Interface-amp-Class\"><a href=\"#Enum-amp-Interface-amp-Class\" class=\"headerlink\" title=\"Enum &amp; Interface &amp; Class\"></a>Enum &amp; Interface &amp; Class</h2><p>不僅在維護上，使用 <code>TypeScript</code> 也能讓開發更有效率。舉例來說：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義一個 Book 介面</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Book</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">author</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"attr\">pages</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義一個 Library 類別</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Library</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"attr\">books</span>: <span class=\"title class_\">Book</span>[] = [];</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">books: Book[]</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">books</span> = books;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 取得所有的 Book</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">getBooks</span>(): <span class=\"title class_\">Book</span>[] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 增加新的 Book</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">addBook</span>(<span class=\"attr\">newBook</span>: <span class=\"title class_\">Book</span>): <span class=\"title class_\">Book</span>[] &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>.<span class=\"title function_\">push</span>(newBook);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">books</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定義 books 的型別為 Book[]，在建立內容時 TypeScript 就會檢查是否符合 Book 屬性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">books</span>: <span class=\"title class_\">Book</span>[] = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;John&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">20</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">author</span>: <span class=\"string\">&#x27;Peter&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;Hello&#x27;</span>, <span class=\"attr\">pages</span>: <span class=\"number\">10</span>&#125; <span class=\"comment\">// 會因為 Book 介面沒有 name 屬性而報錯，在開發期間就知道這裡會有錯誤</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> library = <span class=\"keyword\">new</span> <span class=\"title class_\">Library</span>(books);</span><br><span class=\"line\">library.<span class=\"title function_\">getBooks</span>();</span><br></pre></td></tr></table></figure>\n\n<p>或者可以更方便地使用繼承／擴充，讓程式碼更結構化：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 enum 直接依順序列舉</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">LegsEnum</span> &#123;</span><br><span class=\"line\">    noLeg,   <span class=\"comment\">// 0</span></span><br><span class=\"line\">    twoLegs, <span class=\"comment\">// 1</span></span><br><span class=\"line\">    fourLegs <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">legsType</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">canFly</span>: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span>; <span class=\"comment\">// Animal 天生就可以叫</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Snake</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">noLeg</span>; <span class=\"comment\">// 可以直接指派 enum 的值，legsType === 0</span></span><br><span class=\"line\">    canFly = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;sss&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">twoLegs</span>;</span><br><span class=\"line\">    canFly = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;bark bark&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bird</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    legsType = <span class=\"title class_\">LegsEnum</span>.<span class=\"property\">twoLegs</span>;</span><br><span class=\"line\">    canFly = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"title function_\">sound</span>(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;jo jo&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如此一來，看著程式碼就可以很迅速地理解各種類別帶有的屬性及方法，光是這點就足以預防很多笨笨的錯誤了。</p>\n<p>在開發時，<code>TypeScript</code> 也會幫你列出正在使用的類別所帶有的屬性及方法，例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> bird1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Bird</span>();</span><br><span class=\"line\">bird1. <span class=\"comment\">// 當程式碼寫到這裡時，會列出以下東西</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.legsType</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.canFly</span></span><br><span class=\"line\"><span class=\"comment\">// bird1.sound</span></span><br></pre></td></tr></table></figure>\n\n<p>實在是相當便利。</p>\n<p>另外一個好處是，當程式碼需要改動時，<code>TypeScript</code> 會自動檢查出還有哪些地方是需要修正的，不會在程式碼上線時才 crash。</p>\n<p><code>TypeScript</code> 真的是個好東西，尤其對於想把程式碼定義清楚的人而言，尤其推薦！</p>\n<hr>\n<p>參考資料：</p>\n<ul>\n<li><a class=\"link\"   href=\"https://www.sanity.io/typescript-guide/typescript-vs-javascript\" >What are the differences between TypeScript and JavaScript?<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://betterprogramming.pub/introduction-to-typescript-interfaces-extending-interfaces-and-classes-af10fcfc1238\" >An Introduction to TypeScript Interfaces<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl0nuss4k0001z6us8jj37ko9","tag_id":"cl0nuss4p0002z6us8mle6i05","_id":"cl0nuss4s0004z6usa5v2a297"},{"post_id":"cl0nuss4k0001z6us8jj37ko9","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nuss4s0005z6us8b41f7g1"},{"post_id":"cl0nuss730006z6us7cgj8fg3","tag_id":"cl0nuss4p0002z6us8mle6i05","_id":"cl0nuss780008z6usgiw89zec"},{"post_id":"cl0nuss730006z6us7cgj8fg3","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nuss780009z6usbe9ue642"},{"post_id":"cl0nuss730006z6us7cgj8fg3","tag_id":"cl0nuss770007z6us7z0l7pok","_id":"cl0nuss78000az6us7a2281t3"},{"post_id":"cl0nussjc000bz6ush0gs9why","tag_id":"cl0nussjd000cz6us24ar1p82","_id":"cl0nussje000dz6usg1etany4"},{"post_id":"cl0nusskv000ez6us5crb0y0x","tag_id":"cl0nussjd000cz6us24ar1p82","_id":"cl0nussl1000gz6usgq2l8qpn"},{"post_id":"cl0nusskz000fz6us2olq3k7x","tag_id":"cl0nussl2000hz6us76sa506e","_id":"cl0nussl3000jz6usaojq5i0j"},{"post_id":"cl0nusskz000fz6us2olq3k7x","tag_id":"cl0nussl2000iz6usgdaggddx","_id":"cl0nussl3000kz6usghi05heo"},{"post_id":"cl0nusss7000lz6us39sx8rbf","tag_id":"cl0nusss9000mz6us673kfmal","_id":"cl0nusssa000nz6uscupp3d7k"},{"post_id":"cl0nusswh000oz6us9ltwah3y","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nusswk000qz6uscvxibugy"},{"post_id":"cl0nusswh000oz6us9ltwah3y","tag_id":"cl0nusswj000pz6us6cbogrme","_id":"cl0nusswk000rz6us8dq32snf"},{"post_id":"cl0nussxq000sz6us1qrd8qal","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nussxr000tz6us234q7lzs"},{"post_id":"cl0nussya000uz6us38za21pc","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nussye000yz6us0ytc96eg"},{"post_id":"cl0nussya000uz6us38za21pc","tag_id":"cl0nussyc000wz6us39p94oi1","_id":"cl0nussye000zz6usfdkiewdd"},{"post_id":"cl0nussyb000vz6us4mo97wc5","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nussyh0011z6usgvyc60og"},{"post_id":"cl0nussyb000vz6us4mo97wc5","tag_id":"cl0nussyd000xz6userh09b7u","_id":"cl0nussyh0012z6us04u72h3o"},{"post_id":"cl0nussyb000vz6us4mo97wc5","tag_id":"cl0nussye0010z6us30bv513n","_id":"cl0nussyi0013z6us2ucrhzan"},{"post_id":"cl0nust130014z6us93q5e39b","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nust140015z6usau3l9as7"},{"post_id":"cl0nust7b0016z6us7g9h6eox","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nust7d001az6us2rcth2gg"},{"post_id":"cl0nust7b0016z6us7g9h6eox","tag_id":"cl0nust7c0018z6usajh9b2ma","_id":"cl0nust7d001bz6us4jw3dits"},{"post_id":"cl0nust7b0017z6usb3an7wvz","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl0nust7d001cz6us3qakh6v3"},{"post_id":"cl0nust7b0017z6usb3an7wvz","tag_id":"cl0nust7d0019z6usc41r8byq","_id":"cl0nust7d001dz6usg9kufi3h"},{"post_id":"cl0nust7f001ez6us549r0xr0","tag_id":"cl0nust7f001fz6us2iic11le","_id":"cl0nust7h001iz6usfuiq79vj"},{"post_id":"cl0nust7f001ez6us549r0xr0","tag_id":"cl0nust7g001gz6us3khq4seh","_id":"cl0nust7h001jz6us8b9f4qmr"},{"post_id":"cl0nust7f001ez6us549r0xr0","tag_id":"cl0nust7g001hz6usbatobaqz","_id":"cl0nust7h001kz6us4dah3qo9"},{"post_id":"cl0nusta4001lz6us036z73bf","tag_id":"cl0nusta5001mz6useo5q8r0k","_id":"cl0nusta5001nz6ush70l867z"},{"post_id":"cl0nusta4001lz6us036z73bf","tag_id":"cl0nust7g001gz6us3khq4seh","_id":"cl0nusta6001oz6us3ate9e40"},{"post_id":"cl0nusta4001lz6us036z73bf","tag_id":"cl0nust7g001hz6usbatobaqz","_id":"cl0nusta6001pz6us3h1k3d4q"},{"post_id":"cl0nustcy001qz6us1p012ul6","tag_id":"cl0nustd0001rz6us9mrgbbmy","_id":"cl0nustd1001sz6ushm865tso"},{"post_id":"cl0nustir001tz6us01vee6ay","tag_id":"cl0nustis001uz6us4k94evr7","_id":"cl0nustit001vz6us1ac8bqcz"},{"post_id":"cl0nustss001wz6us1c8oeia0","tag_id":"cl0nustst001xz6usga6rfzne","_id":"cl0nustst001yz6us62ehepwl"},{"post_id":"cl0nustva001zz6us1eifgqof","tag_id":"cl0nustvb0020z6usbek0hlf1","_id":"cl0nustvd0023z6us0v0b7rz2"},{"post_id":"cl0nustva001zz6us1eifgqof","tag_id":"cl0nustvc0021z6us7ygf3cmt","_id":"cl0nustvd0024z6us6m4ehe3f"},{"post_id":"cl0nustva001zz6us1eifgqof","tag_id":"cl0nustvc0022z6usgmv27hsx","_id":"cl0nustvd0025z6us6j5ygvdl"},{"post_id":"cl0nustxw0026z6ushmks9z26","tag_id":"cl0nussl2000hz6us76sa506e","_id":"cl0nusty1002cz6us13av25jn"},{"post_id":"cl0nustxw0026z6ushmks9z26","tag_id":"cl0nustxx0028z6us4p0kh8np","_id":"cl0nusty2002dz6us3q1e07lo"},{"post_id":"cl0nustxw0026z6ushmks9z26","tag_id":"cl0nustxy0029z6us0r969jck","_id":"cl0nusty2002ez6uscir691vb"},{"post_id":"cl0nustxw0026z6ushmks9z26","tag_id":"cl0nustxy002az6usa0pa859w","_id":"cl0nusty2002fz6usbp083lqq"},{"post_id":"cl0nustxx0027z6us95ob969x","tag_id":"cl0nusty1002bz6usgfuf4z6p","_id":"cl0nusty2002gz6usgcsqf2po"},{"post_id":"cl0nusu0m002hz6usham694e4","tag_id":"cl0nusu0n002iz6us0moh1uji","_id":"cl0nusu0n002jz6usdzfc8rox"},{"post_id":"cl0nusu3e002kz6us1c75habg","tag_id":"cl0nusu3g002lz6usbuz65v6h","_id":"cl0nusu3g002mz6ush16h63my"},{"post_id":"cl0nusu60002nz6usdcoe2hus","tag_id":"cl0nusu62002pz6usf3b994pj","_id":"cl0nusu62002rz6usfhr69q2b"},{"post_id":"cl0nusu61002oz6us4p0chls7","tag_id":"cl0nusu62002qz6usblt1dcmu","_id":"cl0nusu65002wz6us645t7e0p"},{"post_id":"cl0nusu61002oz6us4p0chls7","tag_id":"cl0nusu63002sz6usb2h9eem5","_id":"cl0nusu65002xz6usgysefosu"},{"post_id":"cl0nusu61002oz6us4p0chls7","tag_id":"cl0nusu63002tz6usgzv72iz0","_id":"cl0nusu65002yz6us546d20af"},{"post_id":"cl0nusu61002oz6us4p0chls7","tag_id":"cl0nusu63002uz6us90k35tfa","_id":"cl0nusu65002zz6us2bnihwyw"},{"post_id":"cl0nusu61002oz6us4p0chls7","tag_id":"cl0nusu63002vz6us8x0k0xxa","_id":"cl0nusu650030z6uscj0qeivt"},{"post_id":"cl0nusud60031z6us2iyw2ijb","tag_id":"cl0nusud80032z6us7iek5ulr","_id":"cl0nusud80033z6usathtbkb5"},{"post_id":"cl2pp4ph20000uwar9lzy1ayk","tag_id":"cl0nuss4p0002z6us8mle6i05","_id":"cl2pp4phq0002uwarhew7fzl4"},{"post_id":"cl2pp4ph20000uwar9lzy1ayk","tag_id":"cl0nuss4q0003z6us3jpjd35n","_id":"cl2pp4phq0003uwardzlwc9wz"},{"post_id":"cl2pp4ph20000uwar9lzy1ayk","tag_id":"cl2pp4pha0001uwar5y60gpd8","_id":"cl2pp4phq0004uwarbwmthp01"},{"post_id":"cldwm1cna00006nar9nzc9x9v","tag_id":"cl0nustvc0021z6us7ygf3cmt","_id":"cldwm1cni00016nareeu61ijs"}],"Tag":[{"name":"Angular","_id":"cl0nuss4p0002z6us8mle6i05"},{"name":"JavaScript","_id":"cl0nuss4q0003z6us3jpjd35n"},{"name":"LifeCycle","_id":"cl0nuss770007z6us7z0l7pok"},{"name":"git","_id":"cl0nussjd000cz6us24ar1p82"},{"name":"後端開發","_id":"cl0nussl2000hz6us76sa506e"},{"name":"Go","_id":"cl0nussl2000iz6usgdaggddx"},{"name":"html","_id":"cl0nusss9000mz6us673kfmal"},{"name":"Ajax","_id":"cl0nusswj000pz6us6cbogrme"},{"name":"closure","_id":"cl0nussyc000wz6us39p94oi1"},{"name":"class","_id":"cl0nussyd000xz6userh09b7u"},{"name":"prototype","_id":"cl0nussye0010z6us30bv513n"},{"name":"XMLHttpRequest","_id":"cl0nust7c0018z6usajh9b2ma"},{"name":"hoisting","_id":"cl0nust7d0019z6usc41r8byq"},{"name":"Journalctl","_id":"cl0nust7f001fz6us2iic11le"},{"name":"Systemd","_id":"cl0nust7g001gz6us3khq4seh"},{"name":"Linux","_id":"cl0nust7g001hz6usbatobaqz"},{"name":"Systemctl","_id":"cl0nusta5001mz6useo5q8r0k"},{"name":"hexo","_id":"cl0nustd0001rz6us9mrgbbmy"},{"name":"nginx","_id":"cl0nustis001uz6us4k94evr7"},{"name":"Node.js","_id":"cl0nustst001xz6usga6rfzne"},{"name":"OOP","_id":"cl0nustvb0020z6usbek0hlf1"},{"name":"TypeScript","_id":"cl0nustvc0021z6us7ygf3cmt"},{"name":"SOLID","_id":"cl0nustvc0022z6usgmv27hsx"},{"name":"Python","_id":"cl0nustxx0028z6us4p0kh8np"},{"name":"API","_id":"cl0nustxy0029z6us0r969jck"},{"name":"NAS","_id":"cl0nustxy002az6usa0pa859w"},{"name":"Career","_id":"cl0nusty1002bz6usgfuf4z6p"},{"name":"自我管理","_id":"cl0nusu0n002iz6us0moh1uji"},{"name":"fullStack","_id":"cl0nusu3g002lz6usbuz65v6h"},{"name":"vue.js","_id":"cl0nusu62002pz6usf3b994pj"},{"name":"web","_id":"cl0nusu62002qz6usblt1dcmu"},{"name":"localStorage","_id":"cl0nusu63002sz6usb2h9eem5"},{"name":"sessionStorage","_id":"cl0nusu63002tz6usgzv72iz0"},{"name":"cookie","_id":"cl0nusu63002uz6us90k35tfa"},{"name":"session","_id":"cl0nusu63002vz6us8x0k0xxa"},{"name":"http","_id":"cl0nusud80032z6us7iek5ulr"},{"name":"RxJS","_id":"cl2pp4pha0001uwar5y60gpd8"}]}}